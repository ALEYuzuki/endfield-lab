"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3";
exports.ids = ["vendor-chunks/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs":
/*!*******************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MAX_FIELD_DEPTH: () => (/* binding */ DEFAULT_MAX_FIELD_DEPTH),\n/* harmony export */   DEFAULT_OVERRIDEABLE_FIELDS: () => (/* binding */ DEFAULT_OVERRIDEABLE_FIELDS),\n/* harmony export */   OWN_PROPS_NAME: () => (/* binding */ OWN_PROPS_NAME),\n/* harmony export */   resolveSearchConfig: () => (/* binding */ resolveSearchConfig),\n/* harmony export */   resolveSearchConfigForBaseFieldPaths: () => (/* binding */ resolveSearchConfigForBaseFieldPaths)\n/* harmony export */ });\n/* harmony import */ var lodash_isFinite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isFinite.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFinite.js\");\n/* harmony import */ var lodash_uniqBy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/uniqBy.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniqBy.js\");\n\n\nconst DEFAULT_OVERRIDEABLE_FIELDS = [\n  \"jsonType\",\n  \"type\",\n  \"name\",\n  \"title\",\n  \"description\",\n  \"options\",\n  \"fieldsets\",\n  \"validation\",\n  \"readOnly\",\n  \"hidden\",\n  \"components\",\n  \"diffComponent\",\n  \"initialValue\",\n  \"deprecated\"\n], OWN_PROPS_NAME = \"_internal_ownProps\", DEFAULT_MAX_FIELD_DEPTH = 5, stringFieldsSymbols = {}, getStringFieldSymbol = (maxDepth) => (stringFieldsSymbols[maxDepth] || (stringFieldsSymbols[maxDepth] = Symbol(`__cachedStringFields_${maxDepth}`)), stringFieldsSymbols[maxDepth]), isReference = (type) => type.type && type.type.name === \"reference\", portableTextFields = [\"style\", \"list\"], isPortableTextBlock = (type) => type.name === \"block\" || type.type && isPortableTextBlock(type.type), isPortableTextArray = (type) => type.jsonType === \"array\" && Array.isArray(type.of) && type.of.some(isPortableTextBlock);\nfunction reduceType(type, reducer, acc, path = [], maxDepth) {\n  if (maxDepth < 0)\n    return acc;\n  const accumulator = reducer(acc, type, path);\n  return type.jsonType === \"array\" && Array.isArray(type.of) ? reduceArray(type, reducer, accumulator, path, maxDepth) : type.jsonType === \"object\" && Array.isArray(type.fields) && !isReference(type) ? reduceObject(type, reducer, accumulator, path, maxDepth) : accumulator;\n}\nfunction reduceArray(arrayType, reducer, accumulator, path, maxDepth) {\n  return arrayType.of.reduce(\n    (acc, ofType) => reduceType(ofType, reducer, acc, path, maxDepth - 1),\n    accumulator\n  );\n}\nfunction reduceObject(objectType, reducer, accumulator, path, maxDepth) {\n  const isPtBlock = isPortableTextBlock(objectType);\n  return objectType.fields.reduce((acc, field) => {\n    if (isPtBlock && portableTextFields.includes(field.name))\n      return acc;\n    const segment = [field.name].concat(field.type.jsonType === \"array\" ? [[]] : []);\n    return reduceType(field.type, reducer, acc, path.concat(segment), maxDepth - 1);\n  }, accumulator);\n}\nconst BASE_WEIGHTS = [\n  { weight: 1, path: [\"_id\"] },\n  { weight: 1, path: [\"_type\"] }\n], PREVIEW_FIELD_WEIGHT_MAP = {\n  title: 10,\n  subtitle: 5,\n  description: 1.5\n};\nfunction deriveFromPreview(type, maxDepth) {\n  const select = type?.preview?.select;\n  if (!select)\n    return [];\n  const fields = [];\n  for (const fieldName of Object.keys(select)) {\n    if (!(fieldName in PREVIEW_FIELD_WEIGHT_MAP))\n      continue;\n    const path = select[fieldName].split(\".\");\n    maxDepth > -1 && path.length - 1 > maxDepth || fields.push({\n      weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],\n      path\n    });\n  }\n  return fields;\n}\nfunction getCachedStringFieldPaths(type, maxDepth) {\n  const symbol = getStringFieldSymbol(maxDepth);\n  return type[symbol] || (type[symbol] = lodash_uniqBy_js__WEBPACK_IMPORTED_MODULE_1__(\n    [\n      ...BASE_WEIGHTS,\n      ...deriveFromPreview(type, maxDepth),\n      ...getStringFieldPaths(type, maxDepth).map((path) => ({ weight: 1, path })),\n      ...getPortableTextFieldPaths(type, maxDepth).map((path) => ({\n        weight: 1,\n        path,\n        mapWith: \"pt::text\"\n      }))\n    ],\n    (spec) => spec.path.join(\".\")\n  )), type[symbol];\n}\nfunction getCachedBaseFieldPaths(type, maxDepth) {\n  const symbol = getStringFieldSymbol(maxDepth);\n  return type[symbol] || (type[symbol] = lodash_uniqBy_js__WEBPACK_IMPORTED_MODULE_1__(\n    [...BASE_WEIGHTS, ...deriveFromPreview(type, maxDepth)],\n    (spec) => spec.path.join(\".\")\n  )), type[symbol];\n}\nfunction getStringFieldPaths(type, maxDepth) {\n  return reduceType(type, (accumulator, childType, path) => childType.jsonType === \"string\" ? [...accumulator, path] : accumulator, [], [], maxDepth);\n}\nfunction getPortableTextFieldPaths(type, maxDepth) {\n  return reduceType(type, (accumulator, childType, path) => isPortableTextArray(childType) ? [...accumulator, path] : accumulator, [], [], maxDepth);\n}\nfunction resolveSearchConfigForBaseFieldPaths(type, maxDepth) {\n  return getCachedBaseFieldPaths(type, normalizeMaxDepth(maxDepth));\n}\nfunction resolveSearchConfig(type, maxDepth) {\n  return getCachedStringFieldPaths(type, normalizeMaxDepth(maxDepth));\n}\nfunction normalizeMaxDepth(maxDepth) {\n  return !lodash_isFinite_js__WEBPACK_IMPORTED_MODULE_0__(maxDepth) || maxDepth < 1 || maxDepth > DEFAULT_MAX_FIELD_DEPTH ? DEFAULT_MAX_FIELD_DEPTH - 1 : maxDepth - 1;\n}\n\n//# sourceMappingURL=resolve.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrc2NoZW1hQDMuOTkuMF9AdHlwZXMrcmVhY3RAMTguMy4yNF9kZWJ1Z0A0LjQuMy9ub2RlX21vZHVsZXMvQHNhbml0eS9zY2hlbWEvbGliL19jaHVua3MtZXMvcmVzb2x2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwQztBQUNKO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRix5SUFBeUksU0FBUztBQUNqUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSSwwQkFBMEI7QUFDOUIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2Q0FBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2Q0FBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQ0FBUTtBQUNsQjtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAc2FuaXR5K3NjaGVtYUAzLjk5LjBfQHR5cGVzK3JlYWN0QDE4LjMuMjRfZGVidWdANC40LjNcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcc2NoZW1hXFxsaWJcXF9jaHVua3MtZXNcXHJlc29sdmUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBpc0Zpbml0ZSBmcm9tIFwibG9kYXNoL2lzRmluaXRlLmpzXCI7XG5pbXBvcnQgdW5pcUJ5IGZyb20gXCJsb2Rhc2gvdW5pcUJ5LmpzXCI7XG5jb25zdCBERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFMgPSBbXG4gIFwianNvblR5cGVcIixcbiAgXCJ0eXBlXCIsXG4gIFwibmFtZVwiLFxuICBcInRpdGxlXCIsXG4gIFwiZGVzY3JpcHRpb25cIixcbiAgXCJvcHRpb25zXCIsXG4gIFwiZmllbGRzZXRzXCIsXG4gIFwidmFsaWRhdGlvblwiLFxuICBcInJlYWRPbmx5XCIsXG4gIFwiaGlkZGVuXCIsXG4gIFwiY29tcG9uZW50c1wiLFxuICBcImRpZmZDb21wb25lbnRcIixcbiAgXCJpbml0aWFsVmFsdWVcIixcbiAgXCJkZXByZWNhdGVkXCJcbl0sIE9XTl9QUk9QU19OQU1FID0gXCJfaW50ZXJuYWxfb3duUHJvcHNcIiwgREVGQVVMVF9NQVhfRklFTERfREVQVEggPSA1LCBzdHJpbmdGaWVsZHNTeW1ib2xzID0ge30sIGdldFN0cmluZ0ZpZWxkU3ltYm9sID0gKG1heERlcHRoKSA9PiAoc3RyaW5nRmllbGRzU3ltYm9sc1ttYXhEZXB0aF0gfHwgKHN0cmluZ0ZpZWxkc1N5bWJvbHNbbWF4RGVwdGhdID0gU3ltYm9sKGBfX2NhY2hlZFN0cmluZ0ZpZWxkc18ke21heERlcHRofWApKSwgc3RyaW5nRmllbGRzU3ltYm9sc1ttYXhEZXB0aF0pLCBpc1JlZmVyZW5jZSA9ICh0eXBlKSA9PiB0eXBlLnR5cGUgJiYgdHlwZS50eXBlLm5hbWUgPT09IFwicmVmZXJlbmNlXCIsIHBvcnRhYmxlVGV4dEZpZWxkcyA9IFtcInN0eWxlXCIsIFwibGlzdFwiXSwgaXNQb3J0YWJsZVRleHRCbG9jayA9ICh0eXBlKSA9PiB0eXBlLm5hbWUgPT09IFwiYmxvY2tcIiB8fCB0eXBlLnR5cGUgJiYgaXNQb3J0YWJsZVRleHRCbG9jayh0eXBlLnR5cGUpLCBpc1BvcnRhYmxlVGV4dEFycmF5ID0gKHR5cGUpID0+IHR5cGUuanNvblR5cGUgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KHR5cGUub2YpICYmIHR5cGUub2Yuc29tZShpc1BvcnRhYmxlVGV4dEJsb2NrKTtcbmZ1bmN0aW9uIHJlZHVjZVR5cGUodHlwZSwgcmVkdWNlciwgYWNjLCBwYXRoID0gW10sIG1heERlcHRoKSB7XG4gIGlmIChtYXhEZXB0aCA8IDApXG4gICAgcmV0dXJuIGFjYztcbiAgY29uc3QgYWNjdW11bGF0b3IgPSByZWR1Y2VyKGFjYywgdHlwZSwgcGF0aCk7XG4gIHJldHVybiB0eXBlLmpzb25UeXBlID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheSh0eXBlLm9mKSA/IHJlZHVjZUFycmF5KHR5cGUsIHJlZHVjZXIsIGFjY3VtdWxhdG9yLCBwYXRoLCBtYXhEZXB0aCkgOiB0eXBlLmpzb25UeXBlID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkodHlwZS5maWVsZHMpICYmICFpc1JlZmVyZW5jZSh0eXBlKSA/IHJlZHVjZU9iamVjdCh0eXBlLCByZWR1Y2VyLCBhY2N1bXVsYXRvciwgcGF0aCwgbWF4RGVwdGgpIDogYWNjdW11bGF0b3I7XG59XG5mdW5jdGlvbiByZWR1Y2VBcnJheShhcnJheVR5cGUsIHJlZHVjZXIsIGFjY3VtdWxhdG9yLCBwYXRoLCBtYXhEZXB0aCkge1xuICByZXR1cm4gYXJyYXlUeXBlLm9mLnJlZHVjZShcbiAgICAoYWNjLCBvZlR5cGUpID0+IHJlZHVjZVR5cGUob2ZUeXBlLCByZWR1Y2VyLCBhY2MsIHBhdGgsIG1heERlcHRoIC0gMSksXG4gICAgYWNjdW11bGF0b3JcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlZHVjZU9iamVjdChvYmplY3RUeXBlLCByZWR1Y2VyLCBhY2N1bXVsYXRvciwgcGF0aCwgbWF4RGVwdGgpIHtcbiAgY29uc3QgaXNQdEJsb2NrID0gaXNQb3J0YWJsZVRleHRCbG9jayhvYmplY3RUeXBlKTtcbiAgcmV0dXJuIG9iamVjdFR5cGUuZmllbGRzLnJlZHVjZSgoYWNjLCBmaWVsZCkgPT4ge1xuICAgIGlmIChpc1B0QmxvY2sgJiYgcG9ydGFibGVUZXh0RmllbGRzLmluY2x1ZGVzKGZpZWxkLm5hbWUpKVxuICAgICAgcmV0dXJuIGFjYztcbiAgICBjb25zdCBzZWdtZW50ID0gW2ZpZWxkLm5hbWVdLmNvbmNhdChmaWVsZC50eXBlLmpzb25UeXBlID09PSBcImFycmF5XCIgPyBbW11dIDogW10pO1xuICAgIHJldHVybiByZWR1Y2VUeXBlKGZpZWxkLnR5cGUsIHJlZHVjZXIsIGFjYywgcGF0aC5jb25jYXQoc2VnbWVudCksIG1heERlcHRoIC0gMSk7XG4gIH0sIGFjY3VtdWxhdG9yKTtcbn1cbmNvbnN0IEJBU0VfV0VJR0hUUyA9IFtcbiAgeyB3ZWlnaHQ6IDEsIHBhdGg6IFtcIl9pZFwiXSB9LFxuICB7IHdlaWdodDogMSwgcGF0aDogW1wiX3R5cGVcIl0gfVxuXSwgUFJFVklFV19GSUVMRF9XRUlHSFRfTUFQID0ge1xuICB0aXRsZTogMTAsXG4gIHN1YnRpdGxlOiA1LFxuICBkZXNjcmlwdGlvbjogMS41XG59O1xuZnVuY3Rpb24gZGVyaXZlRnJvbVByZXZpZXcodHlwZSwgbWF4RGVwdGgpIHtcbiAgY29uc3Qgc2VsZWN0ID0gdHlwZT8ucHJldmlldz8uc2VsZWN0O1xuICBpZiAoIXNlbGVjdClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGZpZWxkcyA9IFtdO1xuICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBPYmplY3Qua2V5cyhzZWxlY3QpKSB7XG4gICAgaWYgKCEoZmllbGROYW1lIGluIFBSRVZJRVdfRklFTERfV0VJR0hUX01BUCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBwYXRoID0gc2VsZWN0W2ZpZWxkTmFtZV0uc3BsaXQoXCIuXCIpO1xuICAgIG1heERlcHRoID4gLTEgJiYgcGF0aC5sZW5ndGggLSAxID4gbWF4RGVwdGggfHwgZmllbGRzLnB1c2goe1xuICAgICAgd2VpZ2h0OiBQUkVWSUVXX0ZJRUxEX1dFSUdIVF9NQVBbZmllbGROYW1lXSxcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmllbGRzO1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkU3RyaW5nRmllbGRQYXRocyh0eXBlLCBtYXhEZXB0aCkge1xuICBjb25zdCBzeW1ib2wgPSBnZXRTdHJpbmdGaWVsZFN5bWJvbChtYXhEZXB0aCk7XG4gIHJldHVybiB0eXBlW3N5bWJvbF0gfHwgKHR5cGVbc3ltYm9sXSA9IHVuaXFCeShcbiAgICBbXG4gICAgICAuLi5CQVNFX1dFSUdIVFMsXG4gICAgICAuLi5kZXJpdmVGcm9tUHJldmlldyh0eXBlLCBtYXhEZXB0aCksXG4gICAgICAuLi5nZXRTdHJpbmdGaWVsZFBhdGhzKHR5cGUsIG1heERlcHRoKS5tYXAoKHBhdGgpID0+ICh7IHdlaWdodDogMSwgcGF0aCB9KSksXG4gICAgICAuLi5nZXRQb3J0YWJsZVRleHRGaWVsZFBhdGhzKHR5cGUsIG1heERlcHRoKS5tYXAoKHBhdGgpID0+ICh7XG4gICAgICAgIHdlaWdodDogMSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWFwV2l0aDogXCJwdDo6dGV4dFwiXG4gICAgICB9KSlcbiAgICBdLFxuICAgIChzcGVjKSA9PiBzcGVjLnBhdGguam9pbihcIi5cIilcbiAgKSksIHR5cGVbc3ltYm9sXTtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZEJhc2VGaWVsZFBhdGhzKHR5cGUsIG1heERlcHRoKSB7XG4gIGNvbnN0IHN5bWJvbCA9IGdldFN0cmluZ0ZpZWxkU3ltYm9sKG1heERlcHRoKTtcbiAgcmV0dXJuIHR5cGVbc3ltYm9sXSB8fCAodHlwZVtzeW1ib2xdID0gdW5pcUJ5KFxuICAgIFsuLi5CQVNFX1dFSUdIVFMsIC4uLmRlcml2ZUZyb21QcmV2aWV3KHR5cGUsIG1heERlcHRoKV0sXG4gICAgKHNwZWMpID0+IHNwZWMucGF0aC5qb2luKFwiLlwiKVxuICApKSwgdHlwZVtzeW1ib2xdO1xufVxuZnVuY3Rpb24gZ2V0U3RyaW5nRmllbGRQYXRocyh0eXBlLCBtYXhEZXB0aCkge1xuICByZXR1cm4gcmVkdWNlVHlwZSh0eXBlLCAoYWNjdW11bGF0b3IsIGNoaWxkVHlwZSwgcGF0aCkgPT4gY2hpbGRUeXBlLmpzb25UeXBlID09PSBcInN0cmluZ1wiID8gWy4uLmFjY3VtdWxhdG9yLCBwYXRoXSA6IGFjY3VtdWxhdG9yLCBbXSwgW10sIG1heERlcHRoKTtcbn1cbmZ1bmN0aW9uIGdldFBvcnRhYmxlVGV4dEZpZWxkUGF0aHModHlwZSwgbWF4RGVwdGgpIHtcbiAgcmV0dXJuIHJlZHVjZVR5cGUodHlwZSwgKGFjY3VtdWxhdG9yLCBjaGlsZFR5cGUsIHBhdGgpID0+IGlzUG9ydGFibGVUZXh0QXJyYXkoY2hpbGRUeXBlKSA/IFsuLi5hY2N1bXVsYXRvciwgcGF0aF0gOiBhY2N1bXVsYXRvciwgW10sIFtdLCBtYXhEZXB0aCk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VhcmNoQ29uZmlnRm9yQmFzZUZpZWxkUGF0aHModHlwZSwgbWF4RGVwdGgpIHtcbiAgcmV0dXJuIGdldENhY2hlZEJhc2VGaWVsZFBhdGhzKHR5cGUsIG5vcm1hbGl6ZU1heERlcHRoKG1heERlcHRoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2VhcmNoQ29uZmlnKHR5cGUsIG1heERlcHRoKSB7XG4gIHJldHVybiBnZXRDYWNoZWRTdHJpbmdGaWVsZFBhdGhzKHR5cGUsIG5vcm1hbGl6ZU1heERlcHRoKG1heERlcHRoKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVNYXhEZXB0aChtYXhEZXB0aCkge1xuICByZXR1cm4gIWlzRmluaXRlKG1heERlcHRoKSB8fCBtYXhEZXB0aCA8IDEgfHwgbWF4RGVwdGggPiBERUZBVUxUX01BWF9GSUVMRF9ERVBUSCA/IERFRkFVTFRfTUFYX0ZJRUxEX0RFUFRIIC0gMSA6IG1heERlcHRoIC0gMTtcbn1cbmV4cG9ydCB7XG4gIERFRkFVTFRfTUFYX0ZJRUxEX0RFUFRILFxuICBERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFMsXG4gIE9XTl9QUk9QU19OQU1FLFxuICByZXNvbHZlU2VhcmNoQ29uZmlnLFxuICByZXNvbHZlU2VhcmNoQ29uZmlnRm9yQmFzZUZpZWxkUGF0aHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_internal.mjs":
/*!**********************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_internal.mjs ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_MAX_FIELD_DEPTH: () => (/* reexport safe */ _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__.DEFAULT_MAX_FIELD_DEPTH),\n/* harmony export */   DescriptorConverter: () => (/* binding */ DescriptorConverter),\n/* harmony export */   builtinTypes: () => (/* binding */ builtinTypes),\n/* harmony export */   extractSchema: () => (/* binding */ extractSchema),\n/* harmony export */   groupProblems: () => (/* binding */ groupProblems),\n/* harmony export */   isActionEnabled: () => (/* binding */ isActionEnabled),\n/* harmony export */   processSchemaSynchronization: () => (/* binding */ processSchemaSynchronization),\n/* harmony export */   resolveSearchConfig: () => (/* reexport safe */ _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__.resolveSearchConfig),\n/* harmony export */   resolveSearchConfigForBaseFieldPaths: () => (/* reexport safe */ _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__.resolveSearchConfigForBaseFieldPaths),\n/* harmony export */   validateMediaLibraryAssetAspect: () => (/* binding */ validateMediaLibraryAssetAspect),\n/* harmony export */   validateSchema: () => (/* binding */ validateSchema)\n/* harmony export */ });\n/* harmony import */ var _sanity_descriptors__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @sanity/descriptors */ \"(ssr)/../node_modules/.pnpm/@sanity+descriptors@1.1.1/node_modules/@sanity/descriptors/dist/index.js\");\n/* harmony import */ var _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_chunks-es/resolve.mjs */ \"(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs\");\n/* harmony import */ var lodash_difference_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/difference.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js\");\n/* harmony import */ var groq_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! groq-js */ \"(ssr)/../node_modules/.pnpm/groq-js@1.18.0/node_modules/groq-js/dist/1.mjs\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js\");\n/* harmony import */ var lodash_get_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/get.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js\");\n/* harmony import */ var humanize_list__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! humanize-list */ \"(ssr)/../node_modules/.pnpm/humanize-list@1.0.1/node_modules/humanize-list/index.js\");\n/* harmony import */ var lodash_partition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/partition.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/partition.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/omit.js\");\n/* harmony import */ var leven__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! leven */ \"(ssr)/../node_modules/.pnpm/leven@3.1.0/node_modules/leven/index.js\");\n/* harmony import */ var object_inspect__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! object-inspect */ \"(ssr)/../node_modules/.pnpm/object-inspect@1.13.4/node_modules/object-inspect/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst MAX_DEPTH_UKNOWN = 5;\nclass DescriptorConverter {\n  opts;\n  cache = /* @__PURE__ */ new WeakMap();\n  constructor(opts) {\n    this.opts = opts;\n  }\n  /**\n   * Returns a synchronization object for a schema.\n   *\n   * This is automatically cached in a weak map.\n   */\n  get(schema) {\n    let value = this.cache.get(schema);\n    if (value) return value;\n    const builder = new _sanity_descriptors__WEBPACK_IMPORTED_MODULE_9__.SetBuilder();\n    for (const name of schema.getLocalTypeNames()) {\n      const typeDef = convertTypeDef(schema.get(name));\n      builder.addObject(\"sanity.schema.namedType\", { name, typeDef });\n    }\n    return schema.parent && builder.addSet(this.get(schema.parent)), value = builder.build(\"sanity.schema.registry\"), this.cache.set(schema, value), value;\n  }\n}\nfunction convertCommonTypeDef(schemaType, opts) {\n  const ownProps = _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__.OWN_PROPS_NAME in schemaType ? schemaType[_chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_10__.OWN_PROPS_NAME] : schemaType;\n  let fields;\n  Array.isArray(ownProps.fields) && (fields = ownProps.fields.map(\n    ({ name, group, fieldset, type }) => ({\n      name,\n      typeDef: convertTypeDef(type),\n      groups: arrayifyString(group),\n      fieldset\n    })\n  ));\n  let fieldsets;\n  Array.isArray(ownProps.fieldsets) && (fieldsets = filterStringKey(\n    \"name\",\n    ownProps.fieldsets.map(\n      ({ name, title, description, group, hidden, readOnly, options }) => ({\n        name,\n        title: maybeString(title),\n        description: maybeString(description),\n        group: maybeString(group),\n        hidden: conditionalTrue(hidden),\n        readOnly: conditionalTrue(readOnly),\n        options: convertUnknown(options)\n      })\n    )\n  ));\n  let groups;\n  Array.isArray(ownProps.groups) && (groups = filterStringKey(\n    \"name\",\n    ownProps.groups.map(\n      ({ name, title, hidden, default: def }) => ({\n        name,\n        title: maybeString(title),\n        hidden: conditionalTrue(hidden),\n        default: maybeTrue(def)\n      })\n    )\n  ));\n  const reason = ownProps.deprecated?.reason;\n  return {\n    title: maybeString(ownProps.title),\n    description: maybeStringOrJSX(ownProps.description),\n    readOnly: conditionalTrue(ownProps.readOnly),\n    hidden: conditionalTrue(ownProps.hidden),\n    liveEdit: maybeTrue(ownProps.liveEdit),\n    options: convertUnknown(ownProps.options),\n    initialValue: convertUnknown(ownProps.initialValue),\n    deprecated: typeof reason == \"string\" ? { reason } : void 0,\n    placeholder: maybeString(ownProps.placeholder),\n    rows: maybeNumberAsString(ownProps.rows),\n    fields,\n    fieldsets,\n    groups\n  };\n}\nfunction convertTypeDef(schemaType, opts) {\n  const common2 = convertCommonTypeDef(schemaType);\n  if (!schemaType.type)\n    return {\n      extends: null,\n      jsonType: schemaType.jsonType,\n      ...common2\n    };\n  switch (schemaType.type.name) {\n    case \"array\":\n      return {\n        extends: \"array\",\n        of: schemaType.of.map((ofType) => ({\n          name: ofType.name,\n          typeDef: convertTypeDef(ofType)\n        })),\n        ...common2\n      };\n    case \"reference\":\n    case \"globalDocumentReference\":\n    case \"crossDatasetReference\":\n      return {\n        extends: schemaType.type.name,\n        to: filterStringKey(\n          \"name\",\n          schemaType.to.map((toType) => ({ name: toType.name || toType.type?.name || toType.type }))\n        ),\n        ...common2\n      };\n    default:\n      return { extends: schemaType.type.name, ...common2 };\n  }\n}\nfunction maybeString(val) {\n  return typeof val == \"string\" ? val : void 0;\n}\nfunction maybeNumberAsString(val) {\n  return typeof val == \"number\" ? val.toString() : void 0;\n}\nfunction maybeTrue(val) {\n  return val === !0 ? !0 : void 0;\n}\nfunction conditionalTrue(val) {\n  return typeof val == \"function\" ? FUNCTION_MARKER : maybeTrue(val);\n}\nfunction filterStringKey(key, arr) {\n  return arr.filter((obj) => typeof obj[key] == \"string\");\n}\nfunction arrayifyString(val) {\n  if (typeof val == \"string\")\n    return [val];\n  if (Array.isArray(val))\n    return val.filter((elem) => typeof elem == \"string\");\n}\nconst FUNCTION_MARKER = { __type: \"function\" }, UNKNOWN_MARKER = { __type: \"unknown\" }, UNDEFINED_MARKER = { __type: \"undefined\" }, CYCLIC_MARKER = { __type: \"cyclic\" }, MAX_DEPTH_MARKER = { __type: \"maxDepth\" };\nfunction convertUnknown(val, seen = /* @__PURE__ */ new Set(), maxDepth = MAX_DEPTH_UKNOWN) {\n  if (maxDepth === 0) return MAX_DEPTH_MARKER;\n  if (typeof val == \"string\" || typeof val == \"boolean\" || val === null || val === void 0)\n    return val;\n  if (typeof val == \"number\")\n    return { __type: \"number\", value: val.toString() };\n  if (typeof val == \"function\") return FUNCTION_MARKER;\n  if (seen.has(val))\n    return CYCLIC_MARKER;\n  if (seen.add(val), typeof val == \"object\") {\n    if (Array.isArray(val))\n      return val.map((elem) => {\n        const res = convertUnknown(elem, seen, maxDepth - 1);\n        return res === void 0 ? UNDEFINED_MARKER : res;\n      });\n    if (\"$$typeof\" in val && \"type\" in val && \"props\" in val) {\n      const { type, props } = val, strType = typeof type == \"function\" ? type.name : type;\n      return typeof strType != \"string\" ? void 0 : {\n        __type: \"jsx\",\n        type: strType,\n        props: convertUnknown(props, seen, maxDepth - 1)\n      };\n    }\n    let hasType = !1;\n    const result = {};\n    for (const [key, field] of Object.entries(val))\n      key === \"__type\" && (hasType = !0), result[key] = convertUnknown(field, seen, maxDepth - 1);\n    return hasType ? { __type: \"object\", value: result } : result;\n  }\n  return UNKNOWN_MARKER;\n}\nfunction maybeStringOrJSX(val) {\n  if (typeof val == \"string\") return val;\n  if (val && typeof val == \"object\" && \"$$typeof\" in val && \"type\" in val && \"props\" in val) {\n    const { type, props } = val, strType = typeof type == \"function\" ? type.name : type;\n    return typeof strType != \"string\" ? void 0 : { __type: \"jsx\", type: strType, props: convertUnknown(props) };\n  }\n}\nfunction processSchemaSynchronization(sync, response) {\n  return (0,_sanity_descriptors__WEBPACK_IMPORTED_MODULE_9__.processSetSynchronization)(sync, response);\n}\nconst ACTIONS_FLAG = \"__experimental_actions\", DEFAULT_ACTIONS = [\"create\", \"update\", \"delete\", \"publish\"], VALID_ACTIONS = DEFAULT_ACTIONS, readActions = (schemaType) => ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS, validateActions = (typeName, actions) => {\n  if (!Array.isArray(actions))\n    throw new Error(\n      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(\n        \", \"\n      )}`\n    );\n  const invalid = lodash_difference_js__WEBPACK_IMPORTED_MODULE_0__(actions, VALID_ACTIONS);\n  if (invalid.length > 0)\n    throw new Error(\n      `Invalid action${invalid.length > 1 ? \"s\" : \"\"} configured for schema type \"${typeName}\": ${invalid.join(\n        \", \"\n      )}. Valid actions are: ${VALID_ACTIONS.join(\", \")}`\n    );\n  return actions;\n}, resolveEnabledActions = (schemaType) => validateActions(schemaType.name, readActions(schemaType)), isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action);\nvar assetSourceData = {\n  name: \"sanity.assetSourceData\",\n  title: \"Asset Source Data\",\n  type: \"object\",\n  fields: [\n    {\n      name: \"name\",\n      title: \"Source name\",\n      description: \"A canonical name for the source this asset is originating from\",\n      type: \"string\"\n    },\n    {\n      name: \"id\",\n      title: \"Asset Source ID\",\n      description: \"The unique ID for the asset within the originating source so you can programatically find back to it\",\n      type: \"string\"\n    },\n    {\n      name: \"url\",\n      title: \"Asset information URL\",\n      description: \"A URL to find more information about this asset in the originating source\",\n      type: \"string\"\n    }\n  ]\n}, fileAsset = {\n  name: \"sanity.fileAsset\",\n  title: \"File\",\n  type: \"document\",\n  fieldsets: [\n    {\n      name: \"system\",\n      title: \"System fields\",\n      description: \"These fields are managed by the system and not editable\"\n    }\n  ],\n  fields: [\n    {\n      name: \"originalFilename\",\n      type: \"string\",\n      title: \"Original file name\",\n      readOnly: !0\n    },\n    {\n      name: \"label\",\n      type: \"string\",\n      title: \"Label\"\n    },\n    {\n      name: \"title\",\n      type: \"string\",\n      title: \"Title\"\n    },\n    {\n      name: \"description\",\n      type: \"string\",\n      title: \"Description\"\n    },\n    {\n      name: \"altText\",\n      type: \"string\",\n      title: \"Alternative text\"\n    },\n    {\n      name: \"sha1hash\",\n      type: \"string\",\n      title: \"SHA1 hash\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"extension\",\n      type: \"string\",\n      title: \"File extension\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"mimeType\",\n      type: \"string\",\n      title: \"Mime type\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"size\",\n      type: \"number\",\n      title: \"File size in bytes\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"assetId\",\n      type: \"string\",\n      title: \"Asset ID\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"uploadId\",\n      type: \"string\",\n      readOnly: !0,\n      hidden: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"path\",\n      type: \"string\",\n      title: \"Path\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"url\",\n      type: \"string\",\n      title: \"Url\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"source\",\n      type: \"sanity.assetSourceData\",\n      title: \"Source\",\n      readOnly: !0,\n      fieldset: \"system\"\n    }\n  ],\n  preview: {\n    select: {\n      title: \"originalFilename\",\n      path: \"path\",\n      mimeType: \"mimeType\",\n      size: \"size\"\n    },\n    prepare(doc) {\n      return {\n        title: doc.title || doc.path.split(\"/\").slice(-1)[0],\n        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`\n      };\n    }\n  },\n  orderings: [\n    {\n      title: \"File size\",\n      name: \"fileSizeDesc\",\n      by: [{ field: \"size\", direction: \"desc\" }]\n    }\n  ]\n}, geopoint = {\n  title: \"Geographical Point\",\n  name: \"geopoint\",\n  type: \"object\",\n  fields: [\n    {\n      name: \"lat\",\n      type: \"number\",\n      title: \"Latitude\"\n    },\n    {\n      name: \"lng\",\n      type: \"number\",\n      title: \"Longitude\"\n    },\n    {\n      name: \"alt\",\n      type: \"number\",\n      title: \"Altitude\"\n    }\n  ]\n}, imageAsset = {\n  name: \"sanity.imageAsset\",\n  title: \"Image\",\n  type: \"document\",\n  fieldsets: [\n    {\n      name: \"system\",\n      title: \"System fields\",\n      description: \"These fields are managed by the system and not editable\"\n    }\n  ],\n  fields: [\n    {\n      name: \"originalFilename\",\n      type: \"string\",\n      title: \"Original file name\",\n      readOnly: !0\n    },\n    {\n      name: \"label\",\n      type: \"string\",\n      title: \"Label\"\n    },\n    {\n      name: \"title\",\n      type: \"string\",\n      title: \"Title\"\n    },\n    {\n      name: \"description\",\n      type: \"string\",\n      title: \"Description\"\n    },\n    {\n      name: \"altText\",\n      type: \"string\",\n      title: \"Alternative text\"\n    },\n    {\n      name: \"sha1hash\",\n      type: \"string\",\n      title: \"SHA1 hash\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"extension\",\n      type: \"string\",\n      readOnly: !0,\n      title: \"File extension\",\n      fieldset: \"system\"\n    },\n    {\n      name: \"mimeType\",\n      type: \"string\",\n      readOnly: !0,\n      title: \"Mime type\",\n      fieldset: \"system\"\n    },\n    {\n      name: \"size\",\n      type: \"number\",\n      title: \"File size in bytes\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"assetId\",\n      type: \"string\",\n      title: \"Asset ID\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"uploadId\",\n      type: \"string\",\n      readOnly: !0,\n      hidden: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"path\",\n      type: \"string\",\n      title: \"Path\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"url\",\n      type: \"string\",\n      title: \"Url\",\n      readOnly: !0,\n      fieldset: \"system\"\n    },\n    {\n      name: \"metadata\",\n      type: \"sanity.imageMetadata\",\n      title: \"Metadata\"\n    },\n    {\n      name: \"source\",\n      type: \"sanity.assetSourceData\",\n      title: \"Source\",\n      readOnly: !0,\n      fieldset: \"system\"\n    }\n  ],\n  preview: {\n    select: {\n      id: \"_id\",\n      title: \"originalFilename\",\n      mimeType: \"mimeType\",\n      size: \"size\"\n    },\n    prepare(doc) {\n      return {\n        title: doc.title || typeof doc.path == \"string\" && doc.path.split(\"/\").slice(-1)[0],\n        media: { asset: { _ref: doc.id } },\n        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`\n      };\n    }\n  },\n  orderings: [\n    {\n      title: \"File size\",\n      name: \"fileSizeDesc\",\n      by: [{ field: \"size\", direction: \"desc\" }]\n    }\n  ]\n}, imageCrop = {\n  name: \"sanity.imageCrop\",\n  title: \"Image crop\",\n  type: \"object\",\n  fields: [\n    {\n      name: \"top\",\n      type: \"number\"\n    },\n    {\n      name: \"bottom\",\n      type: \"number\"\n    },\n    {\n      name: \"left\",\n      type: \"number\"\n    },\n    {\n      name: \"right\",\n      type: \"number\"\n    }\n  ]\n}, imageDimensions = {\n  name: \"sanity.imageDimensions\",\n  type: \"object\",\n  title: \"Image dimensions\",\n  fields: [\n    { name: \"height\", type: \"number\", title: \"Height\", readOnly: !0 },\n    { name: \"width\", type: \"number\", title: \"Width\", readOnly: !0 },\n    { name: \"aspectRatio\", type: \"number\", title: \"Aspect ratio\", readOnly: !0 }\n  ]\n}, imageHotspot = {\n  name: \"sanity.imageHotspot\",\n  title: \"Image hotspot\",\n  type: \"object\",\n  fields: [\n    {\n      name: \"x\",\n      type: \"number\"\n    },\n    {\n      name: \"y\",\n      type: \"number\"\n    },\n    {\n      name: \"height\",\n      type: \"number\"\n    },\n    {\n      name: \"width\",\n      type: \"number\"\n    }\n  ]\n}, imageMetadata = {\n  name: \"sanity.imageMetadata\",\n  title: \"Image metadata\",\n  type: \"object\",\n  fieldsets: [\n    {\n      name: \"extra\",\n      title: \"Extra metadata\\u2026\",\n      options: {\n        collapsable: !0\n      }\n    }\n  ],\n  fields: [\n    {\n      name: \"location\",\n      type: \"geopoint\"\n    },\n    {\n      name: \"dimensions\",\n      title: \"Dimensions\",\n      type: \"sanity.imageDimensions\",\n      fieldset: \"extra\"\n    },\n    {\n      name: \"palette\",\n      type: \"sanity.imagePalette\",\n      title: \"Palette\",\n      fieldset: \"extra\"\n    },\n    {\n      name: \"lqip\",\n      title: \"LQIP (Low-Quality Image Placeholder)\",\n      type: \"string\",\n      readOnly: !0\n    },\n    {\n      name: \"blurHash\",\n      title: \"BlurHash\",\n      type: \"string\",\n      readOnly: !0\n    },\n    {\n      name: \"hasAlpha\",\n      title: \"Has alpha channel\",\n      type: \"boolean\",\n      readOnly: !0\n    },\n    {\n      name: \"isOpaque\",\n      title: \"Is opaque\",\n      type: \"boolean\",\n      readOnly: !0\n    }\n  ]\n}, imagePalette = {\n  name: \"sanity.imagePalette\",\n  title: \"Image palette\",\n  type: \"object\",\n  fields: [\n    { name: \"darkMuted\", type: \"sanity.imagePaletteSwatch\", title: \"Dark Muted\" },\n    { name: \"lightVibrant\", type: \"sanity.imagePaletteSwatch\", title: \"Light Vibrant\" },\n    { name: \"darkVibrant\", type: \"sanity.imagePaletteSwatch\", title: \"Dark Vibrant\" },\n    { name: \"vibrant\", type: \"sanity.imagePaletteSwatch\", title: \"Vibrant\" },\n    { name: \"dominant\", type: \"sanity.imagePaletteSwatch\", title: \"Dominant\" },\n    { name: \"lightMuted\", type: \"sanity.imagePaletteSwatch\", title: \"Light Muted\" },\n    { name: \"muted\", type: \"sanity.imagePaletteSwatch\", title: \"Muted\" }\n  ]\n}, imagePaletteSwatch = {\n  name: \"sanity.imagePaletteSwatch\",\n  title: \"Image palette swatch\",\n  type: \"object\",\n  fields: [\n    { name: \"background\", type: \"string\", title: \"Background\", readOnly: !0 },\n    { name: \"foreground\", type: \"string\", title: \"Foreground\", readOnly: !0 },\n    { name: \"population\", type: \"number\", title: \"Population\", readOnly: !0 },\n    { name: \"title\", type: \"string\", title: \"String\", readOnly: !0 }\n  ]\n}, slug$1 = {\n  title: \"Slug\",\n  name: \"slug\",\n  type: \"object\",\n  fields: [\n    {\n      name: \"current\",\n      title: \"Current slug\",\n      type: \"string\",\n      validation: (Rule) => Rule.required()\n    },\n    {\n      // The source field is deprecated/unused, but leaving it included and hidden\n      // to prevent rendering \"Unknown field\" warnings on legacy data\n      name: \"source\",\n      title: \"Source field\",\n      type: \"string\",\n      hidden: !0\n    }\n  ]\n};\nconst builtinTypes = [\n  assetSourceData,\n  slug$1,\n  geopoint,\n  // legacyRichDate,\n  imageAsset,\n  fileAsset,\n  imageCrop,\n  imageHotspot,\n  imageMetadata,\n  imageDimensions,\n  imagePalette,\n  imagePaletteSwatch\n], documentDefaultFields = (typeName) => ({\n  _id: {\n    type: \"objectAttribute\",\n    value: { type: \"string\" }\n  },\n  _type: {\n    type: \"objectAttribute\",\n    value: { type: \"string\", value: typeName }\n  },\n  _createdAt: {\n    type: \"objectAttribute\",\n    value: { type: \"string\" }\n  },\n  _updatedAt: {\n    type: \"objectAttribute\",\n    value: { type: \"string\" }\n  },\n  _rev: {\n    type: \"objectAttribute\",\n    value: { type: \"string\" }\n  }\n}), typesMap = /* @__PURE__ */ new Map([\n  [\"text\", { type: \"string\" }],\n  [\"url\", { type: \"string\" }],\n  [\"datetime\", { type: \"string\" }],\n  [\"date\", { type: \"string\" }],\n  [\"boolean\", { type: \"boolean\" }],\n  [\"email\", { type: \"string\" }]\n]);\nfunction extractSchema(schemaDef, extractOptions = {}) {\n  const inlineFields = /* @__PURE__ */ new Set(), documentTypes = /* @__PURE__ */ new Map(), schema = [];\n  sortByDependencies(schemaDef).forEach((typeName) => {\n    const schemaType = schemaDef.get(typeName);\n    if (schemaType === void 0)\n      return;\n    const base = convertBaseType(schemaType);\n    base !== null && (base.type === \"type\" && inlineFields.add(schemaType), base.type === \"document\" && documentTypes.set(typeName, base), schema.push(base));\n  });\n  function convertBaseType(schemaType) {\n    let typeName;\n    if (schemaType.type ? typeName = schemaType.type.name : \"jsonType\" in schemaType && (typeName = schemaType.jsonType), typeName === \"document\" && isObjectType(schemaType)) {\n      const defaultAttributes = documentDefaultFields(schemaType.name), object2 = createObject(schemaType);\n      return object2.type === \"unknown\" ? null : {\n        name: schemaType.name,\n        type: \"document\",\n        attributes: {\n          ...defaultAttributes,\n          ...object2.attributes\n        }\n      };\n    }\n    const value = convertSchemaType(schemaType);\n    return value.type === \"unknown\" ? null : value.type === \"object\" ? {\n      name: schemaType.name,\n      type: \"type\",\n      value: {\n        type: \"object\",\n        attributes: {\n          _type: {\n            type: \"objectAttribute\",\n            value: {\n              type: \"string\",\n              value: schemaType.name\n            }\n          },\n          ...value.attributes\n        }\n      }\n    } : {\n      name: schemaType.name,\n      type: \"type\",\n      value\n    };\n  }\n  function convertSchemaType(schemaType) {\n    if (inlineFields.has(schemaType.type))\n      return { type: \"inline\", name: schemaType.type.name };\n    if (schemaType.type?.type?.name === \"object\")\n      return { type: \"inline\", name: schemaType.type.name };\n    if (isStringType(schemaType))\n      return createStringTypeNodeDefintion(schemaType);\n    if (isNumberType(schemaType))\n      return createNumberTypeNodeDefintion(schemaType);\n    if (schemaType.type && typesMap.has(schemaType.type.name))\n      return typesMap.get(schemaType.type.name);\n    if (isCrossDatasetReferenceType(schemaType))\n      return { type: \"unknown\" };\n    if (isGlobalDocumentReferenceType(schemaType))\n      return { type: \"unknown\" };\n    if (isReferenceType(schemaType))\n      return createReferenceTypeNodeDefintion(schemaType);\n    if (isArrayType(schemaType))\n      return createArray(schemaType);\n    if (isObjectType(schemaType))\n      return createObject(schemaType);\n    if (lastType(schemaType)?.name === \"document\") {\n      const doc = documentTypes.get(schemaType.name);\n      return doc === void 0 ? { type: \"unknown\" } : { type: \"object\", attributes: doc?.attributes };\n    }\n    throw new Error(`Type \"${schemaType.name}\" not found`);\n  }\n  function createObject(schemaType) {\n    const attributes = {}, fields = gatherFields(schemaType);\n    for (const field of fields) {\n      const fieldIsRequired = isFieldRequired(field), value = convertSchemaType(field.type);\n      if (value === null)\n        continue;\n      hasAssetRequired(field) && value.type === \"object\" && (value.attributes.asset.optional = !1);\n      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === !1 : !0;\n      attributes[field.name] = {\n        type: \"objectAttribute\",\n        value,\n        optional\n      };\n    }\n    return Object.keys(attributes).length === 0 ? { type: \"unknown\" } : (schemaType.type?.name !== \"document\" && schemaType.name !== \"object\" && (attributes._type = {\n      type: \"objectAttribute\",\n      value: {\n        type: \"string\",\n        value: schemaType.name\n      }\n    }), {\n      type: \"object\",\n      attributes\n    });\n  }\n  function createArray(arraySchemaType) {\n    const of = [];\n    for (const item of arraySchemaType.of) {\n      const field = convertSchemaType(item);\n      field.type === \"inline\" ? of.push({\n        type: \"object\",\n        attributes: {\n          _key: createKeyField()\n        },\n        rest: field\n      }) : (field.type === \"object\" && (field.rest = {\n        type: \"object\",\n        attributes: {\n          _key: createKeyField()\n        }\n      }), of.push(field));\n    }\n    return of.length === 0 ? { type: \"null\" } : {\n      type: \"array\",\n      of: of.length > 1 ? {\n        type: \"union\",\n        of\n      } : of[0]\n    };\n  }\n  return schema;\n}\nfunction createKeyField() {\n  return {\n    type: \"objectAttribute\",\n    value: {\n      type: \"string\"\n    }\n  };\n}\nfunction isFieldRequired(field) {\n  const { validation } = field.type;\n  if (!validation)\n    return !1;\n  const rules = Array.isArray(validation) ? validation : [validation];\n  for (const rule of rules) {\n    let required = !1;\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => (methodName === \"required\" && (required = !0), proxy)\n      }\n    );\n    if (typeof rule == \"function\" && (rule(proxy), required) || typeof rule == \"object\" && rule !== null && \"_required\" in rule && rule._required === \"required\")\n      return !0;\n  }\n  return !1;\n}\nfunction hasAssetRequired(field) {\n  const { validation } = field.type;\n  if (!validation)\n    return !1;\n  const rules = Array.isArray(validation) ? validation : [validation];\n  for (const rule of rules) {\n    let assetRequired = !1;\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => (methodName === \"assetRequired\" && (assetRequired = !0), proxy)\n      }\n    );\n    if (typeof rule == \"function\" && (rule(proxy), assetRequired) || typeof rule == \"object\" && rule !== null && \"_rules\" in rule && Array.isArray(rule._rules) && rule._rules.some((r) => r.flag === \"assetRequired\"))\n      return !0;\n  }\n  return !1;\n}\nfunction isObjectType(typeDef) {\n  return isType(typeDef, \"object\") || typeDef.jsonType === \"object\" || \"fields\" in typeDef;\n}\nfunction isArrayType(typeDef) {\n  return isType(typeDef, \"array\");\n}\nfunction isReferenceType(typeDef) {\n  return isType(typeDef, \"reference\");\n}\nfunction isCrossDatasetReferenceType(typeDef) {\n  return isType(typeDef, \"crossDatasetReference\");\n}\nfunction isGlobalDocumentReferenceType(typeDef) {\n  return isType(typeDef, \"globalDocumentReference\");\n}\nfunction isStringType(typeDef) {\n  return isType(typeDef, \"string\");\n}\nfunction isNumberType(typeDef) {\n  return isType(typeDef, \"number\");\n}\nfunction createStringTypeNodeDefintion(stringSchemaType) {\n  const listOptions = stringSchemaType.options?.list;\n  return listOptions && Array.isArray(listOptions) ? {\n    type: \"union\",\n    of: listOptions.map((v) => ({\n      type: \"string\",\n      value: typeof v == \"string\" ? v : v.value\n    }))\n  } : {\n    type: \"string\"\n  };\n}\nfunction createNumberTypeNodeDefintion(numberSchemaType) {\n  const listOptions = numberSchemaType.options?.list;\n  return listOptions && Array.isArray(listOptions) ? {\n    type: \"union\",\n    of: listOptions.map((v) => ({\n      type: \"number\",\n      value: typeof v == \"number\" ? v : v.value\n    }))\n  } : {\n    type: \"number\"\n  };\n}\nfunction createReferenceTypeNodeDefintion(reference2) {\n  const references = gatherReferenceNames(reference2);\n  return references.length === 1 ? (0,groq_js__WEBPACK_IMPORTED_MODULE_11__.createReferenceTypeNode)(references[0]) : {\n    type: \"union\",\n    of: references.map((name) => (0,groq_js__WEBPACK_IMPORTED_MODULE_11__.createReferenceTypeNode)(name))\n  };\n}\nfunction gatherReferenceNames(type) {\n  const allReferences = gatherReferenceTypes(type);\n  return [...new Set(allReferences.map((ref) => ref.name))];\n}\nfunction gatherReferenceTypes(type) {\n  const refTo = \"to\" in type ? type.to : [];\n  return \"type\" in type && isReferenceType(type.type) ? [...gatherReferenceTypes(type.type), ...refTo] : refTo;\n}\nfunction gatherFields(type) {\n  return \"fields\" in type ? type.type ? gatherFields(type.type).concat(type.fields) : type.fields : [];\n}\nfunction isType(typeDef, typeName) {\n  let type = typeDef;\n  for (; type; ) {\n    if (type.name === typeName || type.type && type.type.name === typeName)\n      return !0;\n    type = type.type;\n  }\n  return !1;\n}\nfunction lastType(typeDef) {\n  let type = typeDef;\n  for (; type; ) {\n    if (!type.type)\n      return type;\n    type = type.type;\n  }\n}\nfunction sortByDependencies(compiledSchema) {\n  const seen = /* @__PURE__ */ new Set();\n  function walkDependencies(schemaType, dependencies) {\n    if (!seen.has(schemaType)) {\n      if (seen.add(schemaType), \"fields\" in schemaType)\n        for (const field of gatherFields(schemaType)) {\n          const last = lastType(field.type);\n          if (last.name === \"document\") {\n            dependencies.add(last);\n            continue;\n          }\n          let schemaTypeName;\n          schemaType.type.type ? schemaTypeName = field.type.type.name : \"jsonType\" in schemaType.type && (schemaTypeName = field.type.jsonType), (schemaTypeName === \"object\" || schemaTypeName === \"block\") && (isReferenceType(field.type) ? field.type.to.forEach((ref) => dependencies.add(ref.type)) : dependencies.add(field.type)), walkDependencies(field.type, dependencies);\n        }\n      else if (\"of\" in schemaType)\n        for (const item of schemaType.of)\n          walkDependencies(item, dependencies);\n    }\n  }\n  const dependencyMap = /* @__PURE__ */ new Map();\n  compiledSchema.getTypeNames().forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName);\n    if (schemaType === void 0 || schemaType.type === null)\n      return;\n    const dependencies = /* @__PURE__ */ new Set();\n    walkDependencies(schemaType, dependencies), dependencyMap.set(schemaType, dependencies), seen.clear();\n  });\n  const typeNames = [], currentlyVisiting = /* @__PURE__ */ new Set(), visited = /* @__PURE__ */ new Set();\n  function visit(type) {\n    if (visited.has(type) || currentlyVisiting.has(type))\n      return;\n    currentlyVisiting.add(type);\n    const deps = dependencyMap.get(type);\n    deps !== void 0 && deps.forEach((dep) => visit(dep)), currentlyVisiting.delete(type), visited.add(type), typeNames.includes(type.name) || typeNames.unshift(type.name);\n  }\n  for (const [type] of dependencyMap)\n    visit(type);\n  return typeNames;\n}\nconst HELP_IDS = {\n  TYPE_INVALID: \"schema-type-invalid\",\n  TYPE_IS_ESM_MODULE: \"schema-type-is-esm-module\",\n  TYPE_NAME_RESERVED: \"schema-type-name-reserved\",\n  TYPE_MISSING_NAME: \"schema-type-missing-name-or-type\",\n  TYPE_MISSING_TYPE: \"schema-type-missing-name-or-type\",\n  TYPE_TITLE_RECOMMENDED: \"schema-type-title-is-recommended\",\n  TYPE_TITLE_INVALID: \"schema-type-title-is-recommended\",\n  OBJECT_FIELDS_INVALID: \"schema-object-fields-invalid\",\n  OBJECT_FIELD_NOT_UNIQUE: \"schema-object-fields-invalid\",\n  OBJECT_FIELD_NAME_INVALID: \"schema-object-fields-invalid\",\n  OBJECT_FIELD_DEFINITION_INVALID_TYPE: \"schema-object-fields-invalid\",\n  ARRAY_PREDEFINED_CHOICES_INVALID: \"schema-predefined-choices-invalid\",\n  ARRAY_OF_ARRAY: \"schema-array-of-array\",\n  ARRAY_OF_INVALID: \"schema-array-of-invalid\",\n  ARRAY_OF_NOT_UNIQUE: \"schema-array-of-invalid\",\n  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: \"schema-array-of-type-global-type-conflict\",\n  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: \"schema-array-of-type-builtin-type-conflict\",\n  REFERENCE_TO_INVALID: \"schema-reference-to-invalid\",\n  REFERENCE_TO_NOT_UNIQUE: \"schema-reference-to-invalid\",\n  REFERENCE_INVALID_OPTIONS: \"schema-reference-invalid-options\",\n  REFERENCE_INVALID_OPTIONS_LOCATION: \"schema-reference-options-nesting\",\n  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: \"schema-reference-filter-params-combination\",\n  SLUG_SLUGIFY_FN_RENAMED: \"slug-slugifyfn-renamed\",\n  ASSET_METADATA_FIELD_INVALID: \"asset-metadata-field-invalid\",\n  CROSS_DATASET_REFERENCE_INVALID: \"cross-dataset-reference-invalid\",\n  GLOBAL_DOCUMENT_REFERENCE_INVALID: \"global-document-reference-invalid\",\n  DEPRECATED_BLOCKEDITOR_KEY: \"schema-deprecated-blockeditor-key\",\n  STANDALONE_BLOCK_TYPE: \"schema-standalone-block-type\"\n};\nfunction createValidationResult(severity, message, helpId) {\n  if (helpId && !Object.keys(HELP_IDS).some((id) => HELP_IDS[id] === helpId))\n    throw new Error(\n      `Used the unknown helpId \"${helpId}\", please add it to the array in createValidationResult.js`\n    );\n  return {\n    severity,\n    message,\n    helpId\n  };\n}\nconst error = (message, helpId) => createValidationResult(\"error\", message, helpId), warning = (message, helpId) => createValidationResult(\"warning\", message, helpId);\nfunction groupProblems(types) {\n  return lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__(types.map((type) => getTypeProblems(type))).filter(\n    (type) => type.problems.length > 0\n  );\n}\nfunction createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers = (type) => lodash_get_js__WEBPACK_IMPORTED_MODULE_2__(type, memberPropertyName)) {\n  return function(type, parentPath) {\n    const currentPath = [\n      ...parentPath,\n      { kind: \"type\", type: type.type, name: type.name }\n    ], members = getMembers(type) || [], memberProblems = Array.isArray(members) ? members.map((memberType) => {\n      const propertySegment = {\n        kind: \"property\",\n        name: memberPropertyName\n      }, memberPath = [...currentPath, propertySegment];\n      return getTypeProblems(memberType, memberPath);\n    }) : [\n      [\n        {\n          path: currentPath,\n          problems: [error(`Member declaration (${memberPropertyName}) is not an array`)]\n        }\n      ]\n    ];\n    return [\n      {\n        path: currentPath,\n        problems: type._problems || []\n      },\n      ...lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__(memberProblems)\n    ];\n  };\n}\nconst arrify = (val) => Array.isArray(val) ? val : typeof val > \"u\" && [] || [val], getObjectProblems = createTypeWithMembersProblemsAccessor(\"fields\"), getImageProblems = createTypeWithMembersProblemsAccessor(\"fields\"), getFileProblems = createTypeWithMembersProblemsAccessor(\"fields\"), getArrayProblems = createTypeWithMembersProblemsAccessor(\"of\"), getReferenceProblems = createTypeWithMembersProblemsAccessor(\n  \"to\",\n  (type) => \"to\" in type ? arrify(type.to) : []\n), getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor(\"marks.annotations\"), getBlockMemberProblems = createTypeWithMembersProblemsAccessor(\"of\"), getBlockProblems = (type, problems) => [\n  ...getBlockAnnotationProblems(type, problems),\n  ...getBlockMemberProblems(type, problems)\n];\nfunction getDefaultProblems(type, path = []) {\n  return [\n    {\n      path: [...path, { kind: \"type\", type: type.type, name: type.name }],\n      problems: type._problems || []\n    }\n  ];\n}\nfunction getTypeProblems(type, path = []) {\n  switch (type.type) {\n    case \"object\":\n      return getObjectProblems(type, path);\n    case \"document\":\n      return getObjectProblems(type, path);\n    case \"array\":\n      return getArrayProblems(type, path);\n    case \"reference\":\n      return getReferenceProblems(type, path);\n    case \"block\":\n      return getBlockProblems(type, path);\n    case \"image\":\n      return getImageProblems(type, path);\n    case \"file\":\n      return getFileProblems(type, path);\n    default:\n      return getDefaultProblems(type, path);\n  }\n}\nfunction getDupes(array2, selector = (v) => v) {\n  const dupes = array2.reduce((acc, item) => {\n    const key = selector(item);\n    return acc[key] || (acc[key] = []), acc[key].push(item), acc;\n  }, {});\n  return Object.keys(dupes).map((key) => dupes[key].length > 1 ? dupes[key] : null).filter(Boolean);\n}\nconst NOOP_VISITOR = (typeDef) => typeDef, TYPE_TYPE = { name: \"type\", type: null }, FUTURE_RESERVED = [\"any\", \"time\", \"date\"];\nfunction traverseSchema(types = [], coreTypes2 = [], visitor = NOOP_VISITOR) {\n  const coreTypesRegistry = /* @__PURE__ */ Object.create(null), registry = /* @__PURE__ */ Object.create(null), coreTypeNames2 = coreTypes2.map((typeDef) => typeDef.name), reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames2), typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean);\n  coreTypes2.forEach((coreType) => {\n    coreTypesRegistry[coreType.name] = coreType;\n  }), types.forEach((type, i) => {\n    registry[type && type.name || `__unnamed_${i}`] = {};\n  });\n  function getType(typeName) {\n    return typeName === \"type\" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;\n  }\n  const duplicateNames = lodash_uniq_js__WEBPACK_IMPORTED_MODULE_3__(lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__(getDupes(typeNames)));\n  function isDuplicate(typeName) {\n    return duplicateNames.includes(typeName);\n  }\n  function getTypeNames() {\n    return typeNames.concat(coreTypeNames2);\n  }\n  function isReserved(typeName) {\n    return typeName === \"type\" || reservedTypeNames.includes(typeName);\n  }\n  const visitType = (isRoot) => (typeDef, index) => visitor(typeDef, {\n    visit: visitType(!1),\n    isRoot,\n    getType,\n    getTypeNames,\n    isReserved,\n    isDuplicate,\n    index\n  });\n  return coreTypes2.forEach((coreTypeDef) => {\n    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));\n  }), types.forEach((typeDef, i) => {\n    Object.assign(\n      registry[typeDef && typeDef.name || `__unnamed_${i}`],\n      visitType(!0)(typeDef, i)\n    );\n  }), {\n    get(typeName) {\n      const res = registry[typeName] || coreTypesRegistry[typeName];\n      if (res)\n        return res;\n      throw new Error(`No such type: ${typeName}`);\n    },\n    has(typeName) {\n      return typeName in registry || typeName in coreTypesRegistry;\n    },\n    getTypeNames() {\n      return Object.keys(registry);\n    },\n    getTypes() {\n      return this.getTypeNames().map(this.get);\n    },\n    toJSON() {\n      return this.getTypes();\n    }\n  };\n}\nconst coreTypes = [\n  { name: \"array\", jsonType: \"array\", type: \"type\" },\n  { name: \"block\", jsonType: \"object\", type: \"type\" },\n  { name: \"boolean\", jsonType: \"boolean\", type: \"type\" },\n  { name: \"datetime\", jsonType: \"string\", type: \"type\" },\n  { name: \"date\", jsonType: \"string\", type: \"type\" },\n  { name: \"document\", jsonType: \"object\", type: \"type\" },\n  { name: \"email\", jsonType: \"string\", type: \"type\" },\n  { name: \"file\", jsonType: \"object\", type: \"type\" },\n  { name: \"geopoint\", jsonType: \"object\", type: \"type\" },\n  { name: \"image\", jsonType: \"object\", type: \"type\" },\n  { name: \"number\", jsonType: \"number\", type: \"type\" },\n  { name: \"object\", jsonType: \"object\", type: \"type\" },\n  { name: \"reference\", jsonType: \"object\", type: \"type\" },\n  { name: \"crossDatasetReference\", jsonType: \"object\", type: \"type\" },\n  { name: \"globalDocumentReference\", jsonType: \"object\", type: \"type\" },\n  { name: \"slug\", jsonType: \"object\", type: \"type\" },\n  { name: \"span\", jsonType: \"object\", type: \"type\" },\n  { name: \"string\", jsonType: \"string\", type: \"type\" },\n  { name: \"telephone\", jsonType: \"string\", type: \"type\" },\n  { name: \"text\", jsonType: \"string\", type: \"type\" },\n  { name: \"url\", jsonType: \"string\", type: \"type\" }\n], coreTypeNames = coreTypes.map((t) => t.name);\nfunction traverseSanitySchema(schemaTypes, visitor) {\n  return traverseSchema(schemaTypes, coreTypes, visitor);\n}\nfunction isPrimitiveTypeName(typeName) {\n  return typeName === \"string\" || typeName === \"number\" || typeName === \"boolean\";\n}\nfunction isAssignable(typeName, type) {\n  return (typeof type.name == \"string\" ? type.name : type.type) === typeName;\n}\nfunction quote$2(n) {\n  return `\"${n}\"`;\n}\nfunction pluralize(arr, suf = \"s\") {\n  return arr.length === 1 ? \"\" : suf;\n}\nfunction format(value) {\n  return Array.isArray(value) ? `array with ${value.length} entries` : typeof value == \"object\" && value !== null ? `object with keys ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(Object.keys(value).map(quote$2))}` : quote$2(value);\n}\nvar array = (typeDef, visitorContext) => {\n  const ofIsArray = Array.isArray(typeDef.of);\n  if (ofIsArray) {\n    const invalid = typeDef.of.reduce((errs, def, idx) => {\n      if (typeof def.name == \"string\" && // specifying the same name as the type is redundant, but should not be a hard error at this point\n      // Consider showing a warning for this and deprecate this ability eventually\n      def.name !== def.type && coreTypeNames.includes(def.name))\n        return errs.concat(\n          error(\n            `Found array member declaration with the same type name as a built-in type (\"${def.name}\"). Array members can not be given the same name as a built-in type.`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT\n          )\n        );\n      if (def.type === \"object\" && def.name && visitorContext.getType(def.name))\n        return errs.concat(\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${def.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT\n          )\n        );\n      if (def.type === \"array\")\n        return errs.concat(\n          error(\n            'Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity',\n            HELP_IDS.ARRAY_OF_ARRAY\n          )\n        );\n      if (def)\n        return errs;\n      const err = `Found ${def === null ? \"null\" : typeof def}, expected member declaration`;\n      return errs.concat(\n        error(\n          `Found invalid type member declaration in array at index ${idx}: ${err}`,\n          HELP_IDS.ARRAY_OF_INVALID\n        )\n      );\n    }, []);\n    if (invalid.length > 0)\n      return {\n        ...typeDef,\n        of: [],\n        _problems: invalid\n      };\n  }\n  const problems = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__([\n    ofIsArray ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map(\n      (dupes) => error(\n        `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in array. This makes it impossible to tell their values apart and you should consider naming them`,\n        HELP_IDS.ARRAY_OF_NOT_UNIQUE\n      )\n    ) : error(\n      'The array type is missing or having an invalid value for the required \"of\" property',\n      HELP_IDS.ARRAY_OF_INVALID\n    )\n  ]), of = ofIsArray ? typeDef.of : [], hasObjectTypesWithoutName = of.some(\n    (type) => type.type === \"object\" && typeof type.name > \"u\"\n  );\n  of.some((ofType) => ofType.type === \"block\") && hasObjectTypesWithoutName && problems.push(\n    error(\n      \"The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.\",\n      HELP_IDS.ARRAY_OF_INVALID\n    )\n  );\n  const [primitiveTypes, objectTypes] = lodash_partition_js__WEBPACK_IMPORTED_MODULE_5__(\n    of,\n    (ofType) => isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType)\n  ), isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;\n  if (isMixedArray) {\n    const primitiveTypeNames = primitiveTypes.map((t) => t.type), objectTypeNames = objectTypes.map((t) => t.type);\n    problems.push(\n      error(\n        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(\n          primitiveTypeNames\n        )} ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(primitiveTypeNames.map(quote$2))} and object type${pluralize(\n          objectTypeNames\n        )} ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(objectTypeNames.map(quote$2))})`,\n        HELP_IDS.ARRAY_OF_INVALID\n      )\n    );\n  }\n  const list = typeDef?.options?.list;\n  return !isMixedArray && Array.isArray(list) && (primitiveTypes.length > 0 ? list.forEach((option) => {\n    const value = option?.value ?? option;\n    if (!primitiveTypes.some((primitiveType) => typeof value === visitorContext.getType(primitiveType.type).jsonType)) {\n      const formattedTypeList = humanize_list__WEBPACK_IMPORTED_MODULE_4__(\n        primitiveTypes.map((t) => t.name || t.type),\n        { conjunction: \"or\" }\n      );\n      problems.push(\n        error(\n          `An invalid entry found in options.list: ${format(\n            value\n          )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,\n          HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID\n        )\n      );\n    }\n  }) : list.forEach((option) => {\n    const optionTypeName = option._type || \"object\";\n    objectTypes.some(\n      (validObjectType) => isAssignable(optionTypeName, validObjectType)\n    ) || problems.push(\n      error(\n        `An invalid entry found in options.list: ${format(\n          option\n        )}. Must be an object with \"_type\" set to ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(\n          objectTypes.map((t) => t.name || t.type).map((t) => t === \"object\" ? \"undefined\" : quote$2(t)),\n          { conjunction: \"or\" }\n        )}`,\n        HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID\n      )\n    );\n  })), typeDef?.options?.list && typeDef?.options?.layout === \"tags\" && problems.push(\n    warning(\n      \"Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.\"\n    )\n  ), {\n    ...typeDef,\n    of: of.map(visitorContext.visit),\n    _problems: problems\n  };\n};\nfunction isJSONTypeOf(type, jsonType, visitorContext) {\n  if (\"jsonType\" in type)\n    return type.jsonType === jsonType;\n  const parentType = visitorContext.getType(type.type);\n  if (!parentType)\n    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`);\n  return isJSONTypeOf(parentType, jsonType, visitorContext);\n}\nconst getTypeOf = (thing) => Array.isArray(thing) ? \"array\" : typeof thing, quote$1 = (str) => `\"${str}\"`, allowedKeys = [\n  \"components\",\n  \"lists\",\n  \"marks\",\n  \"name\",\n  \"of\",\n  \"options\",\n  \"styles\",\n  \"title\",\n  \"type\",\n  \"validation\"\n], allowedMarkKeys = [\"decorators\", \"annotations\"], allowedStyleKeys = [\"blockEditor\", \"title\", \"value\", \"icon\", \"component\"], allowedDecoratorKeys = [\"blockEditor\", \"title\", \"value\", \"icon\", \"component\"], allowedListKeys = [\"title\", \"value\", \"icon\", \"component\"], supportedBuiltInObjectTypes = [\n  \"file\",\n  \"image\",\n  \"object\",\n  \"reference\",\n  \"crossDatasetReference\",\n  \"globalDocumentReference\"\n];\nfunction validateBlockType(typeDef, visitorContext) {\n  const problems = [];\n  let styles = typeDef.styles, lists = typeDef.lists, marks = typeDef.marks, members = typeDef.of;\n  const disallowedKeys = Object.keys(typeDef).filter(\n    (key) => !allowedKeys.includes(key) && !key.startsWith(\"_\")\n  );\n  return disallowedKeys.length > 0 && problems.push(\n    error(\n      `Found unknown properties for block declaration: ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(\n        disallowedKeys.map(quote$1)\n      )}`\n    )\n  ), marks && (marks = validateMarks(typeDef.marks, visitorContext, problems)), styles && (styles = validateStyles(styles, visitorContext, problems)), lists && (lists = validateLists(lists, visitorContext, problems)), members && (members = validateMembers(members, visitorContext, problems)), {\n    ...lodash_omit_js__WEBPACK_IMPORTED_MODULE_7__(typeDef, disallowedKeys),\n    marks,\n    styles,\n    name: typeDef.name || typeDef.type,\n    of: members,\n    _problems: problems\n  };\n}\nfunction validateMarks(marks, visitorContext, problems) {\n  let decorators = marks.decorators, annotations = marks.annotations;\n  if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(marks))\n    return problems.push(error(`\"marks\" declaration should be an object, got ${getTypeOf(marks)}`)), problems;\n  const disallowedMarkKeys = Object.keys(marks).filter(\n    (key) => !allowedMarkKeys.includes(key) && !key.startsWith(\"_\")\n  );\n  return disallowedMarkKeys.length > 0 && problems.push(\n    error(\n      `Found unknown properties for block declaration: ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(\n        disallowedMarkKeys.map(quote$1)\n      )}`\n    )\n  ), decorators && !Array.isArray(decorators) ? problems.push(\n    error(`\"marks.decorators\" declaration should be an array, got ${getTypeOf(decorators)}`)\n  ) : decorators && (decorators.filter((dec) => !!dec.blockEditor).forEach((dec) => {\n    dec.icon = dec.blockEditor.icon, dec.component = dec.blockEditor.render;\n  }), decorators = validateDecorators(decorators, visitorContext, problems)), annotations && !Array.isArray(annotations) ? problems.push(\n    error(`\"marks.annotations\" declaration should be an array, got ${getTypeOf(annotations)}`)\n  ) : annotations && (annotations = validateAnnotations(annotations, visitorContext, problems)), { ...marks, decorators, annotations };\n}\nfunction validateLists(lists, visitorContext, problems) {\n  return Array.isArray(lists) ? (lists.forEach((list, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(list)) {\n      problems.push(error(`List must be an object, got ${getTypeOf(list)}`));\n      return;\n    }\n    const name = list.value || `#${index}`, disallowedKeys = Object.keys(list).filter(\n      (key) => !allowedListKeys.includes(key) && !key.startsWith(\"_\")\n    );\n    disallowedKeys.length > 0 && problems.push(\n      error(\n        `Found unknown properties for list ${name}: ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(disallowedKeys.map(quote$1))}`\n      )\n    ), list.value ? typeof list.value != \"string\" ? problems.push(\n      error(\n        `List type #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n          list.value\n        )}`\n      )\n    ) : list.title || problems.push(warning(`List type ${name} is missing recommended \"title\" property`)) : problems.push(error(`List #${index} is missing required \"value\" property`));\n  }), lists) : (problems.push(error(`\"lists\" declaration should be an array, got ${getTypeOf(lists)}`)), problems);\n}\nfunction validateStyles(styles, visitorContext, problems) {\n  return Array.isArray(styles) ? (styles.forEach((style, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(style)) {\n      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`));\n      return;\n    }\n    const name = style.value || `#${index}`, disallowedKeys = Object.keys(style).filter(\n      (key) => !allowedStyleKeys.includes(key) && !key.startsWith(\"_\")\n    );\n    disallowedKeys.length > 0 && problems.push(\n      error(\n        `Found unknown properties for style ${name}: ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(disallowedKeys.map(quote$1))}`\n      )\n    ), style.value ? typeof style.value != \"string\" ? problems.push(\n      error(\n        `Style #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n          style.value\n        )}`\n      )\n    ) : style.title || problems.push(warning(`Style ${name} is missing recommended \"title\" property`)) : problems.push(error(`Style #${index} is missing required \"value\" property`)), typeof style.blockEditor < \"u\" && (problems.push(\n      warning(\n        'Style has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.',\n        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY\n      )\n    ), style.component = style.component || style.blockEditor.render);\n  }), styles) : (problems.push(error(`\"styles\" declaration should be an array, got ${getTypeOf(styles)}`)), problems);\n}\nfunction validateDecorators(decorators, visitorContext, problems) {\n  return decorators.forEach((decorator, index) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(decorator)) {\n      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`));\n      return;\n    }\n    const name = decorator.value || `#${index}`, disallowedKeys = Object.keys(decorator).filter(\n      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith(\"_\")\n    );\n    disallowedKeys.length > 0 && problems.push(\n      error(\n        `Found unknown properties for decorator ${name}: ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(\n          disallowedKeys.map(quote$1)\n        )}`\n      )\n    ), decorator.value ? typeof decorator.value != \"string\" ? problems.push(\n      error(\n        `Decorator #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n          decorator.value\n        )}`\n      )\n    ) : decorator.title || problems.push(warning(`Decorator ${name} is missing recommended \"title\" property`)) : problems.push(error(`Decorator #${index} is missing required \"value\" property`)), typeof decorator.blockEditor < \"u\" && (problems.push(\n      warning(\n        `Decorator \"${name}\" has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY\n      )\n    ), decorator.icon = decorator.icon || decorator.blockEditor.icon, decorator.component = decorator.component || decorator.blockEditor.render);\n  }), decorators;\n}\nfunction validateAnnotations(annotations, visitorContext, problems) {\n  return annotations.map((annotation) => {\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(annotation))\n      return {\n        ...annotation,\n        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)]\n      };\n    const { _problems } = visitorContext.visit(annotation, visitorContext), targetType = annotation.type && visitorContext.getType(annotation.type);\n    return targetType && !isJSONTypeOf(targetType, \"object\", visitorContext) && _problems.push(\n      error(\n        `Annotation cannot have type \"${annotation.type}\" - annotation types must inherit from object`\n      )\n    ), typeof annotation.blockEditor < \"u\" && (problems.push(\n      warning(\n        'Annotation has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.',\n        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY\n      )\n    ), annotation.icon = annotation.icon || annotation.blockEditor.icon, annotation.blockEditor?.render && !annotation.components?.annotation && (annotation.components = annotation.components || {}, annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render)), { ...annotation, _problems };\n  });\n}\nfunction validateMembers(members, visitorContext, problems) {\n  if (!Array.isArray(members)) {\n    problems.push(error(`\"of\" declaration should be an array, got ${getTypeOf(members)}`));\n    return;\n  }\n  return members.map((member) => {\n    const { _problems } = visitorContext.visit(member, visitorContext);\n    if (member.type === \"object\" && member.name && visitorContext.getType(member.name))\n      return {\n        ...member,\n        _problems: [\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${member.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT\n          )\n        ]\n      };\n    let type = member;\n    for (; type && !type.jsonType; )\n      type = visitorContext.getType(type.type);\n    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n));\n    return (\n      // Must be object-like type (to validate hoisted types)\n      type && type.jsonType !== \"object\" || // Can't be a core type, or core object type that isn't supported (like 'span')\n      nonObjectCoreTypes.some((coreName) => coreName === member.type) ? {\n        ...member,\n        _problems: [\n          error(\n            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(\n              \"', '\"\n            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT\n          )\n        ]\n      } : { ...member, _problems }\n    );\n  });\n}\nfunction validateNonObjectFieldsProp(typeDef, visitorContext) {\n  if (!(\"fields\" in typeDef))\n    return [];\n  let type = typeDef;\n  for (; type && !type.jsonType; )\n    type = visitorContext.getType(type.type);\n  return type && type.jsonType !== \"object\" ? [error('Type has propery \"fields\", but is not an object/document type.')] : [];\n}\nconst quote = (str) => `\"${str}\"`;\nfunction validateTypeName(typeName, visitorContext) {\n  const possibleTypeNames = visitorContext.getTypeNames();\n  if (!typeName)\n    return [error(\"Type is missing a type.\", HELP_IDS.TYPE_MISSING_TYPE)];\n  if (typeof typeName != \"string\")\n    return [\n      error(\n        'Type has an invalid \"type\"-property - should be a string.',\n        HELP_IDS.TYPE_MISSING_TYPE\n      )\n    ];\n  if (!possibleTypeNames.includes(typeName)) {\n    const suggestions = possibleTypeNames.map((possibleTypeName) => [leven__WEBPACK_IMPORTED_MODULE_8__(typeName, possibleTypeName), possibleTypeName]).filter(([distance]) => distance < 3).map(([_, name]) => name), suggestion = suggestions.length > 0 ? ` Did you mean ${humanize_list__WEBPACK_IMPORTED_MODULE_4__(suggestions.map(quote), { conjunction: \"or\" })}?` : \"\";\n    return [error(`Unknown type: ${typeName}.${suggestion}`)];\n  }\n  return [];\n}\nfunction validateDeprecatedProperties(type) {\n  const warnings = [];\n  return type?.inputComponent && warnings.push(\n    warning('The \"inputComponent\" property is deprecated. Use \"components.input\" instead.')\n  ), type?.preview?.component && warnings.push(\n    warning('The \"preview.component\" property is deprecated. Use \"components.preview\" instead.')\n  ), type?.diffComponent && warnings.push(\n    warning('The \"diffComponent\" property is deprecated. Use \"components.diff\" instead.')\n  ), type?.options?.editModal && warnings.push(\n    warning('The \"options.editModal\" property is deprecated. Use \"options.modal\" instead.')\n  ), type?.options?.isHighlighted && warnings.push(\n    warning(\n      'The \"options.isHighlighted\" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.'\n    )\n  ), warnings;\n}\nvar common = (typeDef, visitorContext) => ({\n  ...typeDef,\n  _problems: [\n    ...validateTypeName(typeDef.type, visitorContext),\n    ...validateNonObjectFieldsProp(typeDef, visitorContext),\n    ...validateDeprecatedProperties(typeDef)\n  ].filter(Boolean)\n});\nfunction normalizeToProp$2(typeDef) {\n  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;\n}\nconst VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;\nfunction isValidDatasetName(name) {\n  return name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name) || `The provided dataset \"${name}\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`;\n}\nvar crossDatasetReference = (typeDef, visitorContext) => {\n  const isValidTo = Array.isArray(typeDef.to) || lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(typeDef.to), normalizedTo = normalizeToProp$2(typeDef), problems = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__([\n    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(\n      (dupes) => error(\n        `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n      )\n    ) : error(\n      'The cross dataset reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n    )\n  ]);\n  if (isValidTo && normalizedTo.length === 0 && problems.push(\n    error(\n      'The cross dataset reference type should define at least one referenced type. Please check the \"to\" property.',\n      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n    )\n  ), normalizedTo.forEach((crossDatasetTypeDef, index) => {\n    crossDatasetTypeDef.type || problems.push(\n      error(\n        `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n      )\n    ), lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(crossDatasetTypeDef.preview) || problems.push(\n      error(\n        `Missing required preview config for the referenced type \"${crossDatasetTypeDef.type || \"<unknown type>\"}\"`,\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n      )\n    );\n  }), typeof typeDef.dataset == \"string\") {\n    const datasetValidation = isValidDatasetName(typeDef.dataset);\n    datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));\n  } else\n    problems.push(\n      error(\n        \"A cross dataset reference must specify a `dataset`\",\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n      )\n    );\n  return typeDef.studioUrl && typeof typeDef.studioUrl != \"function\" && problems.push(\n    error(\n      'The \"studioUrl\" property on a cross dataset reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID\n    )\n  ), problems.push(...getOptionErrors$2(typeDef)), {\n    ...typeDef,\n    _problems: problems\n  };\n};\nfunction getOptionErrors$2(typeDef) {\n  const { options } = typeDef, problems = [];\n  return problems.push(\n    ...[\"filter\", \"filterParams\"].filter((key) => key in typeDef).map(\n      (key) => error(\n        `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION\n      )\n    )\n  ), options ? lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options) ? typeof options.filter == \"function\" && typeof options.filterParams < \"u\" ? problems.concat(\n    error(\n      \"`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.\",\n      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION\n    )\n  ) : typeof options.filter == \"function\" || !options.filter && !options.filterParams ? problems : typeof options.filter != \"string\" ? problems.concat(\n    error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`)\n  ) : typeof options.filterParams < \"u\" && !lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options.filterParams) ? problems.concat(error(\"If set, `filterParams` must be an object.\")) : options.filterParams ? problems.concat(\n    Object.keys(options.filterParams).filter((key) => key.startsWith(\"__\") || key.startsWith(\"$\")).map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`))\n  ) : problems : problems.concat(\n    error(\n      \"The reference type expects `options` to be an object\",\n      HELP_IDS.REFERENCE_INVALID_OPTIONS\n    )\n  ) : problems;\n}\nconst REACT_SYM_RE = /^Symbol\\(react\\..+\\)$/;\nfunction isComponentLike(value) {\n  return typeof value == \"function\" || typeof value?.$$typeof == \"symbol\" && REACT_SYM_RE.test(String(value?.$$typeof));\n}\nfunction validateComponent(typeDef) {\n  const components = \"components\" in typeDef ? typeDef.components : !1;\n  if (!components)\n    return [];\n  const warnings = [];\n  return components.input && !isComponentLike(components.input) && warnings.push(\n    warning(\n      `The \\`components.input\\` property is set but does not appear to be a valid React component (expected a function, but saw ${object_inspect__WEBPACK_IMPORTED_MODULE_12__(\n        components.input\n      )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`\n    )\n  ), components.field && !isComponentLike(components.field) && warnings.push(\n    warning(\n      `The \\`components.field\\` property is set but does not appear to be a valid React component (expected a function, but saw ${object_inspect__WEBPACK_IMPORTED_MODULE_12__(\n        components.field\n      )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`\n    )\n  ), components.item && !isComponentLike(components.item) && warnings.push(\n    warning(\n      `The \\`components.item\\` property is set but does not appear to be a valid React component (expected a function, but saw ${object_inspect__WEBPACK_IMPORTED_MODULE_12__(\n        components.item\n      )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`\n    )\n  ), components.preview && !isComponentLike(components.preview) && warnings.push(\n    warning(\n      `The \\`components.preview\\` property is set but does not appear to be a valid React component (expected a function, but saw ${object_inspect__WEBPACK_IMPORTED_MODULE_12__(\n        components.preview\n      )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`\n    )\n  ), warnings;\n}\nconst VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/, CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;\nfunction validateFieldName(name) {\n  return typeof name != \"string\" ? [\n    error(\n      `Field names must be strings. Saw \"${object_inspect__WEBPACK_IMPORTED_MODULE_12__(name)}\"`,\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID\n    )\n  ] : name.startsWith(\"_\") ? [\n    error(\n      `Invalid field name \"${name}\". Field names cannot start with underscores \"_\" as it's reserved for system fields.`,\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID\n    )\n  ] : VALID_FIELD_RE.test(name) ? CONVENTIONAL_FIELD_RE.test(name) ? [] : [\n    warning(\n      \"Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on.\"\n    ),\n    HELP_IDS.OBJECT_FIELD_NAME_INVALID\n  ] : [\n    error(\n      `Invalid field name: \"${name}\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(\n        VALID_FIELD_RE\n      )}).`,\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID\n    )\n  ];\n}\nfunction validateField(field, _visitorContext) {\n  if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(field))\n    return [\n      error(\n        `Incorrect type for field definition - should be an object, saw ${object_inspect__WEBPACK_IMPORTED_MODULE_12__(field)}`,\n        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE\n      )\n    ];\n  const problems = [];\n  return problems.push(\n    ...\"name\" in field ? validateFieldName(field.name) : [error(\"Missing field name\", HELP_IDS.OBJECT_FIELD_NAME_INVALID)]\n  ), problems.push(...validateComponent(field)), problems;\n}\nfunction getDuplicateFields(array2) {\n  const dupes = {};\n  return array2.forEach((field) => {\n    dupes[field.name] || (dupes[field.name] = []), dupes[field.name].push(field);\n  }), Object.keys(dupes).map((fieldName) => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);\n}\nfunction validateFields(fields, options = { allowEmpty: !1 }) {\n  const problems = [];\n  if (!Array.isArray(fields))\n    return [\n      error(\n        `The \"fields\" property must be an array of fields. Instead saw \"${typeof fields}\"`,\n        HELP_IDS.OBJECT_FIELDS_INVALID\n      )\n    ];\n  const fieldsWithNames = fields.filter((field) => typeof field.name == \"string\");\n  getDuplicateFields(fieldsWithNames).forEach((dupes) => {\n    problems.push(\n      error(\n        `Found ${dupes.length} fields with name \"${dupes[0].name}\" in object`,\n        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE\n      )\n    );\n  }), fields.length === 0 && !options.allowEmpty && problems.push(error(\"Object should have at least one field\", HELP_IDS.OBJECT_FIELDS_INVALID));\n  const standaloneBlockFields = fields.filter((field) => field.type === \"block\").map((field) => `\"${field.name}\"`);\n  if (standaloneBlockFields.length > 0) {\n    const fmtFields = standaloneBlockFields.join(\", \");\n    problems.push(\n      error(\n        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,\n        HELP_IDS.STANDALONE_BLOCK_TYPE\n      )\n    );\n  }\n  return problems;\n}\nfunction validatePreview(preview) {\n  return lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(preview) ? typeof preview.prepare < \"u\" && typeof preview.prepare != \"function\" ? [\n    error(\n      `The \"preview.prepare\" property must be a function, instead saw \"${typeof preview.prepare}\"`\n    )\n  ] : preview.select ? lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(preview.select) ? Object.keys(preview.select).reduce((errs, key) => typeof preview.select[key] == \"string\" ? errs : errs.concat(\n    error(\n      `The key \"${key}\" of \"preview.select\" must be a string, instead saw \"${typeof preview.select[key]}\"`\n    )\n  ), []) : [\n    error(\n      `The \"preview.select\" property must be an object, instead saw \"${typeof preview.prepare}\"`\n    )\n  ] : [] : [error(`The \"preview\" property must be an object, instead saw \"${typeof preview}\"`)];\n}\nvar object = (typeDef, visitorContext) => {\n  let problems = validateFields(typeDef.fields), preview = typeDef.preview;\n  if (preview) {\n    const previewErrors = validatePreview(typeDef.preview);\n    problems = problems.concat(previewErrors), preview = previewErrors.some((err) => err.severity === \"error\") ? {} : preview;\n  }\n  return typeDef.type !== \"document\" && typeDef.type !== \"object\" && typeof typeDef.initialValue < \"u\" && problems.push(\n    error('The \"initialValue\" property is currently only supported for document & object types.')\n  ), {\n    ...typeDef,\n    preview,\n    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {\n      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field).concat(_problems || [])\n      };\n    }),\n    _problems: problems\n  };\n}, documentVisitor = (typeDefinition, visitorContext) => {\n  const typeDef = object(typeDefinition, visitorContext), { initialValue, initialValues } = typeDef;\n  return typeof initialValue < \"u\" && !lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(initialValue) && typeof initialValue != \"function\" && typeDef._problems.push(\n    error('The \"initialValue\" property must be either a plain object or a function')\n  ), typeof initialValues < \"u\" && typeDef._problems.push(error('Found property \"initialValues\" - did you mean \"initialValue\"?')), typeDef;\n}, file = (typeDef, visitorContext) => {\n  const problems = [], fields = typeDef.fields;\n  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));\n  const invalidFieldNames = Array.isArray(fields) ? fields?.filter((field) => field.name === \"asset\") : [];\n  return typeDef.options && typeof typeDef.options.metadata < \"u\" && !Array.isArray(typeDef.options.metadata) ? problems.push(\n    error(\n      \"Invalid type for file `metadata` field - must be an array of strings\",\n      HELP_IDS.ASSET_METADATA_FIELD_INVALID\n    )\n  ) : invalidFieldNames.length > 0 && problems.push(error(\"The name `asset` is not a valid field name for type `file`.\")), {\n    ...typeDef,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field).concat(_problems || [])\n      };\n    }),\n    _problems: problems\n  };\n};\nfunction normalizeToProp$1(typeDef) {\n  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : [];\n}\nfunction isValidResourceType(resourceType) {\n  return resourceType ? resourceType != \"media-library\" && resourceType != \"dataset\" ? 'The resource type must be either \"media-library\" or \"dataset\"' : !0 : \"The resource type must be a non-empty string\";\n}\nfunction isValidResourceId(resourceType, resourceId) {\n  return resourceId ? resourceType === \"dataset\" ? resourceId.split(\".\").length !== 2 ? 'The resource ID for a dataset reference must be on the form \"<projectId>.<datasetName>\"' : !0 : resourceType === \"media-library\" ? !0 : `Cannot validate resource ID for resource type: ${resourceType}` : \"The resource ID must be a non-empty string\";\n}\nvar globalDocumentReference = (typeDef, visitorContext) => {\n  const isValidTo = Array.isArray(typeDef.to) || lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(typeDef.to), normalizedTo = normalizeToProp$1(typeDef), problems = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__([\n    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(\n      (dupes) => error(\n        `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n      )\n    ) : error(\n      'The global document reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n    )\n  ]);\n  if (isValidTo && normalizedTo.length === 0 && problems.push(\n    error(\n      'The global document reference type should define at least one referenced type. Please check the \"to\" property.',\n      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n    )\n  ), normalizedTo.forEach((crossDatasetTypeDef, index) => {\n    crossDatasetTypeDef.type || problems.push(\n      error(\n        `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n      )\n    ), lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(crossDatasetTypeDef.preview) || problems.push(\n      error(\n        `Missing required preview config for the referenced type \"${crossDatasetTypeDef.type || \"<unknown type>\"}\"`,\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n      )\n    );\n  }), typeof typeDef.resourceType == \"string\") {\n    const validation = isValidResourceType(typeDef.resourceType);\n    validation !== !0 && problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));\n  } else\n    problems.push(\n      error(\n        \"A global document reference must specify a `resourceType`\",\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n      )\n    );\n  if (typeof typeDef.resourceId == \"string\") {\n    const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId);\n    datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));\n  } else\n    problems.push(\n      error(\n        \"A global document reference must specify a `resourceId`\",\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n      )\n    );\n  return typeDef.studioUrl && typeof typeDef.studioUrl != \"function\" && typeof typeDef.studioUrl != \"string\" && problems.push(\n    error(\n      'The \"studioUrl\" property on a global document reference must either be a function taking \"{id, type}\" as argument and returning a studio url, or a string being the base url pointing to a studio.',\n      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID\n    )\n  ), problems.push(...getOptionErrors$1(typeDef)), {\n    ...typeDef,\n    _problems: problems\n  };\n};\nfunction getOptionErrors$1(typeDef) {\n  const { options } = typeDef, problems = [];\n  return problems.push(\n    ...[\"filter\", \"filterParams\"].filter((key) => key in typeDef).map(\n      (key) => error(\n        `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION\n      )\n    )\n  ), options ? lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options) ? typeof options.filter == \"function\" && typeof options.filterParams < \"u\" ? problems.concat(\n    error(\n      \"`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.\",\n      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION\n    )\n  ) : typeof options.filter == \"function\" || !options.filter && !options.filterParams ? problems : typeof options.filter != \"string\" ? problems.concat(\n    error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`)\n  ) : typeof options.filterParams < \"u\" && !lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options.filterParams) ? problems.concat(error(\"If set, `filterParams` must be an object.\")) : options.filterParams ? problems.concat(\n    Object.keys(options.filterParams).filter((key) => key.startsWith(\"__\") || key.startsWith(\"$\")).map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`))\n  ) : problems : problems.concat(\n    error(\n      \"The reference type expects `options` to be an object\",\n      HELP_IDS.REFERENCE_INVALID_OPTIONS\n    )\n  ) : problems;\n}\nconst autoMeta = [\"dimensions\", \"hasAlpha\", \"isOpaque\"];\nvar image = (typeDef, visitorContext) => {\n  const problems = [], fields = typeDef.fields;\n  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));\n  let options = typeDef.options;\n  const metadata = options?.metadata, superfluousMeta = Array.isArray(metadata) ? metadata.filter((meta) => autoMeta.includes(meta)) : [], invalidFieldNames = [\"asset\", \"hotspot\", \"crop\"], fieldsWithInvalidName = Array.isArray(fields) ? fields?.filter((field) => invalidFieldNames.includes(field.name)) : [];\n  return typeof metadata < \"u\" && !Array.isArray(metadata) ? problems.push(\n    error(\n      \"Invalid type for image `metadata` field - must be an array of strings\",\n      HELP_IDS.ASSET_METADATA_FIELD_INVALID\n    )\n  ) : superfluousMeta.length > 0 ? (problems.push(\n    warning(\n      `Image \\`metadata\\` field contains superfluous properties (they are always included): ${superfluousMeta.join(\n        \", \"\n      )}`\n    )\n  ), options = { ...options, metadata: metadata.filter((meta) => !autoMeta.includes(meta)) }) : fieldsWithInvalidName.length > 0 && problems.push(\n    error(\n      `The names \\`${invalidFieldNames.join(\n        \"`, `\"\n      )}\\` are invalid field names for type \\`image\\`.`\n    )\n  ), {\n    ...typeDef,\n    options,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field).concat(_problems || [])\n      };\n    }),\n    _problems: problems\n  };\n};\nfunction normalizeToProp(typeDef) {\n  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;\n}\nvar reference = (typeDef, visitorContext) => {\n  const isValidTo = Array.isArray(typeDef.to) || lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(typeDef.to), normalizedTo = normalizeToProp(typeDef), problems = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_1__([\n    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(\n      (dupes) => error(\n        `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n        HELP_IDS.REFERENCE_TO_INVALID\n      )\n    ) : error(\n      'The reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n      HELP_IDS.REFERENCE_TO_INVALID\n    )\n  ]);\n  return isValidTo && normalizedTo.length === 0 && problems.push(\n    error(\n      'The reference type should define at least one accepted type. Please check the \"to\" property.',\n      HELP_IDS.REFERENCE_TO_INVALID\n    )\n  ), problems.push(...getOptionErrors(typeDef)), {\n    ...typeDef,\n    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),\n    _problems: problems\n  };\n};\nfunction getOptionErrors(typeDef) {\n  const { options } = typeDef, problems = [];\n  return problems.push(\n    ...[\"filter\", \"filterParams\"].filter((key) => key in typeDef).map(\n      (key) => error(\n        `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION\n      )\n    )\n  ), options ? lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options) ? typeof options.filter == \"function\" && typeof options.filterParams < \"u\" ? problems.concat(\n    error(\n      \"`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.\",\n      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION\n    )\n  ) : typeof options.filter == \"function\" || !options.filter && !options.filterParams ? problems : typeof options.filter != \"string\" ? problems.concat(\n    error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`)\n  ) : typeof options.filterParams < \"u\" && !lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_6__(options.filterParams) ? problems.concat(error(\"If set, `filterParams` must be an object.\")) : options.filterParams ? problems.concat(\n    Object.keys(options.filterParams).filter((key) => key.startsWith(\"__\") || key.startsWith(\"$\")).map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`))\n  ) : problems : problems.concat(\n    error(\n      \"The reference type expects `options` to be an object\",\n      HELP_IDS.REFERENCE_INVALID_OPTIONS\n    )\n  ) : problems;\n}\nvar rootType = (typeDef, visitorContext) => {\n  const hasName = !!typeDef.name;\n  if (!hasName && Object.keys(typeDef).length === 1)\n    return {\n      ...typeDef,\n      _problems: [\n        error(\n          \"Invalid/undefined type declaration, check declaration or the import/export of the schema type.\",\n          HELP_IDS.TYPE_INVALID\n        )\n      ]\n    };\n  const problems = [];\n  return looksLikeEsmModule(typeDef) ? problems.push(\n    error(\n      \"Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property\",\n      HELP_IDS.TYPE_IS_ESM_MODULE\n    )\n  ) : hasName ? visitorContext.isReserved(typeDef.name) && problems.push(\n    error(\n      `Invalid type name: \"${typeDef.name}\" is a reserved name.`,\n      HELP_IDS.TYPE_NAME_RESERVED\n    )\n  ) : problems.push(error(\"Missing type name\", HELP_IDS.TYPE_MISSING_NAME)), visitorContext.isDuplicate(typeDef.name) && problems.push(\n    error(\n      `Invalid type name: A type with name \"${typeDef.name}\" is already defined in the schema.`\n    )\n  ), problems.push(...validateComponent(typeDef)), \"title\" in typeDef && typeof typeDef.title != \"string\" && problems.push(warning(\"Type title is not a string.\", HELP_IDS.TYPE_TITLE_INVALID)), {\n    ...typeDef,\n    _problems: problems\n  };\n};\nfunction looksLikeEsmModule(typeDef) {\n  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);\n}\nvar slug = (typeDef, visitorContext) => {\n  const problems = [];\n  return typeDef.options && typeDef.options.slugifyFn && (problems.push(\n    warning(\n      'Heads up! The \"slugifyFn\" option has been renamed to \"slugify\".',\n      HELP_IDS.SLUG_SLUGIFY_FN_RENAMED\n    )\n  ), typeDef.options.slugify = typeDef.options.slugifyFn), {\n    ...typeDef,\n    _problems: problems\n  };\n};\nconst typeVisitors = {\n  array,\n  object,\n  slug,\n  file,\n  image,\n  block: validateBlockType,\n  document: documentVisitor,\n  reference,\n  crossDatasetReference,\n  globalDocumentReference\n}, getNoopVisitor = (visitorContext) => (schemaDef) => ({\n  name: `<unnamed_type_@_index_${visitorContext.index}>`,\n  ...schemaDef,\n  _problems: []\n});\nfunction combine(...visitors) {\n  return (schemaType, visitorContext) => visitors.reduce(\n    (result, visitor) => {\n      const res = visitor(result, visitorContext);\n      return {\n        ...res,\n        _problems: result._problems.concat(res._problems)\n      };\n    },\n    { _problems: [], ...schemaType }\n  );\n}\nfunction validateSchema(schemaTypes, { transformTypeVisitors = (visitors) => visitors } = {}) {\n  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {\n    const typeVisitor = schemaDef && schemaDef.type && transformTypeVisitors(typeVisitors)[schemaDef.type] || getNoopVisitor(visitorContext);\n    return visitorContext.isRoot ? combine(rootType, common, typeVisitor)(schemaDef, visitorContext) : combine(common, typeVisitor)(schemaDef, visitorContext);\n  });\n}\nfunction unsupportedTypeValidator(typeLabel) {\n  return function() {\n    return {\n      _problems: [\n        {\n          severity: \"error\",\n          message: `Type unsupported in Media Library aspects: ${typeLabel}.`\n        }\n      ]\n    };\n  };\n}\nfunction validateMediaLibraryAssetAspect(maybeAspect) {\n  const validated = validateSchema([maybeAspect], {\n    transformTypeVisitors: (typeVisitors2) => ({\n      ...typeVisitors2,\n      document: unsupportedTypeValidator(\"document\"),\n      image: unsupportedTypeValidator(\"image\"),\n      file: unsupportedTypeValidator(\"file\"),\n      video: unsupportedTypeValidator(\"sanity.video\"),\n      reference: unsupportedTypeValidator(\"reference\"),\n      crossDatasetReference: unsupportedTypeValidator(\"cross dataset reference\")\n    })\n  }), errors = groupProblems(validated.getTypes()).map((group) => group.problems.filter(({ severity }) => severity === \"error\")).filter((problems) => problems.length);\n  return [errors.length === 0, errors];\n}\n\n//# sourceMappingURL=_internal.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrc2NoZW1hQDMuOTkuMF9AdHlwZXMrcmVhY3RAMTguMy4yNF9kZWJ1Z0A0LjQuMy9ub2RlX21vZHVsZXMvQHNhbml0eS9zY2hlbWEvbGliL19pbnRlcm5hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRFO0FBQ2xCO0FBQ29FO0FBQ2hGO0FBQ0k7QUFDVjtBQUNSO0FBQ0U7QUFDTztBQUNHO0FBQ1E7QUFDbEI7QUFDUjtBQUNXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBVTtBQUNsQztBQUNBO0FBQ0EscURBQXFELGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBYyw0QkFBNEIsbUVBQWM7QUFDM0U7QUFDQTtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUE0RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVEQUF1RDtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQixxQkFBcUIsbUJBQW1CLHVCQUF1QixxQkFBcUIsb0JBQW9CLGtCQUFrQix1QkFBdUI7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEVBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMsNkNBQTZDO0FBQ3hGO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0JBQWtCLGlEQUFVO0FBQzVCO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCLDhCQUE4QixTQUFTLEtBQUs7QUFDbEc7QUFDQSxRQUFRLHVCQUF1Qix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYyxHQUFHLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsZ0JBQWdCO0FBQzFDLHFCQUFxQixjQUFjLEdBQUcsNkNBQTZDO0FBQ25GO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQStEO0FBQ3JFLE1BQU0sNkRBQTZEO0FBQ25FLE1BQU07QUFDTjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyRUFBMkU7QUFDakYsTUFBTSxpRkFBaUY7QUFDdkYsTUFBTSwrRUFBK0U7QUFDckYsTUFBTSxzRUFBc0U7QUFDNUUsTUFBTSx3RUFBd0U7QUFDOUUsTUFBTSw2RUFBNkU7QUFDbkYsTUFBTTtBQUNOO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1RUFBdUU7QUFDN0UsTUFBTSx1RUFBdUU7QUFDN0UsTUFBTSx1RUFBdUU7QUFDN0UsTUFBTTtBQUNOO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYTtB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bUxBQW1MLElBQUk7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRCxJQUFJO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLHdGQUF3RixVQUFVO0FBQ3JHO0FBQ0E7QUFhRTtBQUNGIiwic291cmNlcyI6WyJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHNhbml0eStzY2hlbWFAMy45OS4wX0B0eXBlcytyZWFjdEAxOC4zLjI0X2RlYnVnQDQuNC4zXFxub2RlX21vZHVsZXNcXEBzYW5pdHlcXHNjaGVtYVxcbGliXFxfaW50ZXJuYWwubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNldEJ1aWxkZXIsIHByb2Nlc3NTZXRTeW5jaHJvbml6YXRpb24gfSBmcm9tIFwiQHNhbml0eS9kZXNjcmlwdG9yc1wiO1xuaW1wb3J0IHsgT1dOX1BST1BTX05BTUUgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3Jlc29sdmUubWpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX01BWF9GSUVMRF9ERVBUSCwgcmVzb2x2ZVNlYXJjaENvbmZpZywgcmVzb2x2ZVNlYXJjaENvbmZpZ0ZvckJhc2VGaWVsZFBhdGhzIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9yZXNvbHZlLm1qc1wiO1xuaW1wb3J0IGRpZmZlcmVuY2UgZnJvbSBcImxvZGFzaC9kaWZmZXJlbmNlLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZWZlcmVuY2VUeXBlTm9kZSB9IGZyb20gXCJncm9xLWpzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCBnZXQgZnJvbSBcImxvZGFzaC9nZXQuanNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IGh1bWFuaXplTGlzdCBmcm9tIFwiaHVtYW5pemUtbGlzdFwiO1xuaW1wb3J0IHBhcnRpdGlvbiBmcm9tIFwibG9kYXNoL3BhcnRpdGlvbi5qc1wiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSBcImxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI7XG5pbXBvcnQgb21pdCBmcm9tIFwibG9kYXNoL29taXQuanNcIjtcbmltcG9ydCBsZXZlbiBmcm9tIFwibGV2ZW5cIjtcbmltcG9ydCBpbnNwZWN0IGZyb20gXCJvYmplY3QtaW5zcGVjdFwiO1xuY29uc3QgTUFYX0RFUFRIX1VLTk9XTiA9IDU7XG5jbGFzcyBEZXNjcmlwdG9yQ29udmVydGVyIHtcbiAgb3B0cztcbiAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzeW5jaHJvbml6YXRpb24gb2JqZWN0IGZvciBhIHNjaGVtYS5cbiAgICpcbiAgICogVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhY2hlZCBpbiBhIHdlYWsgbWFwLlxuICAgKi9cbiAgZ2V0KHNjaGVtYSkge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuY2FjaGUuZ2V0KHNjaGVtYSk7XG4gICAgaWYgKHZhbHVlKSByZXR1cm4gdmFsdWU7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBTZXRCdWlsZGVyKCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNjaGVtYS5nZXRMb2NhbFR5cGVOYW1lcygpKSB7XG4gICAgICBjb25zdCB0eXBlRGVmID0gY29udmVydFR5cGVEZWYoc2NoZW1hLmdldChuYW1lKSk7XG4gICAgICBidWlsZGVyLmFkZE9iamVjdChcInNhbml0eS5zY2hlbWEubmFtZWRUeXBlXCIsIHsgbmFtZSwgdHlwZURlZiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYS5wYXJlbnQgJiYgYnVpbGRlci5hZGRTZXQodGhpcy5nZXQoc2NoZW1hLnBhcmVudCkpLCB2YWx1ZSA9IGJ1aWxkZXIuYnVpbGQoXCJzYW5pdHkuc2NoZW1hLnJlZ2lzdHJ5XCIpLCB0aGlzLmNhY2hlLnNldChzY2hlbWEsIHZhbHVlKSwgdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb21tb25UeXBlRGVmKHNjaGVtYVR5cGUsIG9wdHMpIHtcbiAgY29uc3Qgb3duUHJvcHMgPSBPV05fUFJPUFNfTkFNRSBpbiBzY2hlbWFUeXBlID8gc2NoZW1hVHlwZVtPV05fUFJPUFNfTkFNRV0gOiBzY2hlbWFUeXBlO1xuICBsZXQgZmllbGRzO1xuICBBcnJheS5pc0FycmF5KG93blByb3BzLmZpZWxkcykgJiYgKGZpZWxkcyA9IG93blByb3BzLmZpZWxkcy5tYXAoXG4gICAgKHsgbmFtZSwgZ3JvdXAsIGZpZWxkc2V0LCB0eXBlIH0pID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgdHlwZURlZjogY29udmVydFR5cGVEZWYodHlwZSksXG4gICAgICBncm91cHM6IGFycmF5aWZ5U3RyaW5nKGdyb3VwKSxcbiAgICAgIGZpZWxkc2V0XG4gICAgfSlcbiAgKSk7XG4gIGxldCBmaWVsZHNldHM7XG4gIEFycmF5LmlzQXJyYXkob3duUHJvcHMuZmllbGRzZXRzKSAmJiAoZmllbGRzZXRzID0gZmlsdGVyU3RyaW5nS2V5KFxuICAgIFwibmFtZVwiLFxuICAgIG93blByb3BzLmZpZWxkc2V0cy5tYXAoXG4gICAgICAoeyBuYW1lLCB0aXRsZSwgZGVzY3JpcHRpb24sIGdyb3VwLCBoaWRkZW4sIHJlYWRPbmx5LCBvcHRpb25zIH0pID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRpdGxlOiBtYXliZVN0cmluZyh0aXRsZSksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtYXliZVN0cmluZyhkZXNjcmlwdGlvbiksXG4gICAgICAgIGdyb3VwOiBtYXliZVN0cmluZyhncm91cCksXG4gICAgICAgIGhpZGRlbjogY29uZGl0aW9uYWxUcnVlKGhpZGRlbiksXG4gICAgICAgIHJlYWRPbmx5OiBjb25kaXRpb25hbFRydWUocmVhZE9ubHkpLFxuICAgICAgICBvcHRpb25zOiBjb252ZXJ0VW5rbm93bihvcHRpb25zKVxuICAgICAgfSlcbiAgICApXG4gICkpO1xuICBsZXQgZ3JvdXBzO1xuICBBcnJheS5pc0FycmF5KG93blByb3BzLmdyb3VwcykgJiYgKGdyb3VwcyA9IGZpbHRlclN0cmluZ0tleShcbiAgICBcIm5hbWVcIixcbiAgICBvd25Qcm9wcy5ncm91cHMubWFwKFxuICAgICAgKHsgbmFtZSwgdGl0bGUsIGhpZGRlbiwgZGVmYXVsdDogZGVmIH0pID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRpdGxlOiBtYXliZVN0cmluZyh0aXRsZSksXG4gICAgICAgIGhpZGRlbjogY29uZGl0aW9uYWxUcnVlKGhpZGRlbiksXG4gICAgICAgIGRlZmF1bHQ6IG1heWJlVHJ1ZShkZWYpXG4gICAgICB9KVxuICAgIClcbiAgKSk7XG4gIGNvbnN0IHJlYXNvbiA9IG93blByb3BzLmRlcHJlY2F0ZWQ/LnJlYXNvbjtcbiAgcmV0dXJuIHtcbiAgICB0aXRsZTogbWF5YmVTdHJpbmcob3duUHJvcHMudGl0bGUpLFxuICAgIGRlc2NyaXB0aW9uOiBtYXliZVN0cmluZ09ySlNYKG93blByb3BzLmRlc2NyaXB0aW9uKSxcbiAgICByZWFkT25seTogY29uZGl0aW9uYWxUcnVlKG93blByb3BzLnJlYWRPbmx5KSxcbiAgICBoaWRkZW46IGNvbmRpdGlvbmFsVHJ1ZShvd25Qcm9wcy5oaWRkZW4pLFxuICAgIGxpdmVFZGl0OiBtYXliZVRydWUob3duUHJvcHMubGl2ZUVkaXQpLFxuICAgIG9wdGlvbnM6IGNvbnZlcnRVbmtub3duKG93blByb3BzLm9wdGlvbnMpLFxuICAgIGluaXRpYWxWYWx1ZTogY29udmVydFVua25vd24ob3duUHJvcHMuaW5pdGlhbFZhbHVlKSxcbiAgICBkZXByZWNhdGVkOiB0eXBlb2YgcmVhc29uID09IFwic3RyaW5nXCIgPyB7IHJlYXNvbiB9IDogdm9pZCAwLFxuICAgIHBsYWNlaG9sZGVyOiBtYXliZVN0cmluZyhvd25Qcm9wcy5wbGFjZWhvbGRlciksXG4gICAgcm93czogbWF5YmVOdW1iZXJBc1N0cmluZyhvd25Qcm9wcy5yb3dzKSxcbiAgICBmaWVsZHMsXG4gICAgZmllbGRzZXRzLFxuICAgIGdyb3Vwc1xuICB9O1xufVxuZnVuY3Rpb24gY29udmVydFR5cGVEZWYoc2NoZW1hVHlwZSwgb3B0cykge1xuICBjb25zdCBjb21tb24yID0gY29udmVydENvbW1vblR5cGVEZWYoc2NoZW1hVHlwZSk7XG4gIGlmICghc2NoZW1hVHlwZS50eXBlKVxuICAgIHJldHVybiB7XG4gICAgICBleHRlbmRzOiBudWxsLFxuICAgICAganNvblR5cGU6IHNjaGVtYVR5cGUuanNvblR5cGUsXG4gICAgICAuLi5jb21tb24yXG4gICAgfTtcbiAgc3dpdGNoIChzY2hlbWFUeXBlLnR5cGUubmFtZSkge1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0ZW5kczogXCJhcnJheVwiLFxuICAgICAgICBvZjogc2NoZW1hVHlwZS5vZi5tYXAoKG9mVHlwZSkgPT4gKHtcbiAgICAgICAgICBuYW1lOiBvZlR5cGUubmFtZSxcbiAgICAgICAgICB0eXBlRGVmOiBjb252ZXJ0VHlwZURlZihvZlR5cGUpXG4gICAgICAgIH0pKSxcbiAgICAgICAgLi4uY29tbW9uMlxuICAgICAgfTtcbiAgICBjYXNlIFwicmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcImdsb2JhbERvY3VtZW50UmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcImNyb3NzRGF0YXNldFJlZmVyZW5jZVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXh0ZW5kczogc2NoZW1hVHlwZS50eXBlLm5hbWUsXG4gICAgICAgIHRvOiBmaWx0ZXJTdHJpbmdLZXkoXG4gICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgc2NoZW1hVHlwZS50by5tYXAoKHRvVHlwZSkgPT4gKHsgbmFtZTogdG9UeXBlLm5hbWUgfHwgdG9UeXBlLnR5cGU/Lm5hbWUgfHwgdG9UeXBlLnR5cGUgfSkpXG4gICAgICAgICksXG4gICAgICAgIC4uLmNvbW1vbjJcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IGV4dGVuZHM6IHNjaGVtYVR5cGUudHlwZS5uYW1lLCAuLi5jb21tb24yIH07XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8gdmFsIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gbWF5YmVOdW1iZXJBc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIiA/IHZhbC50b1N0cmluZygpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gbWF5YmVUcnVlKHZhbCkge1xuICByZXR1cm4gdmFsID09PSAhMCA/ICEwIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxUcnVlKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcImZ1bmN0aW9uXCIgPyBGVU5DVElPTl9NQVJLRVIgOiBtYXliZVRydWUodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbHRlclN0cmluZ0tleShrZXksIGFycikge1xuICByZXR1cm4gYXJyLmZpbHRlcigob2JqKSA9PiB0eXBlb2Ygb2JqW2tleV0gPT0gXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBhcnJheWlmeVN0cmluZyh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gW3ZhbF07XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpXG4gICAgcmV0dXJuIHZhbC5maWx0ZXIoKGVsZW0pID0+IHR5cGVvZiBlbGVtID09IFwic3RyaW5nXCIpO1xufVxuY29uc3QgRlVOQ1RJT05fTUFSS0VSID0geyBfX3R5cGU6IFwiZnVuY3Rpb25cIiB9LCBVTktOT1dOX01BUktFUiA9IHsgX190eXBlOiBcInVua25vd25cIiB9LCBVTkRFRklORURfTUFSS0VSID0geyBfX3R5cGU6IFwidW5kZWZpbmVkXCIgfSwgQ1lDTElDX01BUktFUiA9IHsgX190eXBlOiBcImN5Y2xpY1wiIH0sIE1BWF9ERVBUSF9NQVJLRVIgPSB7IF9fdHlwZTogXCJtYXhEZXB0aFwiIH07XG5mdW5jdGlvbiBjb252ZXJ0VW5rbm93bih2YWwsIHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBtYXhEZXB0aCA9IE1BWF9ERVBUSF9VS05PV04pIHtcbiAgaWYgKG1heERlcHRoID09PSAwKSByZXR1cm4gTUFYX0RFUFRIX01BUktFUjtcbiAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsID09IFwiYm9vbGVhblwiIHx8IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIHZhbCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiB7IF9fdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IHZhbC50b1N0cmluZygpIH07XG4gIGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIEZVTkNUSU9OX01BUktFUjtcbiAgaWYgKHNlZW4uaGFzKHZhbCkpXG4gICAgcmV0dXJuIENZQ0xJQ19NQVJLRVI7XG4gIGlmIChzZWVuLmFkZCh2YWwpLCB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgICAgcmV0dXJuIHZhbC5tYXAoKGVsZW0pID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gY29udmVydFVua25vd24oZWxlbSwgc2VlbiwgbWF4RGVwdGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHJlcyA9PT0gdm9pZCAwID8gVU5ERUZJTkVEX01BUktFUiA6IHJlcztcbiAgICAgIH0pO1xuICAgIGlmIChcIiQkdHlwZW9mXCIgaW4gdmFsICYmIFwidHlwZVwiIGluIHZhbCAmJiBcInByb3BzXCIgaW4gdmFsKSB7XG4gICAgICBjb25zdCB7IHR5cGUsIHByb3BzIH0gPSB2YWwsIHN0clR5cGUgPSB0eXBlb2YgdHlwZSA9PSBcImZ1bmN0aW9uXCIgPyB0eXBlLm5hbWUgOiB0eXBlO1xuICAgICAgcmV0dXJuIHR5cGVvZiBzdHJUeXBlICE9IFwic3RyaW5nXCIgPyB2b2lkIDAgOiB7XG4gICAgICAgIF9fdHlwZTogXCJqc3hcIixcbiAgICAgICAgdHlwZTogc3RyVHlwZSxcbiAgICAgICAgcHJvcHM6IGNvbnZlcnRVbmtub3duKHByb3BzLCBzZWVuLCBtYXhEZXB0aCAtIDEpXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgaGFzVHlwZSA9ICExO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgZmllbGRdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpXG4gICAgICBrZXkgPT09IFwiX190eXBlXCIgJiYgKGhhc1R5cGUgPSAhMCksIHJlc3VsdFtrZXldID0gY29udmVydFVua25vd24oZmllbGQsIHNlZW4sIG1heERlcHRoIC0gMSk7XG4gICAgcmV0dXJuIGhhc1R5cGUgPyB7IF9fdHlwZTogXCJvYmplY3RcIiwgdmFsdWU6IHJlc3VsdCB9IDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBVTktOT1dOX01BUktFUjtcbn1cbmZ1bmN0aW9uIG1heWJlU3RyaW5nT3JKU1godmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIpIHJldHVybiB2YWw7XG4gIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PSBcIm9iamVjdFwiICYmIFwiJCR0eXBlb2ZcIiBpbiB2YWwgJiYgXCJ0eXBlXCIgaW4gdmFsICYmIFwicHJvcHNcIiBpbiB2YWwpIHtcbiAgICBjb25zdCB7IHR5cGUsIHByb3BzIH0gPSB2YWwsIHN0clR5cGUgPSB0eXBlb2YgdHlwZSA9PSBcImZ1bmN0aW9uXCIgPyB0eXBlLm5hbWUgOiB0eXBlO1xuICAgIHJldHVybiB0eXBlb2Ygc3RyVHlwZSAhPSBcInN0cmluZ1wiID8gdm9pZCAwIDogeyBfX3R5cGU6IFwianN4XCIsIHR5cGU6IHN0clR5cGUsIHByb3BzOiBjb252ZXJ0VW5rbm93bihwcm9wcykgfTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1NjaGVtYVN5bmNocm9uaXphdGlvbihzeW5jLCByZXNwb25zZSkge1xuICByZXR1cm4gcHJvY2Vzc1NldFN5bmNocm9uaXphdGlvbihzeW5jLCByZXNwb25zZSk7XG59XG5jb25zdCBBQ1RJT05TX0ZMQUcgPSBcIl9fZXhwZXJpbWVudGFsX2FjdGlvbnNcIiwgREVGQVVMVF9BQ1RJT05TID0gW1wiY3JlYXRlXCIsIFwidXBkYXRlXCIsIFwiZGVsZXRlXCIsIFwicHVibGlzaFwiXSwgVkFMSURfQUNUSU9OUyA9IERFRkFVTFRfQUNUSU9OUywgcmVhZEFjdGlvbnMgPSAoc2NoZW1hVHlwZSkgPT4gQUNUSU9OU19GTEFHIGluIHNjaGVtYVR5cGUgPyBzY2hlbWFUeXBlW0FDVElPTlNfRkxBR10gOiBERUZBVUxUX0FDVElPTlMsIHZhbGlkYXRlQWN0aW9ucyA9ICh0eXBlTmFtZSwgYWN0aW9ucykgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYWN0aW9ucykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSB2YWx1ZSBvZiA8dHlwZT4uJHtBQ1RJT05TX0ZMQUd9IHNob3VsZCBiZSBhbiBhcnJheSB3aXRoIGFueSBvZiB0aGUgYWN0aW9ucyAke1ZBTElEX0FDVElPTlMuam9pbihcbiAgICAgICAgXCIsIFwiXG4gICAgICApfWBcbiAgICApO1xuICBjb25zdCBpbnZhbGlkID0gZGlmZmVyZW5jZShhY3Rpb25zLCBWQUxJRF9BQ1RJT05TKTtcbiAgaWYgKGludmFsaWQubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBhY3Rpb24ke2ludmFsaWQubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn0gY29uZmlndXJlZCBmb3Igc2NoZW1hIHR5cGUgXCIke3R5cGVOYW1lfVwiOiAke2ludmFsaWQuam9pbihcbiAgICAgICAgXCIsIFwiXG4gICAgICApfS4gVmFsaWQgYWN0aW9ucyBhcmU6ICR7VkFMSURfQUNUSU9OUy5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIHJldHVybiBhY3Rpb25zO1xufSwgcmVzb2x2ZUVuYWJsZWRBY3Rpb25zID0gKHNjaGVtYVR5cGUpID0+IHZhbGlkYXRlQWN0aW9ucyhzY2hlbWFUeXBlLm5hbWUsIHJlYWRBY3Rpb25zKHNjaGVtYVR5cGUpKSwgaXNBY3Rpb25FbmFibGVkID0gKHNjaGVtYVR5cGUsIGFjdGlvbikgPT4gcmVzb2x2ZUVuYWJsZWRBY3Rpb25zKHNjaGVtYVR5cGUpLmluY2x1ZGVzKGFjdGlvbik7XG52YXIgYXNzZXRTb3VyY2VEYXRhID0ge1xuICBuYW1lOiBcInNhbml0eS5hc3NldFNvdXJjZURhdGFcIixcbiAgdGl0bGU6IFwiQXNzZXQgU291cmNlIERhdGFcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgZmllbGRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJuYW1lXCIsXG4gICAgICB0aXRsZTogXCJTb3VyY2UgbmFtZVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBjYW5vbmljYWwgbmFtZSBmb3IgdGhlIHNvdXJjZSB0aGlzIGFzc2V0IGlzIG9yaWdpbmF0aW5nIGZyb21cIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiaWRcIixcbiAgICAgIHRpdGxlOiBcIkFzc2V0IFNvdXJjZSBJRFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIGFzc2V0IHdpdGhpbiB0aGUgb3JpZ2luYXRpbmcgc291cmNlIHNvIHlvdSBjYW4gcHJvZ3JhbWF0aWNhbGx5IGZpbmQgYmFjayB0byBpdFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJ1cmxcIixcbiAgICAgIHRpdGxlOiBcIkFzc2V0IGluZm9ybWF0aW9uIFVSTFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQSBVUkwgdG8gZmluZCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgYXNzZXQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH1cbiAgXVxufSwgZmlsZUFzc2V0ID0ge1xuICBuYW1lOiBcInNhbml0eS5maWxlQXNzZXRcIixcbiAgdGl0bGU6IFwiRmlsZVwiLFxuICB0eXBlOiBcImRvY3VtZW50XCIsXG4gIGZpZWxkc2V0czogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwic3lzdGVtXCIsXG4gICAgICB0aXRsZTogXCJTeXN0ZW0gZmllbGRzXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaGVzZSBmaWVsZHMgYXJlIG1hbmFnZWQgYnkgdGhlIHN5c3RlbSBhbmQgbm90IGVkaXRhYmxlXCJcbiAgICB9XG4gIF0sXG4gIGZpZWxkczogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwib3JpZ2luYWxGaWxlbmFtZVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIk9yaWdpbmFsIGZpbGUgbmFtZVwiLFxuICAgICAgcmVhZE9ubHk6ICEwXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImxhYmVsXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiTGFiZWxcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJ0aXRsZVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIlRpdGxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiZGVzY3JpcHRpb25cIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJEZXNjcmlwdGlvblwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImFsdFRleHRcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJBbHRlcm5hdGl2ZSB0ZXh0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwic2hhMWhhc2hcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJTSEExIGhhc2hcIixcbiAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImV4dGVuc2lvblwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIkZpbGUgZXh0ZW5zaW9uXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJtaW1lVHlwZVwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIk1pbWUgdHlwZVwiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgZmllbGRzZXQ6IFwic3lzdGVtXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwic2l6ZVwiLFxuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHRpdGxlOiBcIkZpbGUgc2l6ZSBpbiBieXRlc1wiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgZmllbGRzZXQ6IFwic3lzdGVtXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiYXNzZXRJZFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIkFzc2V0IElEXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJ1cGxvYWRJZFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgIGhpZGRlbjogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJwYXRoXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiUGF0aFwiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgZmllbGRzZXQ6IFwic3lzdGVtXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwidXJsXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiVXJsXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJzb3VyY2VcIixcbiAgICAgIHR5cGU6IFwic2FuaXR5LmFzc2V0U291cmNlRGF0YVwiLFxuICAgICAgdGl0bGU6IFwiU291cmNlXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH1cbiAgXSxcbiAgcHJldmlldzoge1xuICAgIHNlbGVjdDoge1xuICAgICAgdGl0bGU6IFwib3JpZ2luYWxGaWxlbmFtZVwiLFxuICAgICAgcGF0aDogXCJwYXRoXCIsXG4gICAgICBtaW1lVHlwZTogXCJtaW1lVHlwZVwiLFxuICAgICAgc2l6ZTogXCJzaXplXCJcbiAgICB9LFxuICAgIHByZXBhcmUoZG9jKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogZG9jLnRpdGxlIHx8IGRvYy5wYXRoLnNwbGl0KFwiL1wiKS5zbGljZSgtMSlbMF0sXG4gICAgICAgIHN1YnRpdGxlOiBgJHtkb2MubWltZVR5cGV9ICgkeyhkb2Muc2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQilgXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgb3JkZXJpbmdzOiBbXG4gICAge1xuICAgICAgdGl0bGU6IFwiRmlsZSBzaXplXCIsXG4gICAgICBuYW1lOiBcImZpbGVTaXplRGVzY1wiLFxuICAgICAgYnk6IFt7IGZpZWxkOiBcInNpemVcIiwgZGlyZWN0aW9uOiBcImRlc2NcIiB9XVxuICAgIH1cbiAgXVxufSwgZ2VvcG9pbnQgPSB7XG4gIHRpdGxlOiBcIkdlb2dyYXBoaWNhbCBQb2ludFwiLFxuICBuYW1lOiBcImdlb3BvaW50XCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGZpZWxkczogW1xuICAgIHtcbiAgICAgIG5hbWU6IFwibGF0XCIsXG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgdGl0bGU6IFwiTGF0aXR1ZGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJsbmdcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICB0aXRsZTogXCJMb25naXR1ZGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJhbHRcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICB0aXRsZTogXCJBbHRpdHVkZVwiXG4gICAgfVxuICBdXG59LCBpbWFnZUFzc2V0ID0ge1xuICBuYW1lOiBcInNhbml0eS5pbWFnZUFzc2V0XCIsXG4gIHRpdGxlOiBcIkltYWdlXCIsXG4gIHR5cGU6IFwiZG9jdW1lbnRcIixcbiAgZmllbGRzZXRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJzeXN0ZW1cIixcbiAgICAgIHRpdGxlOiBcIlN5c3RlbSBmaWVsZHNcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZXNlIGZpZWxkcyBhcmUgbWFuYWdlZCBieSB0aGUgc3lzdGVtIGFuZCBub3QgZWRpdGFibGVcIlxuICAgIH1cbiAgXSxcbiAgZmllbGRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJvcmlnaW5hbEZpbGVuYW1lXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiT3JpZ2luYWwgZmlsZSBuYW1lXCIsXG4gICAgICByZWFkT25seTogITBcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwibGFiZWxcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJMYWJlbFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcInRpdGxlXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiVGl0bGVcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJkZXNjcmlwdGlvblwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIkRlc2NyaXB0aW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiYWx0VGV4dFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIkFsdGVybmF0aXZlIHRleHRcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJzaGExaGFzaFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHRpdGxlOiBcIlNIQTEgaGFzaFwiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgZmllbGRzZXQ6IFwic3lzdGVtXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiZXh0ZW5zaW9uXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgdGl0bGU6IFwiRmlsZSBleHRlbnNpb25cIixcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIm1pbWVUeXBlXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgdGl0bGU6IFwiTWltZSB0eXBlXCIsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJzaXplXCIsXG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgdGl0bGU6IFwiRmlsZSBzaXplIGluIGJ5dGVzXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJhc3NldElkXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdGl0bGU6IFwiQXNzZXQgSURcIixcbiAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcInVwbG9hZElkXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcmVhZE9ubHk6ICEwLFxuICAgICAgaGlkZGVuOiAhMCxcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcInBhdGhcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJQYXRoXCIsXG4gICAgICByZWFkT25seTogITAsXG4gICAgICBmaWVsZHNldDogXCJzeXN0ZW1cIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJ1cmxcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB0aXRsZTogXCJVcmxcIixcbiAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIm1ldGFkYXRhXCIsXG4gICAgICB0eXBlOiBcInNhbml0eS5pbWFnZU1ldGFkYXRhXCIsXG4gICAgICB0aXRsZTogXCJNZXRhZGF0YVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcInNvdXJjZVwiLFxuICAgICAgdHlwZTogXCJzYW5pdHkuYXNzZXRTb3VyY2VEYXRhXCIsXG4gICAgICB0aXRsZTogXCJTb3VyY2VcIixcbiAgICAgIHJlYWRPbmx5OiAhMCxcbiAgICAgIGZpZWxkc2V0OiBcInN5c3RlbVwiXG4gICAgfVxuICBdLFxuICBwcmV2aWV3OiB7XG4gICAgc2VsZWN0OiB7XG4gICAgICBpZDogXCJfaWRcIixcbiAgICAgIHRpdGxlOiBcIm9yaWdpbmFsRmlsZW5hbWVcIixcbiAgICAgIG1pbWVUeXBlOiBcIm1pbWVUeXBlXCIsXG4gICAgICBzaXplOiBcInNpemVcIlxuICAgIH0sXG4gICAgcHJlcGFyZShkb2MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBkb2MudGl0bGUgfHwgdHlwZW9mIGRvYy5wYXRoID09IFwic3RyaW5nXCIgJiYgZG9jLnBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKC0xKVswXSxcbiAgICAgICAgbWVkaWE6IHsgYXNzZXQ6IHsgX3JlZjogZG9jLmlkIH0gfSxcbiAgICAgICAgc3VidGl0bGU6IGAke2RvYy5taW1lVHlwZX0gKCR7KE51bWJlcihkb2Muc2l6ZSkgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX0gTUIpYFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG9yZGVyaW5nczogW1xuICAgIHtcbiAgICAgIHRpdGxlOiBcIkZpbGUgc2l6ZVwiLFxuICAgICAgbmFtZTogXCJmaWxlU2l6ZURlc2NcIixcbiAgICAgIGJ5OiBbeyBmaWVsZDogXCJzaXplXCIsIGRpcmVjdGlvbjogXCJkZXNjXCIgfV1cbiAgICB9XG4gIF1cbn0sIGltYWdlQ3JvcCA9IHtcbiAgbmFtZTogXCJzYW5pdHkuaW1hZ2VDcm9wXCIsXG4gIHRpdGxlOiBcIkltYWdlIGNyb3BcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgZmllbGRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJ0b3BcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiYm90dG9tXCIsXG4gICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImxlZnRcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwicmlnaHRcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9XG4gIF1cbn0sIGltYWdlRGltZW5zaW9ucyA9IHtcbiAgbmFtZTogXCJzYW5pdHkuaW1hZ2VEaW1lbnNpb25zXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHRpdGxlOiBcIkltYWdlIGRpbWVuc2lvbnNcIixcbiAgZmllbGRzOiBbXG4gICAgeyBuYW1lOiBcImhlaWdodFwiLCB0eXBlOiBcIm51bWJlclwiLCB0aXRsZTogXCJIZWlnaHRcIiwgcmVhZE9ubHk6ICEwIH0sXG4gICAgeyBuYW1lOiBcIndpZHRoXCIsIHR5cGU6IFwibnVtYmVyXCIsIHRpdGxlOiBcIldpZHRoXCIsIHJlYWRPbmx5OiAhMCB9LFxuICAgIHsgbmFtZTogXCJhc3BlY3RSYXRpb1wiLCB0eXBlOiBcIm51bWJlclwiLCB0aXRsZTogXCJBc3BlY3QgcmF0aW9cIiwgcmVhZE9ubHk6ICEwIH1cbiAgXVxufSwgaW1hZ2VIb3RzcG90ID0ge1xuICBuYW1lOiBcInNhbml0eS5pbWFnZUhvdHNwb3RcIixcbiAgdGl0bGU6IFwiSW1hZ2UgaG90c3BvdFwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBmaWVsZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiBcInhcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwieVwiLFxuICAgICAgdHlwZTogXCJudW1iZXJcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJoZWlnaHRcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwid2lkdGhcIixcbiAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICB9XG4gIF1cbn0sIGltYWdlTWV0YWRhdGEgPSB7XG4gIG5hbWU6IFwic2FuaXR5LmltYWdlTWV0YWRhdGFcIixcbiAgdGl0bGU6IFwiSW1hZ2UgbWV0YWRhdGFcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgZmllbGRzZXRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJleHRyYVwiLFxuICAgICAgdGl0bGU6IFwiRXh0cmEgbWV0YWRhdGFcXHUyMDI2XCIsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGNvbGxhcHNhYmxlOiAhMFxuICAgICAgfVxuICAgIH1cbiAgXSxcbiAgZmllbGRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJsb2NhdGlvblwiLFxuICAgICAgdHlwZTogXCJnZW9wb2ludFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImRpbWVuc2lvbnNcIixcbiAgICAgIHRpdGxlOiBcIkRpbWVuc2lvbnNcIixcbiAgICAgIHR5cGU6IFwic2FuaXR5LmltYWdlRGltZW5zaW9uc1wiLFxuICAgICAgZmllbGRzZXQ6IFwiZXh0cmFcIlxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJwYWxldHRlXCIsXG4gICAgICB0eXBlOiBcInNhbml0eS5pbWFnZVBhbGV0dGVcIixcbiAgICAgIHRpdGxlOiBcIlBhbGV0dGVcIixcbiAgICAgIGZpZWxkc2V0OiBcImV4dHJhXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwibHFpcFwiLFxuICAgICAgdGl0bGU6IFwiTFFJUCAoTG93LVF1YWxpdHkgSW1hZ2UgUGxhY2Vob2xkZXIpXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcmVhZE9ubHk6ICEwXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImJsdXJIYXNoXCIsXG4gICAgICB0aXRsZTogXCJCbHVySGFzaFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIHJlYWRPbmx5OiAhMFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJoYXNBbHBoYVwiLFxuICAgICAgdGl0bGU6IFwiSGFzIGFscGhhIGNoYW5uZWxcIixcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgcmVhZE9ubHk6ICEwXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcImlzT3BhcXVlXCIsXG4gICAgICB0aXRsZTogXCJJcyBvcGFxdWVcIixcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgcmVhZE9ubHk6ICEwXG4gICAgfVxuICBdXG59LCBpbWFnZVBhbGV0dGUgPSB7XG4gIG5hbWU6IFwic2FuaXR5LmltYWdlUGFsZXR0ZVwiLFxuICB0aXRsZTogXCJJbWFnZSBwYWxldHRlXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIGZpZWxkczogW1xuICAgIHsgbmFtZTogXCJkYXJrTXV0ZWRcIiwgdHlwZTogXCJzYW5pdHkuaW1hZ2VQYWxldHRlU3dhdGNoXCIsIHRpdGxlOiBcIkRhcmsgTXV0ZWRcIiB9LFxuICAgIHsgbmFtZTogXCJsaWdodFZpYnJhbnRcIiwgdHlwZTogXCJzYW5pdHkuaW1hZ2VQYWxldHRlU3dhdGNoXCIsIHRpdGxlOiBcIkxpZ2h0IFZpYnJhbnRcIiB9LFxuICAgIHsgbmFtZTogXCJkYXJrVmlicmFudFwiLCB0eXBlOiBcInNhbml0eS5pbWFnZVBhbGV0dGVTd2F0Y2hcIiwgdGl0bGU6IFwiRGFyayBWaWJyYW50XCIgfSxcbiAgICB7IG5hbWU6IFwidmlicmFudFwiLCB0eXBlOiBcInNhbml0eS5pbWFnZVBhbGV0dGVTd2F0Y2hcIiwgdGl0bGU6IFwiVmlicmFudFwiIH0sXG4gICAgeyBuYW1lOiBcImRvbWluYW50XCIsIHR5cGU6IFwic2FuaXR5LmltYWdlUGFsZXR0ZVN3YXRjaFwiLCB0aXRsZTogXCJEb21pbmFudFwiIH0sXG4gICAgeyBuYW1lOiBcImxpZ2h0TXV0ZWRcIiwgdHlwZTogXCJzYW5pdHkuaW1hZ2VQYWxldHRlU3dhdGNoXCIsIHRpdGxlOiBcIkxpZ2h0IE11dGVkXCIgfSxcbiAgICB7IG5hbWU6IFwibXV0ZWRcIiwgdHlwZTogXCJzYW5pdHkuaW1hZ2VQYWxldHRlU3dhdGNoXCIsIHRpdGxlOiBcIk11dGVkXCIgfVxuICBdXG59LCBpbWFnZVBhbGV0dGVTd2F0Y2ggPSB7XG4gIG5hbWU6IFwic2FuaXR5LmltYWdlUGFsZXR0ZVN3YXRjaFwiLFxuICB0aXRsZTogXCJJbWFnZSBwYWxldHRlIHN3YXRjaFwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBmaWVsZHM6IFtcbiAgICB7IG5hbWU6IFwiYmFja2dyb3VuZFwiLCB0eXBlOiBcInN0cmluZ1wiLCB0aXRsZTogXCJCYWNrZ3JvdW5kXCIsIHJlYWRPbmx5OiAhMCB9LFxuICAgIHsgbmFtZTogXCJmb3JlZ3JvdW5kXCIsIHR5cGU6IFwic3RyaW5nXCIsIHRpdGxlOiBcIkZvcmVncm91bmRcIiwgcmVhZE9ubHk6ICEwIH0sXG4gICAgeyBuYW1lOiBcInBvcHVsYXRpb25cIiwgdHlwZTogXCJudW1iZXJcIiwgdGl0bGU6IFwiUG9wdWxhdGlvblwiLCByZWFkT25seTogITAgfSxcbiAgICB7IG5hbWU6IFwidGl0bGVcIiwgdHlwZTogXCJzdHJpbmdcIiwgdGl0bGU6IFwiU3RyaW5nXCIsIHJlYWRPbmx5OiAhMCB9XG4gIF1cbn0sIHNsdWckMSA9IHtcbiAgdGl0bGU6IFwiU2x1Z1wiLFxuICBuYW1lOiBcInNsdWdcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgZmllbGRzOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJjdXJyZW50XCIsXG4gICAgICB0aXRsZTogXCJDdXJyZW50IHNsdWdcIixcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICB2YWxpZGF0aW9uOiAoUnVsZSkgPT4gUnVsZS5yZXF1aXJlZCgpXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBUaGUgc291cmNlIGZpZWxkIGlzIGRlcHJlY2F0ZWQvdW51c2VkLCBidXQgbGVhdmluZyBpdCBpbmNsdWRlZCBhbmQgaGlkZGVuXG4gICAgICAvLyB0byBwcmV2ZW50IHJlbmRlcmluZyBcIlVua25vd24gZmllbGRcIiB3YXJuaW5ncyBvbiBsZWdhY3kgZGF0YVxuICAgICAgbmFtZTogXCJzb3VyY2VcIixcbiAgICAgIHRpdGxlOiBcIlNvdXJjZSBmaWVsZFwiLFxuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGhpZGRlbjogITBcbiAgICB9XG4gIF1cbn07XG5jb25zdCBidWlsdGluVHlwZXMgPSBbXG4gIGFzc2V0U291cmNlRGF0YSxcbiAgc2x1ZyQxLFxuICBnZW9wb2ludCxcbiAgLy8gbGVnYWN5UmljaERhdGUsXG4gIGltYWdlQXNzZXQsXG4gIGZpbGVBc3NldCxcbiAgaW1hZ2VDcm9wLFxuICBpbWFnZUhvdHNwb3QsXG4gIGltYWdlTWV0YWRhdGEsXG4gIGltYWdlRGltZW5zaW9ucyxcbiAgaW1hZ2VQYWxldHRlLFxuICBpbWFnZVBhbGV0dGVTd2F0Y2hcbl0sIGRvY3VtZW50RGVmYXVsdEZpZWxkcyA9ICh0eXBlTmFtZSkgPT4gKHtcbiAgX2lkOiB7XG4gICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgfSxcbiAgX3R5cGU6IHtcbiAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiB0eXBlTmFtZSB9XG4gIH0sXG4gIF9jcmVhdGVkQXQ6IHtcbiAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiB7IHR5cGU6IFwic3RyaW5nXCIgfVxuICB9LFxuICBfdXBkYXRlZEF0OiB7XG4gICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgfSxcbiAgX3Jldjoge1xuICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gIH1cbn0pLCB0eXBlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1widGV4dFwiLCB7IHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gIFtcInVybFwiLCB7IHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gIFtcImRhdGV0aW1lXCIsIHsgdHlwZTogXCJzdHJpbmdcIiB9XSxcbiAgW1wiZGF0ZVwiLCB7IHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gIFtcImJvb2xlYW5cIiwgeyB0eXBlOiBcImJvb2xlYW5cIiB9XSxcbiAgW1wiZW1haWxcIiwgeyB0eXBlOiBcInN0cmluZ1wiIH1dXG5dKTtcbmZ1bmN0aW9uIGV4dHJhY3RTY2hlbWEoc2NoZW1hRGVmLCBleHRyYWN0T3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGlubGluZUZpZWxkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIGRvY3VtZW50VHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBzY2hlbWEgPSBbXTtcbiAgc29ydEJ5RGVwZW5kZW5jaWVzKHNjaGVtYURlZikuZm9yRWFjaCgodHlwZU5hbWUpID0+IHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hRGVmLmdldCh0eXBlTmFtZSk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBiYXNlID0gY29udmVydEJhc2VUeXBlKHNjaGVtYVR5cGUpO1xuICAgIGJhc2UgIT09IG51bGwgJiYgKGJhc2UudHlwZSA9PT0gXCJ0eXBlXCIgJiYgaW5saW5lRmllbGRzLmFkZChzY2hlbWFUeXBlKSwgYmFzZS50eXBlID09PSBcImRvY3VtZW50XCIgJiYgZG9jdW1lbnRUeXBlcy5zZXQodHlwZU5hbWUsIGJhc2UpLCBzY2hlbWEucHVzaChiYXNlKSk7XG4gIH0pO1xuICBmdW5jdGlvbiBjb252ZXJ0QmFzZVR5cGUoc2NoZW1hVHlwZSkge1xuICAgIGxldCB0eXBlTmFtZTtcbiAgICBpZiAoc2NoZW1hVHlwZS50eXBlID8gdHlwZU5hbWUgPSBzY2hlbWFUeXBlLnR5cGUubmFtZSA6IFwianNvblR5cGVcIiBpbiBzY2hlbWFUeXBlICYmICh0eXBlTmFtZSA9IHNjaGVtYVR5cGUuanNvblR5cGUpLCB0eXBlTmFtZSA9PT0gXCJkb2N1bWVudFwiICYmIGlzT2JqZWN0VHlwZShzY2hlbWFUeXBlKSkge1xuICAgICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSBkb2N1bWVudERlZmF1bHRGaWVsZHMoc2NoZW1hVHlwZS5uYW1lKSwgb2JqZWN0MiA9IGNyZWF0ZU9iamVjdChzY2hlbWFUeXBlKTtcbiAgICAgIHJldHVybiBvYmplY3QyLnR5cGUgPT09IFwidW5rbm93blwiID8gbnVsbCA6IHtcbiAgICAgICAgbmFtZTogc2NoZW1hVHlwZS5uYW1lLFxuICAgICAgICB0eXBlOiBcImRvY3VtZW50XCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgICAgICAuLi5vYmplY3QyLmF0dHJpYnV0ZXNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjb252ZXJ0U2NoZW1hVHlwZShzY2hlbWFUeXBlKTtcbiAgICByZXR1cm4gdmFsdWUudHlwZSA9PT0gXCJ1bmtub3duXCIgPyBudWxsIDogdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiA/IHtcbiAgICAgIG5hbWU6IHNjaGVtYVR5cGUubmFtZSxcbiAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIF90eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHNjaGVtYVR5cGUubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4udmFsdWUuYXR0cmlidXRlc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIG5hbWU6IHNjaGVtYVR5cGUubmFtZSxcbiAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNvbnZlcnRTY2hlbWFUeXBlKHNjaGVtYVR5cGUpIHtcbiAgICBpZiAoaW5saW5lRmllbGRzLmhhcyhzY2hlbWFUeXBlLnR5cGUpKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmxpbmVcIiwgbmFtZTogc2NoZW1hVHlwZS50eXBlLm5hbWUgfTtcbiAgICBpZiAoc2NoZW1hVHlwZS50eXBlPy50eXBlPy5uYW1lID09PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmxpbmVcIiwgbmFtZTogc2NoZW1hVHlwZS50eXBlLm5hbWUgfTtcbiAgICBpZiAoaXNTdHJpbmdUeXBlKHNjaGVtYVR5cGUpKVxuICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ1R5cGVOb2RlRGVmaW50aW9uKHNjaGVtYVR5cGUpO1xuICAgIGlmIChpc051bWJlclR5cGUoc2NoZW1hVHlwZSkpXG4gICAgICByZXR1cm4gY3JlYXRlTnVtYmVyVHlwZU5vZGVEZWZpbnRpb24oc2NoZW1hVHlwZSk7XG4gICAgaWYgKHNjaGVtYVR5cGUudHlwZSAmJiB0eXBlc01hcC5oYXMoc2NoZW1hVHlwZS50eXBlLm5hbWUpKVxuICAgICAgcmV0dXJuIHR5cGVzTWFwLmdldChzY2hlbWFUeXBlLnR5cGUubmFtZSk7XG4gICAgaWYgKGlzQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVHlwZShzY2hlbWFUeXBlKSlcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidW5rbm93blwiIH07XG4gICAgaWYgKGlzR2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VUeXBlKHNjaGVtYVR5cGUpKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ1bmtub3duXCIgfTtcbiAgICBpZiAoaXNSZWZlcmVuY2VUeXBlKHNjaGVtYVR5cGUpKVxuICAgICAgcmV0dXJuIGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlRGVmaW50aW9uKHNjaGVtYVR5cGUpO1xuICAgIGlmIChpc0FycmF5VHlwZShzY2hlbWFUeXBlKSlcbiAgICAgIHJldHVybiBjcmVhdGVBcnJheShzY2hlbWFUeXBlKTtcbiAgICBpZiAoaXNPYmplY3RUeXBlKHNjaGVtYVR5cGUpKVxuICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdChzY2hlbWFUeXBlKTtcbiAgICBpZiAobGFzdFR5cGUoc2NoZW1hVHlwZSk/Lm5hbWUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgY29uc3QgZG9jID0gZG9jdW1lbnRUeXBlcy5nZXQoc2NoZW1hVHlwZS5uYW1lKTtcbiAgICAgIHJldHVybiBkb2MgPT09IHZvaWQgMCA/IHsgdHlwZTogXCJ1bmtub3duXCIgfSA6IHsgdHlwZTogXCJvYmplY3RcIiwgYXR0cmlidXRlczogZG9jPy5hdHRyaWJ1dGVzIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSBcIiR7c2NoZW1hVHlwZS5uYW1lfVwiIG5vdCBmb3VuZGApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChzY2hlbWFUeXBlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9LCBmaWVsZHMgPSBnYXRoZXJGaWVsZHMoc2NoZW1hVHlwZSk7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkSXNSZXF1aXJlZCA9IGlzRmllbGRSZXF1aXJlZChmaWVsZCksIHZhbHVlID0gY29udmVydFNjaGVtYVR5cGUoZmllbGQudHlwZSk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaGFzQXNzZXRSZXF1aXJlZChmaWVsZCkgJiYgdmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiAodmFsdWUuYXR0cmlidXRlcy5hc3NldC5vcHRpb25hbCA9ICExKTtcbiAgICAgIGNvbnN0IG9wdGlvbmFsID0gZXh0cmFjdE9wdGlvbnMuZW5mb3JjZVJlcXVpcmVkRmllbGRzID8gZmllbGRJc1JlcXVpcmVkID09PSAhMSA6ICEwO1xuICAgICAgYXR0cmlidXRlc1tmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RBdHRyaWJ1dGVcIixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9wdGlvbmFsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoID09PSAwID8geyB0eXBlOiBcInVua25vd25cIiB9IDogKHNjaGVtYVR5cGUudHlwZT8ubmFtZSAhPT0gXCJkb2N1bWVudFwiICYmIHNjaGVtYVR5cGUubmFtZSAhPT0gXCJvYmplY3RcIiAmJiAoYXR0cmlidXRlcy5fdHlwZSA9IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0QXR0cmlidXRlXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hVHlwZS5uYW1lXG4gICAgICB9XG4gICAgfSksIHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXkoYXJyYXlTY2hlbWFUeXBlKSB7XG4gICAgY29uc3Qgb2YgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXlTY2hlbWFUeXBlLm9mKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IGNvbnZlcnRTY2hlbWFUeXBlKGl0ZW0pO1xuICAgICAgZmllbGQudHlwZSA9PT0gXCJpbmxpbmVcIiA/IG9mLnB1c2goe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgX2tleTogY3JlYXRlS2V5RmllbGQoKVxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBmaWVsZFxuICAgICAgfSkgOiAoZmllbGQudHlwZSA9PT0gXCJvYmplY3RcIiAmJiAoZmllbGQucmVzdCA9IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIF9rZXk6IGNyZWF0ZUtleUZpZWxkKClcbiAgICAgICAgfVxuICAgICAgfSksIG9mLnB1c2goZmllbGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mLmxlbmd0aCA9PT0gMCA/IHsgdHlwZTogXCJudWxsXCIgfSA6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG9mOiBvZi5sZW5ndGggPiAxID8ge1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9mXG4gICAgICB9IDogb2ZbMF1cbiAgICB9O1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlGaWVsZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIm9iamVjdEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNGaWVsZFJlcXVpcmVkKGZpZWxkKSB7XG4gIGNvbnN0IHsgdmFsaWRhdGlvbiB9ID0gZmllbGQudHlwZTtcbiAgaWYgKCF2YWxpZGF0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgcnVsZXMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRpb24pID8gdmFsaWRhdGlvbiA6IFt2YWxpZGF0aW9uXTtcbiAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgbGV0IHJlcXVpcmVkID0gITE7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoXG4gICAgICB7fSxcbiAgICAgIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBtZXRob2ROYW1lKSA9PiAoKSA9PiAobWV0aG9kTmFtZSA9PT0gXCJyZXF1aXJlZFwiICYmIChyZXF1aXJlZCA9ICEwKSwgcHJveHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJmdW5jdGlvblwiICYmIChydWxlKHByb3h5KSwgcmVxdWlyZWQpIHx8IHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgcnVsZSAhPT0gbnVsbCAmJiBcIl9yZXF1aXJlZFwiIGluIHJ1bGUgJiYgcnVsZS5fcmVxdWlyZWQgPT09IFwicmVxdWlyZWRcIilcbiAgICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBoYXNBc3NldFJlcXVpcmVkKGZpZWxkKSB7XG4gIGNvbnN0IHsgdmFsaWRhdGlvbiB9ID0gZmllbGQudHlwZTtcbiAgaWYgKCF2YWxpZGF0aW9uKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgcnVsZXMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRpb24pID8gdmFsaWRhdGlvbiA6IFt2YWxpZGF0aW9uXTtcbiAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgbGV0IGFzc2V0UmVxdWlyZWQgPSAhMTtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShcbiAgICAgIHt9LFxuICAgICAge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIG1ldGhvZE5hbWUpID0+ICgpID0+IChtZXRob2ROYW1lID09PSBcImFzc2V0UmVxdWlyZWRcIiAmJiAoYXNzZXRSZXF1aXJlZCA9ICEwKSwgcHJveHkpXG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJmdW5jdGlvblwiICYmIChydWxlKHByb3h5KSwgYXNzZXRSZXF1aXJlZCkgfHwgdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiBydWxlICE9PSBudWxsICYmIFwiX3J1bGVzXCIgaW4gcnVsZSAmJiBBcnJheS5pc0FycmF5KHJ1bGUuX3J1bGVzKSAmJiBydWxlLl9ydWxlcy5zb21lKChyKSA9PiByLmZsYWcgPT09IFwiYXNzZXRSZXF1aXJlZFwiKSlcbiAgICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBpc09iamVjdFR5cGUodHlwZURlZikge1xuICByZXR1cm4gaXNUeXBlKHR5cGVEZWYsIFwib2JqZWN0XCIpIHx8IHR5cGVEZWYuanNvblR5cGUgPT09IFwib2JqZWN0XCIgfHwgXCJmaWVsZHNcIiBpbiB0eXBlRGVmO1xufVxuZnVuY3Rpb24gaXNBcnJheVR5cGUodHlwZURlZikge1xuICByZXR1cm4gaXNUeXBlKHR5cGVEZWYsIFwiYXJyYXlcIik7XG59XG5mdW5jdGlvbiBpc1JlZmVyZW5jZVR5cGUodHlwZURlZikge1xuICByZXR1cm4gaXNUeXBlKHR5cGVEZWYsIFwicmVmZXJlbmNlXCIpO1xufVxuZnVuY3Rpb24gaXNDcm9zc0RhdGFzZXRSZWZlcmVuY2VUeXBlKHR5cGVEZWYpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlRGVmLCBcImNyb3NzRGF0YXNldFJlZmVyZW5jZVwiKTtcbn1cbmZ1bmN0aW9uIGlzR2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VUeXBlKHR5cGVEZWYpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlRGVmLCBcImdsb2JhbERvY3VtZW50UmVmZXJlbmNlXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdUeXBlKHR5cGVEZWYpIHtcbiAgcmV0dXJuIGlzVHlwZSh0eXBlRGVmLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyVHlwZSh0eXBlRGVmKSB7XG4gIHJldHVybiBpc1R5cGUodHlwZURlZiwgXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdUeXBlTm9kZURlZmludGlvbihzdHJpbmdTY2hlbWFUeXBlKSB7XG4gIGNvbnN0IGxpc3RPcHRpb25zID0gc3RyaW5nU2NoZW1hVHlwZS5vcHRpb25zPy5saXN0O1xuICByZXR1cm4gbGlzdE9wdGlvbnMgJiYgQXJyYXkuaXNBcnJheShsaXN0T3B0aW9ucykgPyB7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9mOiBsaXN0T3B0aW9ucy5tYXAoKHYpID0+ICh7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgdmFsdWU6IHR5cGVvZiB2ID09IFwic3RyaW5nXCIgPyB2IDogdi52YWx1ZVxuICAgIH0pKVxuICB9IDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlclR5cGVOb2RlRGVmaW50aW9uKG51bWJlclNjaGVtYVR5cGUpIHtcbiAgY29uc3QgbGlzdE9wdGlvbnMgPSBudW1iZXJTY2hlbWFUeXBlLm9wdGlvbnM/Lmxpc3Q7XG4gIHJldHVybiBsaXN0T3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KGxpc3RPcHRpb25zKSA/IHtcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgb2Y6IGxpc3RPcHRpb25zLm1hcCgodikgPT4gKHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICB2YWx1ZTogdHlwZW9mIHYgPT0gXCJudW1iZXJcIiA/IHYgOiB2LnZhbHVlXG4gICAgfSkpXG4gIH0gOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlVHlwZU5vZGVEZWZpbnRpb24ocmVmZXJlbmNlMikge1xuICBjb25zdCByZWZlcmVuY2VzID0gZ2F0aGVyUmVmZXJlbmNlTmFtZXMocmVmZXJlbmNlMik7XG4gIHJldHVybiByZWZlcmVuY2VzLmxlbmd0aCA9PT0gMSA/IGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlKHJlZmVyZW5jZXNbMF0pIDoge1xuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICBvZjogcmVmZXJlbmNlcy5tYXAoKG5hbWUpID0+IGNyZWF0ZVJlZmVyZW5jZVR5cGVOb2RlKG5hbWUpKVxuICB9O1xufVxuZnVuY3Rpb24gZ2F0aGVyUmVmZXJlbmNlTmFtZXModHlwZSkge1xuICBjb25zdCBhbGxSZWZlcmVuY2VzID0gZ2F0aGVyUmVmZXJlbmNlVHlwZXModHlwZSk7XG4gIHJldHVybiBbLi4ubmV3IFNldChhbGxSZWZlcmVuY2VzLm1hcCgocmVmKSA9PiByZWYubmFtZSkpXTtcbn1cbmZ1bmN0aW9uIGdhdGhlclJlZmVyZW5jZVR5cGVzKHR5cGUpIHtcbiAgY29uc3QgcmVmVG8gPSBcInRvXCIgaW4gdHlwZSA/IHR5cGUudG8gOiBbXTtcbiAgcmV0dXJuIFwidHlwZVwiIGluIHR5cGUgJiYgaXNSZWZlcmVuY2VUeXBlKHR5cGUudHlwZSkgPyBbLi4uZ2F0aGVyUmVmZXJlbmNlVHlwZXModHlwZS50eXBlKSwgLi4ucmVmVG9dIDogcmVmVG87XG59XG5mdW5jdGlvbiBnYXRoZXJGaWVsZHModHlwZSkge1xuICByZXR1cm4gXCJmaWVsZHNcIiBpbiB0eXBlID8gdHlwZS50eXBlID8gZ2F0aGVyRmllbGRzKHR5cGUudHlwZSkuY29uY2F0KHR5cGUuZmllbGRzKSA6IHR5cGUuZmllbGRzIDogW107XG59XG5mdW5jdGlvbiBpc1R5cGUodHlwZURlZiwgdHlwZU5hbWUpIHtcbiAgbGV0IHR5cGUgPSB0eXBlRGVmO1xuICBmb3IgKDsgdHlwZTsgKSB7XG4gICAgaWYgKHR5cGUubmFtZSA9PT0gdHlwZU5hbWUgfHwgdHlwZS50eXBlICYmIHR5cGUudHlwZS5uYW1lID09PSB0eXBlTmFtZSlcbiAgICAgIHJldHVybiAhMDtcbiAgICB0eXBlID0gdHlwZS50eXBlO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGxhc3RUeXBlKHR5cGVEZWYpIHtcbiAgbGV0IHR5cGUgPSB0eXBlRGVmO1xuICBmb3IgKDsgdHlwZTsgKSB7XG4gICAgaWYgKCF0eXBlLnR5cGUpXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB0eXBlID0gdHlwZS50eXBlO1xuICB9XG59XG5mdW5jdGlvbiBzb3J0QnlEZXBlbmRlbmNpZXMoY29tcGlsZWRTY2hlbWEpIHtcbiAgY29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZ1bmN0aW9uIHdhbGtEZXBlbmRlbmNpZXMoc2NoZW1hVHlwZSwgZGVwZW5kZW5jaWVzKSB7XG4gICAgaWYgKCFzZWVuLmhhcyhzY2hlbWFUeXBlKSkge1xuICAgICAgaWYgKHNlZW4uYWRkKHNjaGVtYVR5cGUpLCBcImZpZWxkc1wiIGluIHNjaGVtYVR5cGUpXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZ2F0aGVyRmllbGRzKHNjaGVtYVR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IGxhc3RUeXBlKGZpZWxkLnR5cGUpO1xuICAgICAgICAgIGlmIChsYXN0Lm5hbWUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmFkZChsYXN0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgc2NoZW1hVHlwZU5hbWU7XG4gICAgICAgICAgc2NoZW1hVHlwZS50eXBlLnR5cGUgPyBzY2hlbWFUeXBlTmFtZSA9IGZpZWxkLnR5cGUudHlwZS5uYW1lIDogXCJqc29uVHlwZVwiIGluIHNjaGVtYVR5cGUudHlwZSAmJiAoc2NoZW1hVHlwZU5hbWUgPSBmaWVsZC50eXBlLmpzb25UeXBlKSwgKHNjaGVtYVR5cGVOYW1lID09PSBcIm9iamVjdFwiIHx8IHNjaGVtYVR5cGVOYW1lID09PSBcImJsb2NrXCIpICYmIChpc1JlZmVyZW5jZVR5cGUoZmllbGQudHlwZSkgPyBmaWVsZC50eXBlLnRvLmZvckVhY2goKHJlZikgPT4gZGVwZW5kZW5jaWVzLmFkZChyZWYudHlwZSkpIDogZGVwZW5kZW5jaWVzLmFkZChmaWVsZC50eXBlKSksIHdhbGtEZXBlbmRlbmNpZXMoZmllbGQudHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoXCJvZlwiIGluIHNjaGVtYVR5cGUpXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzY2hlbWFUeXBlLm9mKVxuICAgICAgICAgIHdhbGtEZXBlbmRlbmNpZXMoaXRlbSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVwZW5kZW5jeU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbXBpbGVkU2NoZW1hLmdldFR5cGVOYW1lcygpLmZvckVhY2goKHR5cGVOYW1lKSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGNvbXBpbGVkU2NoZW1hLmdldCh0eXBlTmFtZSk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09IHZvaWQgMCB8fCBzY2hlbWFUeXBlLnR5cGUgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB3YWxrRGVwZW5kZW5jaWVzKHNjaGVtYVR5cGUsIGRlcGVuZGVuY2llcyksIGRlcGVuZGVuY3lNYXAuc2V0KHNjaGVtYVR5cGUsIGRlcGVuZGVuY2llcyksIHNlZW4uY2xlYXIoKTtcbiAgfSk7XG4gIGNvbnN0IHR5cGVOYW1lcyA9IFtdLCBjdXJyZW50bHlWaXNpdGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiB2aXNpdCh0eXBlKSB7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHR5cGUpIHx8IGN1cnJlbnRseVZpc2l0aW5nLmhhcyh0eXBlKSlcbiAgICAgIHJldHVybjtcbiAgICBjdXJyZW50bHlWaXNpdGluZy5hZGQodHlwZSk7XG4gICAgY29uc3QgZGVwcyA9IGRlcGVuZGVuY3lNYXAuZ2V0KHR5cGUpO1xuICAgIGRlcHMgIT09IHZvaWQgMCAmJiBkZXBzLmZvckVhY2goKGRlcCkgPT4gdmlzaXQoZGVwKSksIGN1cnJlbnRseVZpc2l0aW5nLmRlbGV0ZSh0eXBlKSwgdmlzaXRlZC5hZGQodHlwZSksIHR5cGVOYW1lcy5pbmNsdWRlcyh0eXBlLm5hbWUpIHx8IHR5cGVOYW1lcy51bnNoaWZ0KHR5cGUubmFtZSk7XG4gIH1cbiAgZm9yIChjb25zdCBbdHlwZV0gb2YgZGVwZW5kZW5jeU1hcClcbiAgICB2aXNpdCh0eXBlKTtcbiAgcmV0dXJuIHR5cGVOYW1lcztcbn1cbmNvbnN0IEhFTFBfSURTID0ge1xuICBUWVBFX0lOVkFMSUQ6IFwic2NoZW1hLXR5cGUtaW52YWxpZFwiLFxuICBUWVBFX0lTX0VTTV9NT0RVTEU6IFwic2NoZW1hLXR5cGUtaXMtZXNtLW1vZHVsZVwiLFxuICBUWVBFX05BTUVfUkVTRVJWRUQ6IFwic2NoZW1hLXR5cGUtbmFtZS1yZXNlcnZlZFwiLFxuICBUWVBFX01JU1NJTkdfTkFNRTogXCJzY2hlbWEtdHlwZS1taXNzaW5nLW5hbWUtb3ItdHlwZVwiLFxuICBUWVBFX01JU1NJTkdfVFlQRTogXCJzY2hlbWEtdHlwZS1taXNzaW5nLW5hbWUtb3ItdHlwZVwiLFxuICBUWVBFX1RJVExFX1JFQ09NTUVOREVEOiBcInNjaGVtYS10eXBlLXRpdGxlLWlzLXJlY29tbWVuZGVkXCIsXG4gIFRZUEVfVElUTEVfSU5WQUxJRDogXCJzY2hlbWEtdHlwZS10aXRsZS1pcy1yZWNvbW1lbmRlZFwiLFxuICBPQkpFQ1RfRklFTERTX0lOVkFMSUQ6IFwic2NoZW1hLW9iamVjdC1maWVsZHMtaW52YWxpZFwiLFxuICBPQkpFQ1RfRklFTERfTk9UX1VOSVFVRTogXCJzY2hlbWEtb2JqZWN0LWZpZWxkcy1pbnZhbGlkXCIsXG4gIE9CSkVDVF9GSUVMRF9OQU1FX0lOVkFMSUQ6IFwic2NoZW1hLW9iamVjdC1maWVsZHMtaW52YWxpZFwiLFxuICBPQkpFQ1RfRklFTERfREVGSU5JVElPTl9JTlZBTElEX1RZUEU6IFwic2NoZW1hLW9iamVjdC1maWVsZHMtaW52YWxpZFwiLFxuICBBUlJBWV9QUkVERUZJTkVEX0NIT0lDRVNfSU5WQUxJRDogXCJzY2hlbWEtcHJlZGVmaW5lZC1jaG9pY2VzLWludmFsaWRcIixcbiAgQVJSQVlfT0ZfQVJSQVk6IFwic2NoZW1hLWFycmF5LW9mLWFycmF5XCIsXG4gIEFSUkFZX09GX0lOVkFMSUQ6IFwic2NoZW1hLWFycmF5LW9mLWludmFsaWRcIixcbiAgQVJSQVlfT0ZfTk9UX1VOSVFVRTogXCJzY2hlbWEtYXJyYXktb2YtaW52YWxpZFwiLFxuICBBUlJBWV9PRl9UWVBFX0dMT0JBTF9UWVBFX0NPTkZMSUNUOiBcInNjaGVtYS1hcnJheS1vZi10eXBlLWdsb2JhbC10eXBlLWNvbmZsaWN0XCIsXG4gIEFSUkFZX09GX1RZUEVfQlVJTFRJTl9UWVBFX0NPTkZMSUNUOiBcInNjaGVtYS1hcnJheS1vZi10eXBlLWJ1aWx0aW4tdHlwZS1jb25mbGljdFwiLFxuICBSRUZFUkVOQ0VfVE9fSU5WQUxJRDogXCJzY2hlbWEtcmVmZXJlbmNlLXRvLWludmFsaWRcIixcbiAgUkVGRVJFTkNFX1RPX05PVF9VTklRVUU6IFwic2NoZW1hLXJlZmVyZW5jZS10by1pbnZhbGlkXCIsXG4gIFJFRkVSRU5DRV9JTlZBTElEX09QVElPTlM6IFwic2NoZW1hLXJlZmVyZW5jZS1pbnZhbGlkLW9wdGlvbnNcIixcbiAgUkVGRVJFTkNFX0lOVkFMSURfT1BUSU9OU19MT0NBVElPTjogXCJzY2hlbWEtcmVmZXJlbmNlLW9wdGlvbnMtbmVzdGluZ1wiLFxuICBSRUZFUkVOQ0VfSU5WQUxJRF9GSUxURVJfUEFSQU1TX0NPTUJJTkFUSU9OOiBcInNjaGVtYS1yZWZlcmVuY2UtZmlsdGVyLXBhcmFtcy1jb21iaW5hdGlvblwiLFxuICBTTFVHX1NMVUdJRllfRk5fUkVOQU1FRDogXCJzbHVnLXNsdWdpZnlmbi1yZW5hbWVkXCIsXG4gIEFTU0VUX01FVEFEQVRBX0ZJRUxEX0lOVkFMSUQ6IFwiYXNzZXQtbWV0YWRhdGEtZmllbGQtaW52YWxpZFwiLFxuICBDUk9TU19EQVRBU0VUX1JFRkVSRU5DRV9JTlZBTElEOiBcImNyb3NzLWRhdGFzZXQtcmVmZXJlbmNlLWludmFsaWRcIixcbiAgR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9JTlZBTElEOiBcImdsb2JhbC1kb2N1bWVudC1yZWZlcmVuY2UtaW52YWxpZFwiLFxuICBERVBSRUNBVEVEX0JMT0NLRURJVE9SX0tFWTogXCJzY2hlbWEtZGVwcmVjYXRlZC1ibG9ja2VkaXRvci1rZXlcIixcbiAgU1RBTkRBTE9ORV9CTE9DS19UWVBFOiBcInNjaGVtYS1zdGFuZGFsb25lLWJsb2NrLXR5cGVcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25SZXN1bHQoc2V2ZXJpdHksIG1lc3NhZ2UsIGhlbHBJZCkge1xuICBpZiAoaGVscElkICYmICFPYmplY3Qua2V5cyhIRUxQX0lEUykuc29tZSgoaWQpID0+IEhFTFBfSURTW2lkXSA9PT0gaGVscElkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVXNlZCB0aGUgdW5rbm93biBoZWxwSWQgXCIke2hlbHBJZH1cIiwgcGxlYXNlIGFkZCBpdCB0byB0aGUgYXJyYXkgaW4gY3JlYXRlVmFsaWRhdGlvblJlc3VsdC5qc2BcbiAgICApO1xuICByZXR1cm4ge1xuICAgIHNldmVyaXR5LFxuICAgIG1lc3NhZ2UsXG4gICAgaGVscElkXG4gIH07XG59XG5jb25zdCBlcnJvciA9IChtZXNzYWdlLCBoZWxwSWQpID0+IGNyZWF0ZVZhbGlkYXRpb25SZXN1bHQoXCJlcnJvclwiLCBtZXNzYWdlLCBoZWxwSWQpLCB3YXJuaW5nID0gKG1lc3NhZ2UsIGhlbHBJZCkgPT4gY3JlYXRlVmFsaWRhdGlvblJlc3VsdChcIndhcm5pbmdcIiwgbWVzc2FnZSwgaGVscElkKTtcbmZ1bmN0aW9uIGdyb3VwUHJvYmxlbXModHlwZXMpIHtcbiAgcmV0dXJuIGZsYXR0ZW4odHlwZXMubWFwKCh0eXBlKSA9PiBnZXRUeXBlUHJvYmxlbXModHlwZSkpKS5maWx0ZXIoXG4gICAgKHR5cGUpID0+IHR5cGUucHJvYmxlbXMubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVdpdGhNZW1iZXJzUHJvYmxlbXNBY2Nlc3NvcihtZW1iZXJQcm9wZXJ0eU5hbWUsIGdldE1lbWJlcnMgPSAodHlwZSkgPT4gZ2V0KHR5cGUsIG1lbWJlclByb3BlcnR5TmFtZSkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIHBhcmVudFBhdGgpIHtcbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IFtcbiAgICAgIC4uLnBhcmVudFBhdGgsXG4gICAgICB7IGtpbmQ6IFwidHlwZVwiLCB0eXBlOiB0eXBlLnR5cGUsIG5hbWU6IHR5cGUubmFtZSB9XG4gICAgXSwgbWVtYmVycyA9IGdldE1lbWJlcnModHlwZSkgfHwgW10sIG1lbWJlclByb2JsZW1zID0gQXJyYXkuaXNBcnJheShtZW1iZXJzKSA/IG1lbWJlcnMubWFwKChtZW1iZXJUeXBlKSA9PiB7XG4gICAgICBjb25zdCBwcm9wZXJ0eVNlZ21lbnQgPSB7XG4gICAgICAgIGtpbmQ6IFwicHJvcGVydHlcIixcbiAgICAgICAgbmFtZTogbWVtYmVyUHJvcGVydHlOYW1lXG4gICAgICB9LCBtZW1iZXJQYXRoID0gWy4uLmN1cnJlbnRQYXRoLCBwcm9wZXJ0eVNlZ21lbnRdO1xuICAgICAgcmV0dXJuIGdldFR5cGVQcm9ibGVtcyhtZW1iZXJUeXBlLCBtZW1iZXJQYXRoKTtcbiAgICB9KSA6IFtcbiAgICAgIFtcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IGN1cnJlbnRQYXRoLFxuICAgICAgICAgIHByb2JsZW1zOiBbZXJyb3IoYE1lbWJlciBkZWNsYXJhdGlvbiAoJHttZW1iZXJQcm9wZXJ0eU5hbWV9KSBpcyBub3QgYW4gYXJyYXlgKV1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgcGF0aDogY3VycmVudFBhdGgsXG4gICAgICAgIHByb2JsZW1zOiB0eXBlLl9wcm9ibGVtcyB8fCBbXVxuICAgICAgfSxcbiAgICAgIC4uLmZsYXR0ZW4obWVtYmVyUHJvYmxlbXMpXG4gICAgXTtcbiAgfTtcbn1cbmNvbnN0IGFycmlmeSA9ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbCA6IHR5cGVvZiB2YWwgPiBcInVcIiAmJiBbXSB8fCBbdmFsXSwgZ2V0T2JqZWN0UHJvYmxlbXMgPSBjcmVhdGVUeXBlV2l0aE1lbWJlcnNQcm9ibGVtc0FjY2Vzc29yKFwiZmllbGRzXCIpLCBnZXRJbWFnZVByb2JsZW1zID0gY3JlYXRlVHlwZVdpdGhNZW1iZXJzUHJvYmxlbXNBY2Nlc3NvcihcImZpZWxkc1wiKSwgZ2V0RmlsZVByb2JsZW1zID0gY3JlYXRlVHlwZVdpdGhNZW1iZXJzUHJvYmxlbXNBY2Nlc3NvcihcImZpZWxkc1wiKSwgZ2V0QXJyYXlQcm9ibGVtcyA9IGNyZWF0ZVR5cGVXaXRoTWVtYmVyc1Byb2JsZW1zQWNjZXNzb3IoXCJvZlwiKSwgZ2V0UmVmZXJlbmNlUHJvYmxlbXMgPSBjcmVhdGVUeXBlV2l0aE1lbWJlcnNQcm9ibGVtc0FjY2Vzc29yKFxuICBcInRvXCIsXG4gICh0eXBlKSA9PiBcInRvXCIgaW4gdHlwZSA/IGFycmlmeSh0eXBlLnRvKSA6IFtdXG4pLCBnZXRCbG9ja0Fubm90YXRpb25Qcm9ibGVtcyA9IGNyZWF0ZVR5cGVXaXRoTWVtYmVyc1Byb2JsZW1zQWNjZXNzb3IoXCJtYXJrcy5hbm5vdGF0aW9uc1wiKSwgZ2V0QmxvY2tNZW1iZXJQcm9ibGVtcyA9IGNyZWF0ZVR5cGVXaXRoTWVtYmVyc1Byb2JsZW1zQWNjZXNzb3IoXCJvZlwiKSwgZ2V0QmxvY2tQcm9ibGVtcyA9ICh0eXBlLCBwcm9ibGVtcykgPT4gW1xuICAuLi5nZXRCbG9ja0Fubm90YXRpb25Qcm9ibGVtcyh0eXBlLCBwcm9ibGVtcyksXG4gIC4uLmdldEJsb2NrTWVtYmVyUHJvYmxlbXModHlwZSwgcHJvYmxlbXMpXG5dO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb2JsZW1zKHR5cGUsIHBhdGggPSBbXSkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHBhdGg6IFsuLi5wYXRoLCB7IGtpbmQ6IFwidHlwZVwiLCB0eXBlOiB0eXBlLnR5cGUsIG5hbWU6IHR5cGUubmFtZSB9XSxcbiAgICAgIHByb2JsZW1zOiB0eXBlLl9wcm9ibGVtcyB8fCBbXVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVQcm9ibGVtcyh0eXBlLCBwYXRoID0gW10pIHtcbiAgc3dpdGNoICh0eXBlLnR5cGUpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gZ2V0T2JqZWN0UHJvYmxlbXModHlwZSwgcGF0aCk7XG4gICAgY2FzZSBcImRvY3VtZW50XCI6XG4gICAgICByZXR1cm4gZ2V0T2JqZWN0UHJvYmxlbXModHlwZSwgcGF0aCk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gZ2V0QXJyYXlQcm9ibGVtcyh0eXBlLCBwYXRoKTtcbiAgICBjYXNlIFwicmVmZXJlbmNlXCI6XG4gICAgICByZXR1cm4gZ2V0UmVmZXJlbmNlUHJvYmxlbXModHlwZSwgcGF0aCk7XG4gICAgY2FzZSBcImJsb2NrXCI6XG4gICAgICByZXR1cm4gZ2V0QmxvY2tQcm9ibGVtcyh0eXBlLCBwYXRoKTtcbiAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIHJldHVybiBnZXRJbWFnZVByb2JsZW1zKHR5cGUsIHBhdGgpO1xuICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICByZXR1cm4gZ2V0RmlsZVByb2JsZW1zKHR5cGUsIHBhdGgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0RGVmYXVsdFByb2JsZW1zKHR5cGUsIHBhdGgpO1xuICB9XG59XG5mdW5jdGlvbiBnZXREdXBlcyhhcnJheTIsIHNlbGVjdG9yID0gKHYpID0+IHYpIHtcbiAgY29uc3QgZHVwZXMgPSBhcnJheTIucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RvcihpdGVtKTtcbiAgICByZXR1cm4gYWNjW2tleV0gfHwgKGFjY1trZXldID0gW10pLCBhY2Nba2V5XS5wdXNoKGl0ZW0pLCBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGR1cGVzKS5tYXAoKGtleSkgPT4gZHVwZXNba2V5XS5sZW5ndGggPiAxID8gZHVwZXNba2V5XSA6IG51bGwpLmZpbHRlcihCb29sZWFuKTtcbn1cbmNvbnN0IE5PT1BfVklTSVRPUiA9ICh0eXBlRGVmKSA9PiB0eXBlRGVmLCBUWVBFX1RZUEUgPSB7IG5hbWU6IFwidHlwZVwiLCB0eXBlOiBudWxsIH0sIEZVVFVSRV9SRVNFUlZFRCA9IFtcImFueVwiLCBcInRpbWVcIiwgXCJkYXRlXCJdO1xuZnVuY3Rpb24gdHJhdmVyc2VTY2hlbWEodHlwZXMgPSBbXSwgY29yZVR5cGVzMiA9IFtdLCB2aXNpdG9yID0gTk9PUF9WSVNJVE9SKSB7XG4gIGNvbnN0IGNvcmVUeXBlc1JlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIGNvcmVUeXBlTmFtZXMyID0gY29yZVR5cGVzMi5tYXAoKHR5cGVEZWYpID0+IHR5cGVEZWYubmFtZSksIHJlc2VydmVkVHlwZU5hbWVzID0gRlVUVVJFX1JFU0VSVkVELmNvbmNhdChjb3JlVHlwZU5hbWVzMiksIHR5cGVOYW1lcyA9IHR5cGVzLm1hcCgodHlwZURlZikgPT4gdHlwZURlZiAmJiB0eXBlRGVmLm5hbWUpLmZpbHRlcihCb29sZWFuKTtcbiAgY29yZVR5cGVzMi5mb3JFYWNoKChjb3JlVHlwZSkgPT4ge1xuICAgIGNvcmVUeXBlc1JlZ2lzdHJ5W2NvcmVUeXBlLm5hbWVdID0gY29yZVR5cGU7XG4gIH0pLCB0eXBlcy5mb3JFYWNoKCh0eXBlLCBpKSA9PiB7XG4gICAgcmVnaXN0cnlbdHlwZSAmJiB0eXBlLm5hbWUgfHwgYF9fdW5uYW1lZF8ke2l9YF0gPSB7fTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGdldFR5cGUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgPT09IFwidHlwZVwiID8gVFlQRV9UWVBFIDogY29yZVR5cGVzUmVnaXN0cnlbdHlwZU5hbWVdIHx8IHJlZ2lzdHJ5W3R5cGVOYW1lXSB8fCBudWxsO1xuICB9XG4gIGNvbnN0IGR1cGxpY2F0ZU5hbWVzID0gdW5pcShmbGF0dGVuKGdldER1cGVzKHR5cGVOYW1lcykpKTtcbiAgZnVuY3Rpb24gaXNEdXBsaWNhdGUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gZHVwbGljYXRlTmFtZXMuaW5jbHVkZXModHlwZU5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFR5cGVOYW1lcygpIHtcbiAgICByZXR1cm4gdHlwZU5hbWVzLmNvbmNhdChjb3JlVHlwZU5hbWVzMik7XG4gIH1cbiAgZnVuY3Rpb24gaXNSZXNlcnZlZCh0eXBlTmFtZSkge1xuICAgIHJldHVybiB0eXBlTmFtZSA9PT0gXCJ0eXBlXCIgfHwgcmVzZXJ2ZWRUeXBlTmFtZXMuaW5jbHVkZXModHlwZU5hbWUpO1xuICB9XG4gIGNvbnN0IHZpc2l0VHlwZSA9IChpc1Jvb3QpID0+ICh0eXBlRGVmLCBpbmRleCkgPT4gdmlzaXRvcih0eXBlRGVmLCB7XG4gICAgdmlzaXQ6IHZpc2l0VHlwZSghMSksXG4gICAgaXNSb290LFxuICAgIGdldFR5cGUsXG4gICAgZ2V0VHlwZU5hbWVzLFxuICAgIGlzUmVzZXJ2ZWQsXG4gICAgaXNEdXBsaWNhdGUsXG4gICAgaW5kZXhcbiAgfSk7XG4gIHJldHVybiBjb3JlVHlwZXMyLmZvckVhY2goKGNvcmVUeXBlRGVmKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihjb3JlVHlwZXNSZWdpc3RyeVtjb3JlVHlwZURlZi5uYW1lXSwgdmlzaXRUeXBlKGNvcmVUeXBlRGVmKSk7XG4gIH0pLCB0eXBlcy5mb3JFYWNoKCh0eXBlRGVmLCBpKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihcbiAgICAgIHJlZ2lzdHJ5W3R5cGVEZWYgJiYgdHlwZURlZi5uYW1lIHx8IGBfX3VubmFtZWRfJHtpfWBdLFxuICAgICAgdmlzaXRUeXBlKCEwKSh0eXBlRGVmLCBpKVxuICAgICk7XG4gIH0pLCB7XG4gICAgZ2V0KHR5cGVOYW1lKSB7XG4gICAgICBjb25zdCByZXMgPSByZWdpc3RyeVt0eXBlTmFtZV0gfHwgY29yZVR5cGVzUmVnaXN0cnlbdHlwZU5hbWVdO1xuICAgICAgaWYgKHJlcylcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCB0eXBlOiAke3R5cGVOYW1lfWApO1xuICAgIH0sXG4gICAgaGFzKHR5cGVOYW1lKSB7XG4gICAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0cnkgfHwgdHlwZU5hbWUgaW4gY29yZVR5cGVzUmVnaXN0cnk7XG4gICAgfSxcbiAgICBnZXRUeXBlTmFtZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkpO1xuICAgIH0sXG4gICAgZ2V0VHlwZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUeXBlTmFtZXMoKS5tYXAodGhpcy5nZXQpO1xuICAgIH0sXG4gICAgdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZXMoKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjb3JlVHlwZXMgPSBbXG4gIHsgbmFtZTogXCJhcnJheVwiLCBqc29uVHlwZTogXCJhcnJheVwiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwiYmxvY2tcIiwganNvblR5cGU6IFwib2JqZWN0XCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJib29sZWFuXCIsIGpzb25UeXBlOiBcImJvb2xlYW5cIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcImRhdGV0aW1lXCIsIGpzb25UeXBlOiBcInN0cmluZ1wiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwiZGF0ZVwiLCBqc29uVHlwZTogXCJzdHJpbmdcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcImRvY3VtZW50XCIsIGpzb25UeXBlOiBcIm9iamVjdFwiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwiZW1haWxcIiwganNvblR5cGU6IFwic3RyaW5nXCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJmaWxlXCIsIGpzb25UeXBlOiBcIm9iamVjdFwiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwiZ2VvcG9pbnRcIiwganNvblR5cGU6IFwib2JqZWN0XCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJpbWFnZVwiLCBqc29uVHlwZTogXCJvYmplY3RcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcIm51bWJlclwiLCBqc29uVHlwZTogXCJudW1iZXJcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcIm9iamVjdFwiLCBqc29uVHlwZTogXCJvYmplY3RcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcInJlZmVyZW5jZVwiLCBqc29uVHlwZTogXCJvYmplY3RcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcImNyb3NzRGF0YXNldFJlZmVyZW5jZVwiLCBqc29uVHlwZTogXCJvYmplY3RcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcImdsb2JhbERvY3VtZW50UmVmZXJlbmNlXCIsIGpzb25UeXBlOiBcIm9iamVjdFwiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwic2x1Z1wiLCBqc29uVHlwZTogXCJvYmplY3RcIiwgdHlwZTogXCJ0eXBlXCIgfSxcbiAgeyBuYW1lOiBcInNwYW5cIiwganNvblR5cGU6IFwib2JqZWN0XCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJzdHJpbmdcIiwganNvblR5cGU6IFwic3RyaW5nXCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJ0ZWxlcGhvbmVcIiwganNvblR5cGU6IFwic3RyaW5nXCIsIHR5cGU6IFwidHlwZVwiIH0sXG4gIHsgbmFtZTogXCJ0ZXh0XCIsIGpzb25UeXBlOiBcInN0cmluZ1wiLCB0eXBlOiBcInR5cGVcIiB9LFxuICB7IG5hbWU6IFwidXJsXCIsIGpzb25UeXBlOiBcInN0cmluZ1wiLCB0eXBlOiBcInR5cGVcIiB9XG5dLCBjb3JlVHlwZU5hbWVzID0gY29yZVR5cGVzLm1hcCgodCkgPT4gdC5uYW1lKTtcbmZ1bmN0aW9uIHRyYXZlcnNlU2FuaXR5U2NoZW1hKHNjaGVtYVR5cGVzLCB2aXNpdG9yKSB7XG4gIHJldHVybiB0cmF2ZXJzZVNjaGVtYShzY2hlbWFUeXBlcywgY29yZVR5cGVzLCB2aXNpdG9yKTtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZU5hbWUodHlwZU5hbWUpIHtcbiAgcmV0dXJuIHR5cGVOYW1lID09PSBcInN0cmluZ1wiIHx8IHR5cGVOYW1lID09PSBcIm51bWJlclwiIHx8IHR5cGVOYW1lID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGlzQXNzaWduYWJsZSh0eXBlTmFtZSwgdHlwZSkge1xuICByZXR1cm4gKHR5cGVvZiB0eXBlLm5hbWUgPT0gXCJzdHJpbmdcIiA/IHR5cGUubmFtZSA6IHR5cGUudHlwZSkgPT09IHR5cGVOYW1lO1xufVxuZnVuY3Rpb24gcXVvdGUkMihuKSB7XG4gIHJldHVybiBgXCIke259XCJgO1xufVxuZnVuY3Rpb24gcGx1cmFsaXplKGFyciwgc3VmID0gXCJzXCIpIHtcbiAgcmV0dXJuIGFyci5sZW5ndGggPT09IDEgPyBcIlwiIDogc3VmO1xufVxuZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGBhcnJheSB3aXRoICR7dmFsdWUubGVuZ3RofSBlbnRyaWVzYCA6IHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsID8gYG9iamVjdCB3aXRoIGtleXMgJHtodW1hbml6ZUxpc3QoT2JqZWN0LmtleXModmFsdWUpLm1hcChxdW90ZSQyKSl9YCA6IHF1b3RlJDIodmFsdWUpO1xufVxudmFyIGFycmF5ID0gKHR5cGVEZWYsIHZpc2l0b3JDb250ZXh0KSA9PiB7XG4gIGNvbnN0IG9mSXNBcnJheSA9IEFycmF5LmlzQXJyYXkodHlwZURlZi5vZik7XG4gIGlmIChvZklzQXJyYXkpIHtcbiAgICBjb25zdCBpbnZhbGlkID0gdHlwZURlZi5vZi5yZWR1Y2UoKGVycnMsIGRlZiwgaWR4KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRlZi5uYW1lID09IFwic3RyaW5nXCIgJiYgLy8gc3BlY2lmeWluZyB0aGUgc2FtZSBuYW1lIGFzIHRoZSB0eXBlIGlzIHJlZHVuZGFudCwgYnV0IHNob3VsZCBub3QgYmUgYSBoYXJkIGVycm9yIGF0IHRoaXMgcG9pbnRcbiAgICAgIC8vIENvbnNpZGVyIHNob3dpbmcgYSB3YXJuaW5nIGZvciB0aGlzIGFuZCBkZXByZWNhdGUgdGhpcyBhYmlsaXR5IGV2ZW50dWFsbHlcbiAgICAgIGRlZi5uYW1lICE9PSBkZWYudHlwZSAmJiBjb3JlVHlwZU5hbWVzLmluY2x1ZGVzKGRlZi5uYW1lKSlcbiAgICAgICAgcmV0dXJuIGVycnMuY29uY2F0KFxuICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIGFycmF5IG1lbWJlciBkZWNsYXJhdGlvbiB3aXRoIHRoZSBzYW1lIHR5cGUgbmFtZSBhcyBhIGJ1aWx0LWluIHR5cGUgKFwiJHtkZWYubmFtZX1cIikuIEFycmF5IG1lbWJlcnMgY2FuIG5vdCBiZSBnaXZlbiB0aGUgc2FtZSBuYW1lIGFzIGEgYnVpbHQtaW4gdHlwZS5gLFxuICAgICAgICAgICAgSEVMUF9JRFMuQVJSQVlfT0ZfVFlQRV9CVUlMVElOX1RZUEVfQ09ORkxJQ1RcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBpZiAoZGVmLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgZGVmLm5hbWUgJiYgdmlzaXRvckNvbnRleHQuZ2V0VHlwZShkZWYubmFtZSkpXG4gICAgICAgIHJldHVybiBlcnJzLmNvbmNhdChcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgYEZvdW5kIGFycmF5IG1lbWJlciBkZWNsYXJhdGlvbiB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGdsb2JhbCBzY2hlbWEgdHlwZSBcIiR7ZGVmLm5hbWV9XCIuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGEgdW5pcXVlIG5hbWUgdG8gYXZvaWQgcG9zc2libHkgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMgdGhhdCBzaGFyZXMgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICAgICAgSEVMUF9JRFMuQVJSQVlfT0ZfVFlQRV9HTE9CQUxfVFlQRV9DT05GTElDVFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmIChkZWYudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gZXJycy5jb25jYXQoXG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAnRm91bmQgYXJyYXkgbWVtYmVyIGRlY2xhcmF0aW9uIG9mIHR5cGUgXCJhcnJheVwiIC0gbXVsdGlkaW1lbnNpb25hbCBhcnJheXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IFNhbml0eScsXG4gICAgICAgICAgICBIRUxQX0lEUy5BUlJBWV9PRl9BUlJBWVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIGlmIChkZWYpXG4gICAgICAgIHJldHVybiBlcnJzO1xuICAgICAgY29uc3QgZXJyID0gYEZvdW5kICR7ZGVmID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgZGVmfSwgZXhwZWN0ZWQgbWVtYmVyIGRlY2xhcmF0aW9uYDtcbiAgICAgIHJldHVybiBlcnJzLmNvbmNhdChcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgYEZvdW5kIGludmFsaWQgdHlwZSBtZW1iZXIgZGVjbGFyYXRpb24gaW4gYXJyYXkgYXQgaW5kZXggJHtpZHh9OiAke2Vycn1gLFxuICAgICAgICAgIEhFTFBfSURTLkFSUkFZX09GX0lOVkFMSURcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGludmFsaWQubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnR5cGVEZWYsXG4gICAgICAgIG9mOiBbXSxcbiAgICAgICAgX3Byb2JsZW1zOiBpbnZhbGlkXG4gICAgICB9O1xuICB9XG4gIGNvbnN0IHByb2JsZW1zID0gZmxhdHRlbihbXG4gICAgb2ZJc0FycmF5ID8gZ2V0RHVwZXModHlwZURlZi5vZiwgKHQpID0+IGAke3QubmFtZX07JHt0LnR5cGV9YCkubWFwKFxuICAgICAgKGR1cGVzKSA9PiBlcnJvcihcbiAgICAgICAgYEZvdW5kICR7ZHVwZXMubGVuZ3RofSBtZW1iZXJzIHdpdGggc2FtZSB0eXBlLCBidXQgbm90IHVuaXF1ZSBuYW1lcyBcIiR7ZHVwZXNbMF0udHlwZX1cIiBpbiBhcnJheS4gVGhpcyBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIHRlbGwgdGhlaXIgdmFsdWVzIGFwYXJ0IGFuZCB5b3Ugc2hvdWxkIGNvbnNpZGVyIG5hbWluZyB0aGVtYCxcbiAgICAgICAgSEVMUF9JRFMuQVJSQVlfT0ZfTk9UX1VOSVFVRVxuICAgICAgKVxuICAgICkgOiBlcnJvcihcbiAgICAgICdUaGUgYXJyYXkgdHlwZSBpcyBtaXNzaW5nIG9yIGhhdmluZyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgcmVxdWlyZWQgXCJvZlwiIHByb3BlcnR5JyxcbiAgICAgIEhFTFBfSURTLkFSUkFZX09GX0lOVkFMSURcbiAgICApXG4gIF0pLCBvZiA9IG9mSXNBcnJheSA/IHR5cGVEZWYub2YgOiBbXSwgaGFzT2JqZWN0VHlwZXNXaXRob3V0TmFtZSA9IG9mLnNvbWUoXG4gICAgKHR5cGUpID0+IHR5cGUudHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdHlwZS5uYW1lID4gXCJ1XCJcbiAgKTtcbiAgb2Yuc29tZSgob2ZUeXBlKSA9PiBvZlR5cGUudHlwZSA9PT0gXCJibG9ja1wiKSAmJiBoYXNPYmplY3RUeXBlc1dpdGhvdXROYW1lICYmIHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICBcIlRoZSBhcnJheSB0eXBlJ3MgJ29mJyBwcm9wZXJ0eSBjYW4ndCBoYXZlIGFuIG9iamVjdCB0eXBlIHdpdGhvdXQgYSAnbmFtZScgcHJvcGVydHkgYXMgbWVtYmVyLCB3aGVuIHRoZSAnYmxvY2snIHR5cGUgaXMgYWxzbyBhIG1lbWJlciBvZiB0aGF0IGFycmF5LlwiLFxuICAgICAgSEVMUF9JRFMuQVJSQVlfT0ZfSU5WQUxJRFxuICAgIClcbiAgKTtcbiAgY29uc3QgW3ByaW1pdGl2ZVR5cGVzLCBvYmplY3RUeXBlc10gPSBwYXJ0aXRpb24oXG4gICAgb2YsXG4gICAgKG9mVHlwZSkgPT4gaXNQcmltaXRpdmVUeXBlTmFtZShvZlR5cGUudHlwZSkgfHwgaXNQcmltaXRpdmVUeXBlTmFtZSh2aXNpdG9yQ29udGV4dC5nZXRUeXBlKG9mVHlwZS50eXBlKT8uanNvblR5cGUpXG4gICksIGlzTWl4ZWRBcnJheSA9IHByaW1pdGl2ZVR5cGVzLmxlbmd0aCA+IDAgJiYgb2JqZWN0VHlwZXMubGVuZ3RoID4gMDtcbiAgaWYgKGlzTWl4ZWRBcnJheSkge1xuICAgIGNvbnN0IHByaW1pdGl2ZVR5cGVOYW1lcyA9IHByaW1pdGl2ZVR5cGVzLm1hcCgodCkgPT4gdC50eXBlKSwgb2JqZWN0VHlwZU5hbWVzID0gb2JqZWN0VHlwZXMubWFwKCh0KSA9PiB0LnR5cGUpO1xuICAgIHByb2JsZW1zLnB1c2goXG4gICAgICBlcnJvcihcbiAgICAgICAgYFRoZSBhcnJheSB0eXBlJ3MgJ29mJyBwcm9wZXJ0eSBjYW4ndCBoYXZlIGJvdGggb2JqZWN0IHR5cGVzIGFuZCBwcmltaXRpdmUgdHlwZXMgKGZvdW5kIHByaW1pdGl2ZSB0eXBlICR7cGx1cmFsaXplKFxuICAgICAgICAgIHByaW1pdGl2ZVR5cGVOYW1lc1xuICAgICAgICApfSAke2h1bWFuaXplTGlzdChwcmltaXRpdmVUeXBlTmFtZXMubWFwKHF1b3RlJDIpKX0gYW5kIG9iamVjdCB0eXBlJHtwbHVyYWxpemUoXG4gICAgICAgICAgb2JqZWN0VHlwZU5hbWVzXG4gICAgICAgICl9ICR7aHVtYW5pemVMaXN0KG9iamVjdFR5cGVOYW1lcy5tYXAocXVvdGUkMikpfSlgLFxuICAgICAgICBIRUxQX0lEUy5BUlJBWV9PRl9JTlZBTElEXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBjb25zdCBsaXN0ID0gdHlwZURlZj8ub3B0aW9ucz8ubGlzdDtcbiAgcmV0dXJuICFpc01peGVkQXJyYXkgJiYgQXJyYXkuaXNBcnJheShsaXN0KSAmJiAocHJpbWl0aXZlVHlwZXMubGVuZ3RoID4gMCA/IGxpc3QuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb24/LnZhbHVlID8/IG9wdGlvbjtcbiAgICBpZiAoIXByaW1pdGl2ZVR5cGVzLnNvbWUoKHByaW1pdGl2ZVR5cGUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gdmlzaXRvckNvbnRleHQuZ2V0VHlwZShwcmltaXRpdmVUeXBlLnR5cGUpLmpzb25UeXBlKSkge1xuICAgICAgY29uc3QgZm9ybWF0dGVkVHlwZUxpc3QgPSBodW1hbml6ZUxpc3QoXG4gICAgICAgIHByaW1pdGl2ZVR5cGVzLm1hcCgodCkgPT4gdC5uYW1lIHx8IHQudHlwZSksXG4gICAgICAgIHsgY29uanVuY3Rpb246IFwib3JcIiB9XG4gICAgICApO1xuICAgICAgcHJvYmxlbXMucHVzaChcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgYEFuIGludmFsaWQgZW50cnkgZm91bmQgaW4gb3B0aW9ucy5saXN0OiAke2Zvcm1hdChcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgKX0uIE11c3QgYmUgZWl0aGVyIGEgdmFsdWUgb2YgdHlwZSAke2Zvcm1hdHRlZFR5cGVMaXN0fSwgb3IgYW4gb2JqZWN0IHdpdGgge3RpdGxlOiBzdHJpbmcsIHZhbHVlOiAke2Zvcm1hdHRlZFR5cGVMaXN0fX1gLFxuICAgICAgICAgIEhFTFBfSURTLkFSUkFZX1BSRURFRklORURfQ0hPSUNFU19JTlZBTElEXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9KSA6IGxpc3QuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9uVHlwZU5hbWUgPSBvcHRpb24uX3R5cGUgfHwgXCJvYmplY3RcIjtcbiAgICBvYmplY3RUeXBlcy5zb21lKFxuICAgICAgKHZhbGlkT2JqZWN0VHlwZSkgPT4gaXNBc3NpZ25hYmxlKG9wdGlvblR5cGVOYW1lLCB2YWxpZE9iamVjdFR5cGUpXG4gICAgKSB8fCBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBBbiBpbnZhbGlkIGVudHJ5IGZvdW5kIGluIG9wdGlvbnMubGlzdDogJHtmb3JtYXQoXG4gICAgICAgICAgb3B0aW9uXG4gICAgICAgICl9LiBNdXN0IGJlIGFuIG9iamVjdCB3aXRoIFwiX3R5cGVcIiBzZXQgdG8gJHtodW1hbml6ZUxpc3QoXG4gICAgICAgICAgb2JqZWN0VHlwZXMubWFwKCh0KSA9PiB0Lm5hbWUgfHwgdC50eXBlKS5tYXAoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgPyBcInVuZGVmaW5lZFwiIDogcXVvdGUkMih0KSksXG4gICAgICAgICAgeyBjb25qdW5jdGlvbjogXCJvclwiIH1cbiAgICAgICAgKX1gLFxuICAgICAgICBIRUxQX0lEUy5BUlJBWV9QUkVERUZJTkVEX0NIT0lDRVNfSU5WQUxJRFxuICAgICAgKVxuICAgICk7XG4gIH0pKSwgdHlwZURlZj8ub3B0aW9ucz8ubGlzdCAmJiB0eXBlRGVmPy5vcHRpb25zPy5sYXlvdXQgPT09IFwidGFnc1wiICYmIHByb2JsZW1zLnB1c2goXG4gICAgd2FybmluZyhcbiAgICAgIFwiRm91bmQgYXJyYXkgbWVtYmVyIGRlY2xhcmF0aW9uIHdpdGggYm90aCB0YWdzIGxheW91dCBhbmQgYSBsaXN0IG9mIHByZWRlZmluZWQgdmFsdWVzLiBJZiB5b3Ugd2FudCB0byBkaXNwbGF5IGEgbGlzdCBvZiBwcmVkZWZpbmVkIHZhbHVlcywgcmVtb3ZlIHRoZSB0YWdzIGxheW91dCBmcm9tIGBvcHRpb25zYC5cIlxuICAgIClcbiAgKSwge1xuICAgIC4uLnR5cGVEZWYsXG4gICAgb2Y6IG9mLm1hcCh2aXNpdG9yQ29udGV4dC52aXNpdCksXG4gICAgX3Byb2JsZW1zOiBwcm9ibGVtc1xuICB9O1xufTtcbmZ1bmN0aW9uIGlzSlNPTlR5cGVPZih0eXBlLCBqc29uVHlwZSwgdmlzaXRvckNvbnRleHQpIHtcbiAgaWYgKFwianNvblR5cGVcIiBpbiB0eXBlKVxuICAgIHJldHVybiB0eXBlLmpzb25UeXBlID09PSBqc29uVHlwZTtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHZpc2l0b3JDb250ZXh0LmdldFR5cGUodHlwZS50eXBlKTtcbiAgaWYgKCFwYXJlbnRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUganNvblR5cGUgb2YgJHt0eXBlLm5hbWV9LiBObyBwYXJlbnQgdHlwZSBmb3VuZGApO1xuICByZXR1cm4gaXNKU09OVHlwZU9mKHBhcmVudFR5cGUsIGpzb25UeXBlLCB2aXNpdG9yQ29udGV4dCk7XG59XG5jb25zdCBnZXRUeXBlT2YgPSAodGhpbmcpID0+IEFycmF5LmlzQXJyYXkodGhpbmcpID8gXCJhcnJheVwiIDogdHlwZW9mIHRoaW5nLCBxdW90ZSQxID0gKHN0cikgPT4gYFwiJHtzdHJ9XCJgLCBhbGxvd2VkS2V5cyA9IFtcbiAgXCJjb21wb25lbnRzXCIsXG4gIFwibGlzdHNcIixcbiAgXCJtYXJrc1wiLFxuICBcIm5hbWVcIixcbiAgXCJvZlwiLFxuICBcIm9wdGlvbnNcIixcbiAgXCJzdHlsZXNcIixcbiAgXCJ0aXRsZVwiLFxuICBcInR5cGVcIixcbiAgXCJ2YWxpZGF0aW9uXCJcbl0sIGFsbG93ZWRNYXJrS2V5cyA9IFtcImRlY29yYXRvcnNcIiwgXCJhbm5vdGF0aW9uc1wiXSwgYWxsb3dlZFN0eWxlS2V5cyA9IFtcImJsb2NrRWRpdG9yXCIsIFwidGl0bGVcIiwgXCJ2YWx1ZVwiLCBcImljb25cIiwgXCJjb21wb25lbnRcIl0sIGFsbG93ZWREZWNvcmF0b3JLZXlzID0gW1wiYmxvY2tFZGl0b3JcIiwgXCJ0aXRsZVwiLCBcInZhbHVlXCIsIFwiaWNvblwiLCBcImNvbXBvbmVudFwiXSwgYWxsb3dlZExpc3RLZXlzID0gW1widGl0bGVcIiwgXCJ2YWx1ZVwiLCBcImljb25cIiwgXCJjb21wb25lbnRcIl0sIHN1cHBvcnRlZEJ1aWx0SW5PYmplY3RUeXBlcyA9IFtcbiAgXCJmaWxlXCIsXG4gIFwiaW1hZ2VcIixcbiAgXCJvYmplY3RcIixcbiAgXCJyZWZlcmVuY2VcIixcbiAgXCJjcm9zc0RhdGFzZXRSZWZlcmVuY2VcIixcbiAgXCJnbG9iYWxEb2N1bWVudFJlZmVyZW5jZVwiXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVCbG9ja1R5cGUodHlwZURlZiwgdmlzaXRvckNvbnRleHQpIHtcbiAgY29uc3QgcHJvYmxlbXMgPSBbXTtcbiAgbGV0IHN0eWxlcyA9IHR5cGVEZWYuc3R5bGVzLCBsaXN0cyA9IHR5cGVEZWYubGlzdHMsIG1hcmtzID0gdHlwZURlZi5tYXJrcywgbWVtYmVycyA9IHR5cGVEZWYub2Y7XG4gIGNvbnN0IGRpc2FsbG93ZWRLZXlzID0gT2JqZWN0LmtleXModHlwZURlZikuZmlsdGVyKFxuICAgIChrZXkpID0+ICFhbGxvd2VkS2V5cy5pbmNsdWRlcyhrZXkpICYmICFrZXkuc3RhcnRzV2l0aChcIl9cIilcbiAgKTtcbiAgcmV0dXJuIGRpc2FsbG93ZWRLZXlzLmxlbmd0aCA+IDAgJiYgcHJvYmxlbXMucHVzaChcbiAgICBlcnJvcihcbiAgICAgIGBGb3VuZCB1bmtub3duIHByb3BlcnRpZXMgZm9yIGJsb2NrIGRlY2xhcmF0aW9uOiAke2h1bWFuaXplTGlzdChcbiAgICAgICAgZGlzYWxsb3dlZEtleXMubWFwKHF1b3RlJDEpXG4gICAgICApfWBcbiAgICApXG4gICksIG1hcmtzICYmIChtYXJrcyA9IHZhbGlkYXRlTWFya3ModHlwZURlZi5tYXJrcywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSksIHN0eWxlcyAmJiAoc3R5bGVzID0gdmFsaWRhdGVTdHlsZXMoc3R5bGVzLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpKSwgbGlzdHMgJiYgKGxpc3RzID0gdmFsaWRhdGVMaXN0cyhsaXN0cywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSksIG1lbWJlcnMgJiYgKG1lbWJlcnMgPSB2YWxpZGF0ZU1lbWJlcnMobWVtYmVycywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSksIHtcbiAgICAuLi5vbWl0KHR5cGVEZWYsIGRpc2FsbG93ZWRLZXlzKSxcbiAgICBtYXJrcyxcbiAgICBzdHlsZXMsXG4gICAgbmFtZTogdHlwZURlZi5uYW1lIHx8IHR5cGVEZWYudHlwZSxcbiAgICBvZjogbWVtYmVycyxcbiAgICBfcHJvYmxlbXM6IHByb2JsZW1zXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1hcmtzKG1hcmtzLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpIHtcbiAgbGV0IGRlY29yYXRvcnMgPSBtYXJrcy5kZWNvcmF0b3JzLCBhbm5vdGF0aW9ucyA9IG1hcmtzLmFubm90YXRpb25zO1xuICBpZiAoIWlzUGxhaW5PYmplY3QobWFya3MpKVxuICAgIHJldHVybiBwcm9ibGVtcy5wdXNoKGVycm9yKGBcIm1hcmtzXCIgZGVjbGFyYXRpb24gc2hvdWxkIGJlIGFuIG9iamVjdCwgZ290ICR7Z2V0VHlwZU9mKG1hcmtzKX1gKSksIHByb2JsZW1zO1xuICBjb25zdCBkaXNhbGxvd2VkTWFya0tleXMgPSBPYmplY3Qua2V5cyhtYXJrcykuZmlsdGVyKFxuICAgIChrZXkpID0+ICFhbGxvd2VkTWFya0tleXMuaW5jbHVkZXMoa2V5KSAmJiAha2V5LnN0YXJ0c1dpdGgoXCJfXCIpXG4gICk7XG4gIHJldHVybiBkaXNhbGxvd2VkTWFya0tleXMubGVuZ3RoID4gMCAmJiBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKFxuICAgICAgYEZvdW5kIHVua25vd24gcHJvcGVydGllcyBmb3IgYmxvY2sgZGVjbGFyYXRpb246ICR7aHVtYW5pemVMaXN0KFxuICAgICAgICBkaXNhbGxvd2VkTWFya0tleXMubWFwKHF1b3RlJDEpXG4gICAgICApfWBcbiAgICApXG4gICksIGRlY29yYXRvcnMgJiYgIUFycmF5LmlzQXJyYXkoZGVjb3JhdG9ycykgPyBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKGBcIm1hcmtzLmRlY29yYXRvcnNcIiBkZWNsYXJhdGlvbiBzaG91bGQgYmUgYW4gYXJyYXksIGdvdCAke2dldFR5cGVPZihkZWNvcmF0b3JzKX1gKVxuICApIDogZGVjb3JhdG9ycyAmJiAoZGVjb3JhdG9ycy5maWx0ZXIoKGRlYykgPT4gISFkZWMuYmxvY2tFZGl0b3IpLmZvckVhY2goKGRlYykgPT4ge1xuICAgIGRlYy5pY29uID0gZGVjLmJsb2NrRWRpdG9yLmljb24sIGRlYy5jb21wb25lbnQgPSBkZWMuYmxvY2tFZGl0b3IucmVuZGVyO1xuICB9KSwgZGVjb3JhdG9ycyA9IHZhbGlkYXRlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpKSwgYW5ub3RhdGlvbnMgJiYgIUFycmF5LmlzQXJyYXkoYW5ub3RhdGlvbnMpID8gcHJvYmxlbXMucHVzaChcbiAgICBlcnJvcihgXCJtYXJrcy5hbm5vdGF0aW9uc1wiIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBhbiBhcnJheSwgZ290ICR7Z2V0VHlwZU9mKGFubm90YXRpb25zKX1gKVxuICApIDogYW5ub3RhdGlvbnMgJiYgKGFubm90YXRpb25zID0gdmFsaWRhdGVBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSksIHsgLi4ubWFya3MsIGRlY29yYXRvcnMsIGFubm90YXRpb25zIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxpc3RzKGxpc3RzLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGlzdHMpID8gKGxpc3RzLmZvckVhY2goKGxpc3QsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGxpc3QpKSB7XG4gICAgICBwcm9ibGVtcy5wdXNoKGVycm9yKGBMaXN0IG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJHtnZXRUeXBlT2YobGlzdCl9YCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gbGlzdC52YWx1ZSB8fCBgIyR7aW5kZXh9YCwgZGlzYWxsb3dlZEtleXMgPSBPYmplY3Qua2V5cyhsaXN0KS5maWx0ZXIoXG4gICAgICAoa2V5KSA9PiAhYWxsb3dlZExpc3RLZXlzLmluY2x1ZGVzKGtleSkgJiYgIWtleS5zdGFydHNXaXRoKFwiX1wiKVxuICAgICk7XG4gICAgZGlzYWxsb3dlZEtleXMubGVuZ3RoID4gMCAmJiBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBGb3VuZCB1bmtub3duIHByb3BlcnRpZXMgZm9yIGxpc3QgJHtuYW1lfTogJHtodW1hbml6ZUxpc3QoZGlzYWxsb3dlZEtleXMubWFwKHF1b3RlJDEpKX1gXG4gICAgICApXG4gICAgKSwgbGlzdC52YWx1ZSA/IHR5cGVvZiBsaXN0LnZhbHVlICE9IFwic3RyaW5nXCIgPyBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBMaXN0IHR5cGUgIyR7aW5kZXh9IGhhcyBhbiBpbnZhbGlkIFwidmFsdWVcIiBwcm9wZXJ0eSwgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHtnZXRUeXBlT2YoXG4gICAgICAgICAgbGlzdC52YWx1ZVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICApIDogbGlzdC50aXRsZSB8fCBwcm9ibGVtcy5wdXNoKHdhcm5pbmcoYExpc3QgdHlwZSAke25hbWV9IGlzIG1pc3NpbmcgcmVjb21tZW5kZWQgXCJ0aXRsZVwiIHByb3BlcnR5YCkpIDogcHJvYmxlbXMucHVzaChlcnJvcihgTGlzdCAjJHtpbmRleH0gaXMgbWlzc2luZyByZXF1aXJlZCBcInZhbHVlXCIgcHJvcGVydHlgKSk7XG4gIH0pLCBsaXN0cykgOiAocHJvYmxlbXMucHVzaChlcnJvcihgXCJsaXN0c1wiIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBhbiBhcnJheSwgZ290ICR7Z2V0VHlwZU9mKGxpc3RzKX1gKSksIHByb2JsZW1zKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU3R5bGVzKHN0eWxlcywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHN0eWxlcykgPyAoc3R5bGVzLmZvckVhY2goKHN0eWxlLCBpbmRleCkgPT4ge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzdHlsZSkpIHtcbiAgICAgIHByb2JsZW1zLnB1c2goZXJyb3IoYFN0eWxlIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJHtnZXRUeXBlT2Yoc3R5bGUpfWApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHN0eWxlLnZhbHVlIHx8IGAjJHtpbmRleH1gLCBkaXNhbGxvd2VkS2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlKS5maWx0ZXIoXG4gICAgICAoa2V5KSA9PiAhYWxsb3dlZFN0eWxlS2V5cy5pbmNsdWRlcyhrZXkpICYmICFrZXkuc3RhcnRzV2l0aChcIl9cIilcbiAgICApO1xuICAgIGRpc2FsbG93ZWRLZXlzLmxlbmd0aCA+IDAgJiYgcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBgRm91bmQgdW5rbm93biBwcm9wZXJ0aWVzIGZvciBzdHlsZSAke25hbWV9OiAke2h1bWFuaXplTGlzdChkaXNhbGxvd2VkS2V5cy5tYXAocXVvdGUkMSkpfWBcbiAgICAgIClcbiAgICApLCBzdHlsZS52YWx1ZSA/IHR5cGVvZiBzdHlsZS52YWx1ZSAhPSBcInN0cmluZ1wiID8gcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBgU3R5bGUgIyR7aW5kZXh9IGhhcyBhbiBpbnZhbGlkIFwidmFsdWVcIiBwcm9wZXJ0eSwgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHtnZXRUeXBlT2YoXG4gICAgICAgICAgc3R5bGUudmFsdWVcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgKSA6IHN0eWxlLnRpdGxlIHx8IHByb2JsZW1zLnB1c2god2FybmluZyhgU3R5bGUgJHtuYW1lfSBpcyBtaXNzaW5nIHJlY29tbWVuZGVkIFwidGl0bGVcIiBwcm9wZXJ0eWApKSA6IHByb2JsZW1zLnB1c2goZXJyb3IoYFN0eWxlICMke2luZGV4fSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwidmFsdWVcIiBwcm9wZXJ0eWApKSwgdHlwZW9mIHN0eWxlLmJsb2NrRWRpdG9yIDwgXCJ1XCIgJiYgKHByb2JsZW1zLnB1c2goXG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnU3R5bGUgaGFzIGRlcHJlY2F0ZWQga2V5IFwiYmxvY2tFZGl0b3JcIiwgcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9uIGhvdyB0byBjb25maWd1cmUgdGhlIGJsb2NrIHR5cGUgZm9yIHZlcnNpb24gMy4nLFxuICAgICAgICBIRUxQX0lEUy5ERVBSRUNBVEVEX0JMT0NLRURJVE9SX0tFWVxuICAgICAgKVxuICAgICksIHN0eWxlLmNvbXBvbmVudCA9IHN0eWxlLmNvbXBvbmVudCB8fCBzdHlsZS5ibG9ja0VkaXRvci5yZW5kZXIpO1xuICB9KSwgc3R5bGVzKSA6IChwcm9ibGVtcy5wdXNoKGVycm9yKGBcInN0eWxlc1wiIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBhbiBhcnJheSwgZ290ICR7Z2V0VHlwZU9mKHN0eWxlcyl9YCkpLCBwcm9ibGVtcyk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdmlzaXRvckNvbnRleHQsIHByb2JsZW1zKSB7XG4gIHJldHVybiBkZWNvcmF0b3JzLmZvckVhY2goKGRlY29yYXRvciwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGVjb3JhdG9yKSkge1xuICAgICAgcHJvYmxlbXMucHVzaChlcnJvcihgQW5ub3RhdGlvbiBtdXN0IGJlIGFuIG9iamVjdCwgZ290ICR7Z2V0VHlwZU9mKGRlY29yYXRvcil9YCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZGVjb3JhdG9yLnZhbHVlIHx8IGAjJHtpbmRleH1gLCBkaXNhbGxvd2VkS2V5cyA9IE9iamVjdC5rZXlzKGRlY29yYXRvcikuZmlsdGVyKFxuICAgICAgKGtleSkgPT4gIWFsbG93ZWREZWNvcmF0b3JLZXlzLmluY2x1ZGVzKGtleSkgJiYgIWtleS5zdGFydHNXaXRoKFwiX1wiKVxuICAgICk7XG4gICAgZGlzYWxsb3dlZEtleXMubGVuZ3RoID4gMCAmJiBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBGb3VuZCB1bmtub3duIHByb3BlcnRpZXMgZm9yIGRlY29yYXRvciAke25hbWV9OiAke2h1bWFuaXplTGlzdChcbiAgICAgICAgICBkaXNhbGxvd2VkS2V5cy5tYXAocXVvdGUkMSlcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgKSwgZGVjb3JhdG9yLnZhbHVlID8gdHlwZW9mIGRlY29yYXRvci52YWx1ZSAhPSBcInN0cmluZ1wiID8gcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBgRGVjb3JhdG9yICMke2luZGV4fSBoYXMgYW4gaW52YWxpZCBcInZhbHVlXCIgcHJvcGVydHksIGV4cGVjdGVkIHN0cmluZywgZ290ICR7Z2V0VHlwZU9mKFxuICAgICAgICAgIGRlY29yYXRvci52YWx1ZVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICApIDogZGVjb3JhdG9yLnRpdGxlIHx8IHByb2JsZW1zLnB1c2god2FybmluZyhgRGVjb3JhdG9yICR7bmFtZX0gaXMgbWlzc2luZyByZWNvbW1lbmRlZCBcInRpdGxlXCIgcHJvcGVydHlgKSkgOiBwcm9ibGVtcy5wdXNoKGVycm9yKGBEZWNvcmF0b3IgIyR7aW5kZXh9IGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ2YWx1ZVwiIHByb3BlcnR5YCkpLCB0eXBlb2YgZGVjb3JhdG9yLmJsb2NrRWRpdG9yIDwgXCJ1XCIgJiYgKHByb2JsZW1zLnB1c2goXG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgRGVjb3JhdG9yIFwiJHtuYW1lfVwiIGhhcyBkZXByZWNhdGVkIGtleSBcImJsb2NrRWRpdG9yXCIsIHBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbiBvbiBob3cgdG8gY29uZmlndXJlIHRoZSBibG9jayB0eXBlIGZvciB2ZXJzaW9uIDMuYCxcbiAgICAgICAgSEVMUF9JRFMuREVQUkVDQVRFRF9CTE9DS0VESVRPUl9LRVlcbiAgICAgIClcbiAgICApLCBkZWNvcmF0b3IuaWNvbiA9IGRlY29yYXRvci5pY29uIHx8IGRlY29yYXRvci5ibG9ja0VkaXRvci5pY29uLCBkZWNvcmF0b3IuY29tcG9uZW50ID0gZGVjb3JhdG9yLmNvbXBvbmVudCB8fCBkZWNvcmF0b3IuYmxvY2tFZGl0b3IucmVuZGVyKTtcbiAgfSksIGRlY29yYXRvcnM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFubm90YXRpb25zKGFubm90YXRpb25zLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpIHtcbiAgcmV0dXJuIGFubm90YXRpb25zLm1hcCgoYW5ub3RhdGlvbikgPT4ge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhbm5vdGF0aW9uKSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFubm90YXRpb24sXG4gICAgICAgIF9wcm9ibGVtczogW2Vycm9yKGBBbm5vdGF0aW9uIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgJHtnZXRUeXBlT2YoYW5ub3RhdGlvbil9YCldXG4gICAgICB9O1xuICAgIGNvbnN0IHsgX3Byb2JsZW1zIH0gPSB2aXNpdG9yQ29udGV4dC52aXNpdChhbm5vdGF0aW9uLCB2aXNpdG9yQ29udGV4dCksIHRhcmdldFR5cGUgPSBhbm5vdGF0aW9uLnR5cGUgJiYgdmlzaXRvckNvbnRleHQuZ2V0VHlwZShhbm5vdGF0aW9uLnR5cGUpO1xuICAgIHJldHVybiB0YXJnZXRUeXBlICYmICFpc0pTT05UeXBlT2YodGFyZ2V0VHlwZSwgXCJvYmplY3RcIiwgdmlzaXRvckNvbnRleHQpICYmIF9wcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBBbm5vdGF0aW9uIGNhbm5vdCBoYXZlIHR5cGUgXCIke2Fubm90YXRpb24udHlwZX1cIiAtIGFubm90YXRpb24gdHlwZXMgbXVzdCBpbmhlcml0IGZyb20gb2JqZWN0YFxuICAgICAgKVxuICAgICksIHR5cGVvZiBhbm5vdGF0aW9uLmJsb2NrRWRpdG9yIDwgXCJ1XCIgJiYgKHByb2JsZW1zLnB1c2goXG4gICAgICB3YXJuaW5nKFxuICAgICAgICAnQW5ub3RhdGlvbiBoYXMgZGVwcmVjYXRlZCBrZXkgXCJibG9ja0VkaXRvclwiLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24gb24gaG93IHRvIGNvbmZpZ3VyZSB0aGUgYmxvY2sgdHlwZSBmb3IgdmVyc2lvbiAzLicsXG4gICAgICAgIEhFTFBfSURTLkRFUFJFQ0FURURfQkxPQ0tFRElUT1JfS0VZXG4gICAgICApXG4gICAgKSwgYW5ub3RhdGlvbi5pY29uID0gYW5ub3RhdGlvbi5pY29uIHx8IGFubm90YXRpb24uYmxvY2tFZGl0b3IuaWNvbiwgYW5ub3RhdGlvbi5ibG9ja0VkaXRvcj8ucmVuZGVyICYmICFhbm5vdGF0aW9uLmNvbXBvbmVudHM/LmFubm90YXRpb24gJiYgKGFubm90YXRpb24uY29tcG9uZW50cyA9IGFubm90YXRpb24uY29tcG9uZW50cyB8fCB7fSwgYW5ub3RhdGlvbi5jb21wb25lbnRzLmFubm90YXRpb24gPSBhbm5vdGF0aW9uLmNvbXBvbmVudHMuYW5ub3RhdGlvbiB8fCBhbm5vdGF0aW9uLmJsb2NrRWRpdG9yLnJlbmRlcikpLCB7IC4uLmFubm90YXRpb24sIF9wcm9ibGVtcyB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWVtYmVycyhtZW1iZXJzLCB2aXNpdG9yQ29udGV4dCwgcHJvYmxlbXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1lbWJlcnMpKSB7XG4gICAgcHJvYmxlbXMucHVzaChlcnJvcihgXCJvZlwiIGRlY2xhcmF0aW9uIHNob3VsZCBiZSBhbiBhcnJheSwgZ290ICR7Z2V0VHlwZU9mKG1lbWJlcnMpfWApKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIG1lbWJlcnMubWFwKChtZW1iZXIpID0+IHtcbiAgICBjb25zdCB7IF9wcm9ibGVtcyB9ID0gdmlzaXRvckNvbnRleHQudmlzaXQobWVtYmVyLCB2aXNpdG9yQ29udGV4dCk7XG4gICAgaWYgKG1lbWJlci50eXBlID09PSBcIm9iamVjdFwiICYmIG1lbWJlci5uYW1lICYmIHZpc2l0b3JDb250ZXh0LmdldFR5cGUobWVtYmVyLm5hbWUpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVtYmVyLFxuICAgICAgICBfcHJvYmxlbXM6IFtcbiAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgYEZvdW5kIGFycmF5IG1lbWJlciBkZWNsYXJhdGlvbiB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGdsb2JhbCBzY2hlbWEgdHlwZSBcIiR7bWVtYmVyLm5hbWV9XCIuIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIGEgdW5pcXVlIG5hbWUgdG8gYXZvaWQgcG9zc2libHkgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMgdGhhdCBzaGFyZXMgdGhlIHNhbWUgbmFtZS5gLFxuICAgICAgICAgICAgSEVMUF9JRFMuQVJSQVlfT0ZfVFlQRV9HTE9CQUxfVFlQRV9DT05GTElDVFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICBsZXQgdHlwZSA9IG1lbWJlcjtcbiAgICBmb3IgKDsgdHlwZSAmJiAhdHlwZS5qc29uVHlwZTsgKVxuICAgICAgdHlwZSA9IHZpc2l0b3JDb250ZXh0LmdldFR5cGUodHlwZS50eXBlKTtcbiAgICBjb25zdCBub25PYmplY3RDb3JlVHlwZXMgPSBjb3JlVHlwZU5hbWVzLmZpbHRlcigobikgPT4gIXN1cHBvcnRlZEJ1aWx0SW5PYmplY3RUeXBlcy5pbmNsdWRlcyhuKSk7XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIE11c3QgYmUgb2JqZWN0LWxpa2UgdHlwZSAodG8gdmFsaWRhdGUgaG9pc3RlZCB0eXBlcylcbiAgICAgIHR5cGUgJiYgdHlwZS5qc29uVHlwZSAhPT0gXCJvYmplY3RcIiB8fCAvLyBDYW4ndCBiZSBhIGNvcmUgdHlwZSwgb3IgY29yZSBvYmplY3QgdHlwZSB0aGF0IGlzbid0IHN1cHBvcnRlZCAobGlrZSAnc3BhbicpXG4gICAgICBub25PYmplY3RDb3JlVHlwZXMuc29tZSgoY29yZU5hbWUpID0+IGNvcmVOYW1lID09PSBtZW1iZXIudHlwZSkgPyB7XG4gICAgICAgIC4uLm1lbWJlcixcbiAgICAgICAgX3Byb2JsZW1zOiBbXG4gICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICBgQmxvY2sgbWVtYmVyIHR5cGVzIG11c3QgYmUgYSBzdXBwb3J0ZWQgb2JqZWN0LWxpa2UgdHlwZS4gVGhlIGZvbGxvd2luZyBidWlsdC1pbiB0eXBlcyBhcmUgc3VwcG9ydGVkOiAnJHtzdXBwb3J0ZWRCdWlsdEluT2JqZWN0VHlwZXMuam9pbihcbiAgICAgICAgICAgICAgXCInLCAnXCJcbiAgICAgICAgICAgICl9Jy4gWW91IGNhbiBhbHNvIHVzZSBzaG9ydGhhbmRzIGZvciBwcmV2aW91c2x5IGRlZmluZWQgb2JqZWN0IHR5cGVzIGxpa2Uge3R5cGU6ICdteU9iamVjdFR5cGUnfWAsXG4gICAgICAgICAgICBIRUxQX0lEUy5BUlJBWV9PRl9UWVBFX0JVSUxUSU5fVFlQRV9DT05GTElDVFxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgfSA6IHsgLi4ubWVtYmVyLCBfcHJvYmxlbXMgfVxuICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVOb25PYmplY3RGaWVsZHNQcm9wKHR5cGVEZWYsIHZpc2l0b3JDb250ZXh0KSB7XG4gIGlmICghKFwiZmllbGRzXCIgaW4gdHlwZURlZikpXG4gICAgcmV0dXJuIFtdO1xuICBsZXQgdHlwZSA9IHR5cGVEZWY7XG4gIGZvciAoOyB0eXBlICYmICF0eXBlLmpzb25UeXBlOyApXG4gICAgdHlwZSA9IHZpc2l0b3JDb250ZXh0LmdldFR5cGUodHlwZS50eXBlKTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZS5qc29uVHlwZSAhPT0gXCJvYmplY3RcIiA/IFtlcnJvcignVHlwZSBoYXMgcHJvcGVyeSBcImZpZWxkc1wiLCBidXQgaXMgbm90IGFuIG9iamVjdC9kb2N1bWVudCB0eXBlLicpXSA6IFtdO1xufVxuY29uc3QgcXVvdGUgPSAoc3RyKSA9PiBgXCIke3N0cn1cImA7XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVOYW1lKHR5cGVOYW1lLCB2aXNpdG9yQ29udGV4dCkge1xuICBjb25zdCBwb3NzaWJsZVR5cGVOYW1lcyA9IHZpc2l0b3JDb250ZXh0LmdldFR5cGVOYW1lcygpO1xuICBpZiAoIXR5cGVOYW1lKVxuICAgIHJldHVybiBbZXJyb3IoXCJUeXBlIGlzIG1pc3NpbmcgYSB0eXBlLlwiLCBIRUxQX0lEUy5UWVBFX01JU1NJTkdfVFlQRSldO1xuICBpZiAodHlwZW9mIHR5cGVOYW1lICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIFtcbiAgICAgIGVycm9yKFxuICAgICAgICAnVHlwZSBoYXMgYW4gaW52YWxpZCBcInR5cGVcIi1wcm9wZXJ0eSAtIHNob3VsZCBiZSBhIHN0cmluZy4nLFxuICAgICAgICBIRUxQX0lEUy5UWVBFX01JU1NJTkdfVFlQRVxuICAgICAgKVxuICAgIF07XG4gIGlmICghcG9zc2libGVUeXBlTmFtZXMuaW5jbHVkZXModHlwZU5hbWUpKSB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBwb3NzaWJsZVR5cGVOYW1lcy5tYXAoKHBvc3NpYmxlVHlwZU5hbWUpID0+IFtsZXZlbih0eXBlTmFtZSwgcG9zc2libGVUeXBlTmFtZSksIHBvc3NpYmxlVHlwZU5hbWVdKS5maWx0ZXIoKFtkaXN0YW5jZV0pID0+IGRpc3RhbmNlIDwgMykubWFwKChbXywgbmFtZV0pID0+IG5hbWUpLCBzdWdnZXN0aW9uID0gc3VnZ2VzdGlvbnMubGVuZ3RoID4gMCA/IGAgRGlkIHlvdSBtZWFuICR7aHVtYW5pemVMaXN0KHN1Z2dlc3Rpb25zLm1hcChxdW90ZSksIHsgY29uanVuY3Rpb246IFwib3JcIiB9KX0/YCA6IFwiXCI7XG4gICAgcmV0dXJuIFtlcnJvcihgVW5rbm93biB0eXBlOiAke3R5cGVOYW1lfS4ke3N1Z2dlc3Rpb259YCldO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRGVwcmVjYXRlZFByb3BlcnRpZXModHlwZSkge1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICByZXR1cm4gdHlwZT8uaW5wdXRDb21wb25lbnQgJiYgd2FybmluZ3MucHVzaChcbiAgICB3YXJuaW5nKCdUaGUgXCJpbnB1dENvbXBvbmVudFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFVzZSBcImNvbXBvbmVudHMuaW5wdXRcIiBpbnN0ZWFkLicpXG4gICksIHR5cGU/LnByZXZpZXc/LmNvbXBvbmVudCAmJiB3YXJuaW5ncy5wdXNoKFxuICAgIHdhcm5pbmcoJ1RoZSBcInByZXZpZXcuY29tcG9uZW50XCIgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC4gVXNlIFwiY29tcG9uZW50cy5wcmV2aWV3XCIgaW5zdGVhZC4nKVxuICApLCB0eXBlPy5kaWZmQ29tcG9uZW50ICYmIHdhcm5pbmdzLnB1c2goXG4gICAgd2FybmluZygnVGhlIFwiZGlmZkNvbXBvbmVudFwiIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFVzZSBcImNvbXBvbmVudHMuZGlmZlwiIGluc3RlYWQuJylcbiAgKSwgdHlwZT8ub3B0aW9ucz8uZWRpdE1vZGFsICYmIHdhcm5pbmdzLnB1c2goXG4gICAgd2FybmluZygnVGhlIFwib3B0aW9ucy5lZGl0TW9kYWxcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLiBVc2UgXCJvcHRpb25zLm1vZGFsXCIgaW5zdGVhZC4nKVxuICApLCB0eXBlPy5vcHRpb25zPy5pc0hpZ2hsaWdodGVkICYmIHdhcm5pbmdzLnB1c2goXG4gICAgd2FybmluZyhcbiAgICAgICdUaGUgXCJvcHRpb25zLmlzSGlnaGxpZ2h0ZWRcIiBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHB1dCBmaWVsZHMgYmVoaW5kIGEgY29sbGFwc2VkIGZpZWxkc2V0IGlmIHlvdSB3YW50IHRvIGhpZGUgdGhlbSBmcm9tIHBsYWluIHNpZ2h0LidcbiAgICApXG4gICksIHdhcm5pbmdzO1xufVxudmFyIGNvbW1vbiA9ICh0eXBlRGVmLCB2aXNpdG9yQ29udGV4dCkgPT4gKHtcbiAgLi4udHlwZURlZixcbiAgX3Byb2JsZW1zOiBbXG4gICAgLi4udmFsaWRhdGVUeXBlTmFtZSh0eXBlRGVmLnR5cGUsIHZpc2l0b3JDb250ZXh0KSxcbiAgICAuLi52YWxpZGF0ZU5vbk9iamVjdEZpZWxkc1Byb3AodHlwZURlZiwgdmlzaXRvckNvbnRleHQpLFxuICAgIC4uLnZhbGlkYXRlRGVwcmVjYXRlZFByb3BlcnRpZXModHlwZURlZilcbiAgXS5maWx0ZXIoQm9vbGVhbilcbn0pO1xuZnVuY3Rpb24gbm9ybWFsaXplVG9Qcm9wJDIodHlwZURlZikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0eXBlRGVmLnRvKSA/IHR5cGVEZWYudG8gOiB0eXBlRGVmLnRvID8gW3R5cGVEZWYudG9dIDogdHlwZURlZi50bztcbn1cbmNvbnN0IFZBTElEX0RBVEFTRVQgPSAvXlthLXowLTl+XVstX2EtejAtOV0rJC87XG5mdW5jdGlvbiBpc1ZhbGlkRGF0YXNldE5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5sZW5ndGggPj0gMiAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgJiYgVkFMSURfREFUQVNFVC50ZXN0KG5hbWUpIHx8IGBUaGUgcHJvdmlkZWQgZGF0YXNldCBcIiR7bmFtZX1cIiBkb2Vzbid0IGxvb2sgbGlrZSBhIHZhbGlkIGRhdGFzZXQuIERhdGFzZXQgbmFtZXMgbXVzdCBiZSBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzLCBjYW4gb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLCBudW1iZXJzLCB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzIGFuZCBjYW4gbm90IHN0YXJ0IHdpdGggYSBkYXNoIG9yIGFuIHVuZGVyc2NvcmVgO1xufVxudmFyIGNyb3NzRGF0YXNldFJlZmVyZW5jZSA9ICh0eXBlRGVmLCB2aXNpdG9yQ29udGV4dCkgPT4ge1xuICBjb25zdCBpc1ZhbGlkVG8gPSBBcnJheS5pc0FycmF5KHR5cGVEZWYudG8pIHx8IGlzUGxhaW5PYmplY3QodHlwZURlZi50byksIG5vcm1hbGl6ZWRUbyA9IG5vcm1hbGl6ZVRvUHJvcCQyKHR5cGVEZWYpLCBwcm9ibGVtcyA9IGZsYXR0ZW4oW1xuICAgIGlzVmFsaWRUbyA/IGdldER1cGVzKG5vcm1hbGl6ZWRUbywgKHQpID0+IGAke3QubmFtZX07JHt0LnR5cGV9YCkubWFwKFxuICAgICAgKGR1cGVzKSA9PiBlcnJvcihcbiAgICAgICAgYEZvdW5kICR7ZHVwZXMubGVuZ3RofSBtZW1iZXJzIHdpdGggc2FtZSB0eXBlLCBidXQgbm90IHVuaXF1ZSBuYW1lcyBcIiR7ZHVwZXNbMF0udHlwZX1cIiBpbiByZWZlcmVuY2UuIFRoaXMgbWFrZXMgaXQgaW1wb3NzaWJsZSB0byB0ZWxsIHRoZWlyIHZhbHVlcyBhcGFydCBhbmQgeW91IHNob3VsZCBjb25zaWRlciBuYW1pbmcgdGhlbWAsXG4gICAgICAgIEhFTFBfSURTLkNST1NTX0RBVEFTRVRfUkVGRVJFTkNFX0lOVkFMSURcbiAgICAgIClcbiAgICApIDogZXJyb3IoXG4gICAgICAnVGhlIGNyb3NzIGRhdGFzZXQgcmVmZXJlbmNlIHR5cGUgaXMgbWlzc2luZyBvciBoYXZpbmcgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIHJlcXVpcmVkIFwidG9cIiBwcm9wZXJ0eS4gSXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIGFjY2VwdGVkIHR5cGVzLicsXG4gICAgICBIRUxQX0lEUy5DUk9TU19EQVRBU0VUX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgKVxuICBdKTtcbiAgaWYgKGlzVmFsaWRUbyAmJiBub3JtYWxpemVkVG8ubGVuZ3RoID09PSAwICYmIHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICAnVGhlIGNyb3NzIGRhdGFzZXQgcmVmZXJlbmNlIHR5cGUgc2hvdWxkIGRlZmluZSBhdCBsZWFzdCBvbmUgcmVmZXJlbmNlZCB0eXBlLiBQbGVhc2UgY2hlY2sgdGhlIFwidG9cIiBwcm9wZXJ0eS4nLFxuICAgICAgSEVMUF9JRFMuQ1JPU1NfREFUQVNFVF9SRUZFUkVOQ0VfSU5WQUxJRFxuICAgIClcbiAgKSwgbm9ybWFsaXplZFRvLmZvckVhY2goKGNyb3NzRGF0YXNldFR5cGVEZWYsIGluZGV4KSA9PiB7XG4gICAgY3Jvc3NEYXRhc2V0VHlwZURlZi50eXBlIHx8IHByb2JsZW1zLnB1c2goXG4gICAgICBlcnJvcihcbiAgICAgICAgYFRoZSByZWZlcmVuY2VkIHR5cGUgYXQgaW5kZXggJHtpbmRleH0gbXVzdCBiZSBuYW1lZC4gU3BlY2lmeSB0aGUgbmFtZSBvZiB0aGUgdHlwZSB5b3Ugd2FudCB0byBjcmVhdGUgcmVmZXJlbmNlcyB0by5gLFxuICAgICAgICBIRUxQX0lEUy5DUk9TU19EQVRBU0VUX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgICApXG4gICAgKSwgaXNQbGFpbk9iamVjdChjcm9zc0RhdGFzZXRUeXBlRGVmLnByZXZpZXcpIHx8IHByb2JsZW1zLnB1c2goXG4gICAgICBlcnJvcihcbiAgICAgICAgYE1pc3NpbmcgcmVxdWlyZWQgcHJldmlldyBjb25maWcgZm9yIHRoZSByZWZlcmVuY2VkIHR5cGUgXCIke2Nyb3NzRGF0YXNldFR5cGVEZWYudHlwZSB8fCBcIjx1bmtub3duIHR5cGU+XCJ9XCJgLFxuICAgICAgICBIRUxQX0lEUy5DUk9TU19EQVRBU0VUX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgICApXG4gICAgKTtcbiAgfSksIHR5cGVvZiB0eXBlRGVmLmRhdGFzZXQgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGRhdGFzZXRWYWxpZGF0aW9uID0gaXNWYWxpZERhdGFzZXROYW1lKHR5cGVEZWYuZGF0YXNldCk7XG4gICAgZGF0YXNldFZhbGlkYXRpb24gIT09ICEwICYmIHByb2JsZW1zLnB1c2goZXJyb3IoZGF0YXNldFZhbGlkYXRpb24sIEhFTFBfSURTLkNST1NTX0RBVEFTRVRfUkVGRVJFTkNFX0lOVkFMSUQpKTtcbiAgfSBlbHNlXG4gICAgcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBcIkEgY3Jvc3MgZGF0YXNldCByZWZlcmVuY2UgbXVzdCBzcGVjaWZ5IGEgYGRhdGFzZXRgXCIsXG4gICAgICAgIEhFTFBfSURTLkNST1NTX0RBVEFTRVRfUkVGRVJFTkNFX0lOVkFMSURcbiAgICAgIClcbiAgICApO1xuICByZXR1cm4gdHlwZURlZi5zdHVkaW9VcmwgJiYgdHlwZW9mIHR5cGVEZWYuc3R1ZGlvVXJsICE9IFwiZnVuY3Rpb25cIiAmJiBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKFxuICAgICAgJ1RoZSBcInN0dWRpb1VybFwiIHByb3BlcnR5IG9uIGEgY3Jvc3MgZGF0YXNldCByZWZlcmVuY2UgbXVzdCBiZSBhIGZ1bmN0aW9uIHRha2luZyBcIntpZCwgdHlwZX1cIiBhcyBhcmd1bWVudCBhbmQgcmV0dXJuaW5nIGEgc3R1ZGlvIHVybC4nLFxuICAgICAgSEVMUF9JRFMuQ1JPU1NfREFUQVNFVF9SRUZFUkVOQ0VfSU5WQUxJRFxuICAgIClcbiAgKSwgcHJvYmxlbXMucHVzaCguLi5nZXRPcHRpb25FcnJvcnMkMih0eXBlRGVmKSksIHtcbiAgICAuLi50eXBlRGVmLFxuICAgIF9wcm9ibGVtczogcHJvYmxlbXNcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRPcHRpb25FcnJvcnMkMih0eXBlRGVmKSB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gdHlwZURlZiwgcHJvYmxlbXMgPSBbXTtcbiAgcmV0dXJuIHByb2JsZW1zLnB1c2goXG4gICAgLi4uW1wiZmlsdGVyXCIsIFwiZmlsdGVyUGFyYW1zXCJdLmZpbHRlcigoa2V5KSA9PiBrZXkgaW4gdHlwZURlZikubWFwKFxuICAgICAgKGtleSkgPT4gZXJyb3IoXG4gICAgICAgIGBcXGAke2tleX1cXGAgaXMgbm90IGFsbG93ZWQgb24gYSByZWZlcmVuY2UgdHlwZSBkZWZpbml0aW9uIC0gZGlkIHlvdSBtZWFuIFxcYG9wdGlvbnMuJHtrZXl9XFxgP2AsXG4gICAgICAgIEhFTFBfSURTLlJFRkVSRU5DRV9JTlZBTElEX09QVElPTlNfTE9DQVRJT05cbiAgICAgIClcbiAgICApXG4gICksIG9wdGlvbnMgPyBpc1BsYWluT2JqZWN0KG9wdGlvbnMpID8gdHlwZW9mIG9wdGlvbnMuZmlsdGVyID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJQYXJhbXMgPCBcInVcIiA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihcbiAgICAgIFwiYGZpbHRlclBhcmFtc2AgY2Fubm90IGJlIHVzZWQgaWYgYGZpbHRlcmAgaXMgYSBmdW5jdGlvbi4gRWl0aGVyIHN0YXRpY2FsbHkgZGVmaW5lIGBmaWx0ZXJgIGFzIGEgc3RyaW5nLCBvciByZXR1cm4gYHBhcmFtc2AgZnJvbSB0aGUgYGZpbHRlcmAtZnVuY3Rpb24uXCIsXG4gICAgICBIRUxQX0lEUy5SRUZFUkVOQ0VfSU5WQUxJRF9GSUxURVJfUEFSQU1TX0NPTUJJTkFUSU9OXG4gICAgKVxuICApIDogdHlwZW9mIG9wdGlvbnMuZmlsdGVyID09IFwiZnVuY3Rpb25cIiB8fCAhb3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyUGFyYW1zID8gcHJvYmxlbXMgOiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgIT0gXCJzdHJpbmdcIiA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihgSWYgc2V0LCBcXGBmaWx0ZXJcXGAgbXVzdCBiZSBhIHN0cmluZy4gR290ICR7dHlwZW9mIG9wdGlvbnMuZmlsdGVyfWApXG4gICkgOiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJQYXJhbXMgPCBcInVcIiAmJiAhaXNQbGFpbk9iamVjdChvcHRpb25zLmZpbHRlclBhcmFtcykgPyBwcm9ibGVtcy5jb25jYXQoZXJyb3IoXCJJZiBzZXQsIGBmaWx0ZXJQYXJhbXNgIG11c3QgYmUgYW4gb2JqZWN0LlwiKSkgOiBvcHRpb25zLmZpbHRlclBhcmFtcyA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmZpbHRlclBhcmFtcykuZmlsdGVyKChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwiX19cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCIkXCIpKS5tYXAoKGtleSkgPT4gZXJyb3IoYEZpbHRlciBwYXJhbWV0ZXIgY2Fubm90IGJlIHByZWZpeGVkIHdpdGggXCIkXCIgb3IgXCJfX1wiLiBHb3QgJHtrZXl9XCIuYCkpXG4gICkgOiBwcm9ibGVtcyA6IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihcbiAgICAgIFwiVGhlIHJlZmVyZW5jZSB0eXBlIGV4cGVjdHMgYG9wdGlvbnNgIHRvIGJlIGFuIG9iamVjdFwiLFxuICAgICAgSEVMUF9JRFMuUkVGRVJFTkNFX0lOVkFMSURfT1BUSU9OU1xuICAgIClcbiAgKSA6IHByb2JsZW1zO1xufVxuY29uc3QgUkVBQ1RfU1lNX1JFID0gL15TeW1ib2xcXChyZWFjdFxcLi4rXFwpJC87XG5mdW5jdGlvbiBpc0NvbXBvbmVudExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHZhbHVlPy4kJHR5cGVvZiA9PSBcInN5bWJvbFwiICYmIFJFQUNUX1NZTV9SRS50ZXN0KFN0cmluZyh2YWx1ZT8uJCR0eXBlb2YpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50KHR5cGVEZWYpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFwiY29tcG9uZW50c1wiIGluIHR5cGVEZWYgPyB0eXBlRGVmLmNvbXBvbmVudHMgOiAhMTtcbiAgaWYgKCFjb21wb25lbnRzKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgcmV0dXJuIGNvbXBvbmVudHMuaW5wdXQgJiYgIWlzQ29tcG9uZW50TGlrZShjb21wb25lbnRzLmlucHV0KSAmJiB3YXJuaW5ncy5wdXNoKFxuICAgIHdhcm5pbmcoXG4gICAgICBgVGhlIFxcYGNvbXBvbmVudHMuaW5wdXRcXGAgcHJvcGVydHkgaXMgc2V0IGJ1dCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBSZWFjdCBjb21wb25lbnQgKGV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCBzYXcgJHtpbnNwZWN0KFxuICAgICAgICBjb21wb25lbnRzLmlucHV0XG4gICAgICApfSkuIElmIHlvdSBoYXZlIGltcG9ydGVkIGEgY3VzdG9tIGlucHV0IGNvbXBvbmVudCwgcGxlYXNlIHZlcmlmeSB0aGF0IHlvdSBoYXZlIGltcG9ydGVkIHRoZSBjb3JyZWN0IG5hbWVkL2RlZmF1bHQgZXhwb3J0LmBcbiAgICApXG4gICksIGNvbXBvbmVudHMuZmllbGQgJiYgIWlzQ29tcG9uZW50TGlrZShjb21wb25lbnRzLmZpZWxkKSAmJiB3YXJuaW5ncy5wdXNoKFxuICAgIHdhcm5pbmcoXG4gICAgICBgVGhlIFxcYGNvbXBvbmVudHMuZmllbGRcXGAgcHJvcGVydHkgaXMgc2V0IGJ1dCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBSZWFjdCBjb21wb25lbnQgKGV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCBzYXcgJHtpbnNwZWN0KFxuICAgICAgICBjb21wb25lbnRzLmZpZWxkXG4gICAgICApfSkuIElmIHlvdSBoYXZlIGltcG9ydGVkIGEgY3VzdG9tIGZpZWxkIGNvbXBvbmVudCwgcGxlYXNlIHZlcmlmeSB0aGF0IHlvdSBoYXZlIGltcG9ydGVkIHRoZSBjb3JyZWN0IG5hbWVkL2RlZmF1bHQgZXhwb3J0LmBcbiAgICApXG4gICksIGNvbXBvbmVudHMuaXRlbSAmJiAhaXNDb21wb25lbnRMaWtlKGNvbXBvbmVudHMuaXRlbSkgJiYgd2FybmluZ3MucHVzaChcbiAgICB3YXJuaW5nKFxuICAgICAgYFRoZSBcXGBjb21wb25lbnRzLml0ZW1cXGAgcHJvcGVydHkgaXMgc2V0IGJ1dCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBSZWFjdCBjb21wb25lbnQgKGV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCBzYXcgJHtpbnNwZWN0KFxuICAgICAgICBjb21wb25lbnRzLml0ZW1cbiAgICAgICl9KS4gSWYgeW91IGhhdmUgaW1wb3J0ZWQgYSBjdXN0b20gaXRlbSBjb21wb25lbnQsIHBsZWFzZSB2ZXJpZnkgdGhhdCB5b3UgaGF2ZSBpbXBvcnRlZCB0aGUgY29ycmVjdCBuYW1lZC9kZWZhdWx0IGV4cG9ydC5gXG4gICAgKVxuICApLCBjb21wb25lbnRzLnByZXZpZXcgJiYgIWlzQ29tcG9uZW50TGlrZShjb21wb25lbnRzLnByZXZpZXcpICYmIHdhcm5pbmdzLnB1c2goXG4gICAgd2FybmluZyhcbiAgICAgIGBUaGUgXFxgY29tcG9uZW50cy5wcmV2aWV3XFxgIHByb3BlcnR5IGlzIHNldCBidXQgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgUmVhY3QgY29tcG9uZW50IChleHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgc2F3ICR7aW5zcGVjdChcbiAgICAgICAgY29tcG9uZW50cy5wcmV2aWV3XG4gICAgICApfSkuIElmIHlvdSBoYXZlIGltcG9ydGVkIGEgY3VzdG9tIHByZXZpZXcgY29tcG9uZW50LCBwbGVhc2UgdmVyaWZ5IHRoYXQgeW91IGhhdmUgaW1wb3J0ZWQgdGhlIGNvcnJlY3QgbmFtZWQvZGVmYXVsdCBleHBvcnQuYFxuICAgIClcbiAgKSwgd2FybmluZ3M7XG59XG5jb25zdCBWQUxJRF9GSUVMRF9SRSA9IC9eW0EtWmEtel0rWzAtOUEtWmEtel9dKiQvLCBDT05WRU5USU9OQUxfRklFTERfUkUgPSAvXltBLVphLXpfXStbMC05QS1aYS16X10qJC87XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkTmFtZShuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgbmFtZSAhPSBcInN0cmluZ1wiID8gW1xuICAgIGVycm9yKFxuICAgICAgYEZpZWxkIG5hbWVzIG11c3QgYmUgc3RyaW5ncy4gU2F3IFwiJHtpbnNwZWN0KG5hbWUpfVwiYCxcbiAgICAgIEhFTFBfSURTLk9CSkVDVF9GSUVMRF9OQU1FX0lOVkFMSURcbiAgICApXG4gIF0gOiBuYW1lLnN0YXJ0c1dpdGgoXCJfXCIpID8gW1xuICAgIGVycm9yKFxuICAgICAgYEludmFsaWQgZmllbGQgbmFtZSBcIiR7bmFtZX1cIi4gRmllbGQgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggdW5kZXJzY29yZXMgXCJfXCIgYXMgaXQncyByZXNlcnZlZCBmb3Igc3lzdGVtIGZpZWxkcy5gLFxuICAgICAgSEVMUF9JRFMuT0JKRUNUX0ZJRUxEX05BTUVfSU5WQUxJRFxuICAgIClcbiAgXSA6IFZBTElEX0ZJRUxEX1JFLnRlc3QobmFtZSkgPyBDT05WRU5USU9OQUxfRklFTERfUkUudGVzdChuYW1lKSA/IFtdIDogW1xuICAgIHdhcm5pbmcoXG4gICAgICBcIlRoYXRzIGFuIGludGVyZXN0aW5nIGZpZWxkIG5hbWUgZm9yIHN1cmUhIEJ1dCBpdCBpcy4uLiBob3cgdG8gcHV0IGl0Li4uIGEgYml0Li4uIHVuY29udmVudGlvbmFsPyBJdCBtYXkgYmUgd2lzZSB0byBrZWVwIHNwZWNpYWwgY2hhcmFjdGVycyBvdXQgb2YgZmllbGQgbmFtZXMgZm9yIGVhc2llciBhY2Nlc3MgbGF0ZXIgb24uXCJcbiAgICApLFxuICAgIEhFTFBfSURTLk9CSkVDVF9GSUVMRF9OQU1FX0lOVkFMSURcbiAgXSA6IFtcbiAgICBlcnJvcihcbiAgICAgIGBJbnZhbGlkIGZpZWxkIG5hbWU6IFwiJHtuYW1lfVwiLiBGaWVsZHMgY2FuIG9ubHkgY29udGFpbiBjaGFyYWN0ZXJzIGZyb20gQS1aLCBudW1iZXJzIGFuZCB1bmRlcnNjb3JlcyBhbmQgc2hvdWxkIG5vdCBzdGFydCB3aXRoIGEgbnVtYmVyIChtdXN0IHBhc3MgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAke1N0cmluZyhcbiAgICAgICAgVkFMSURfRklFTERfUkVcbiAgICAgICl9KS5gLFxuICAgICAgSEVMUF9JRFMuT0JKRUNUX0ZJRUxEX05BTUVfSU5WQUxJRFxuICAgIClcbiAgXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQsIF92aXNpdG9yQ29udGV4dCkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZmllbGQpKVxuICAgIHJldHVybiBbXG4gICAgICBlcnJvcihcbiAgICAgICAgYEluY29ycmVjdCB0eXBlIGZvciBmaWVsZCBkZWZpbml0aW9uIC0gc2hvdWxkIGJlIGFuIG9iamVjdCwgc2F3ICR7aW5zcGVjdChmaWVsZCl9YCxcbiAgICAgICAgSEVMUF9JRFMuT0JKRUNUX0ZJRUxEX0RFRklOSVRJT05fSU5WQUxJRF9UWVBFXG4gICAgICApXG4gICAgXTtcbiAgY29uc3QgcHJvYmxlbXMgPSBbXTtcbiAgcmV0dXJuIHByb2JsZW1zLnB1c2goXG4gICAgLi4uXCJuYW1lXCIgaW4gZmllbGQgPyB2YWxpZGF0ZUZpZWxkTmFtZShmaWVsZC5uYW1lKSA6IFtlcnJvcihcIk1pc3NpbmcgZmllbGQgbmFtZVwiLCBIRUxQX0lEUy5PQkpFQ1RfRklFTERfTkFNRV9JTlZBTElEKV1cbiAgKSwgcHJvYmxlbXMucHVzaCguLi52YWxpZGF0ZUNvbXBvbmVudChmaWVsZCkpLCBwcm9ibGVtcztcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZUZpZWxkcyhhcnJheTIpIHtcbiAgY29uc3QgZHVwZXMgPSB7fTtcbiAgcmV0dXJuIGFycmF5Mi5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGR1cGVzW2ZpZWxkLm5hbWVdIHx8IChkdXBlc1tmaWVsZC5uYW1lXSA9IFtdKSwgZHVwZXNbZmllbGQubmFtZV0ucHVzaChmaWVsZCk7XG4gIH0pLCBPYmplY3Qua2V5cyhkdXBlcykubWFwKChmaWVsZE5hbWUpID0+IGR1cGVzW2ZpZWxkTmFtZV0ubGVuZ3RoID4gMSA/IGR1cGVzW2ZpZWxkTmFtZV0gOiBudWxsKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkcyhmaWVsZHMsIG9wdGlvbnMgPSB7IGFsbG93RW1wdHk6ICExIH0pIHtcbiAgY29uc3QgcHJvYmxlbXMgPSBbXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkcykpXG4gICAgcmV0dXJuIFtcbiAgICAgIGVycm9yKFxuICAgICAgICBgVGhlIFwiZmllbGRzXCIgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheSBvZiBmaWVsZHMuIEluc3RlYWQgc2F3IFwiJHt0eXBlb2YgZmllbGRzfVwiYCxcbiAgICAgICAgSEVMUF9JRFMuT0JKRUNUX0ZJRUxEU19JTlZBTElEXG4gICAgICApXG4gICAgXTtcbiAgY29uc3QgZmllbGRzV2l0aE5hbWVzID0gZmllbGRzLmZpbHRlcigoZmllbGQpID0+IHR5cGVvZiBmaWVsZC5uYW1lID09IFwic3RyaW5nXCIpO1xuICBnZXREdXBsaWNhdGVGaWVsZHMoZmllbGRzV2l0aE5hbWVzKS5mb3JFYWNoKChkdXBlcykgPT4ge1xuICAgIHByb2JsZW1zLnB1c2goXG4gICAgICBlcnJvcihcbiAgICAgICAgYEZvdW5kICR7ZHVwZXMubGVuZ3RofSBmaWVsZHMgd2l0aCBuYW1lIFwiJHtkdXBlc1swXS5uYW1lfVwiIGluIG9iamVjdGAsXG4gICAgICAgIEhFTFBfSURTLk9CSkVDVF9GSUVMRF9OT1RfVU5JUVVFXG4gICAgICApXG4gICAgKTtcbiAgfSksIGZpZWxkcy5sZW5ndGggPT09IDAgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSAmJiBwcm9ibGVtcy5wdXNoKGVycm9yKFwiT2JqZWN0IHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBmaWVsZFwiLCBIRUxQX0lEUy5PQkpFQ1RfRklFTERTX0lOVkFMSUQpKTtcbiAgY29uc3Qgc3RhbmRhbG9uZUJsb2NrRmllbGRzID0gZmllbGRzLmZpbHRlcigoZmllbGQpID0+IGZpZWxkLnR5cGUgPT09IFwiYmxvY2tcIikubWFwKChmaWVsZCkgPT4gYFwiJHtmaWVsZC5uYW1lfVwiYCk7XG4gIGlmIChzdGFuZGFsb25lQmxvY2tGaWVsZHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGZtdEZpZWxkcyA9IHN0YW5kYWxvbmVCbG9ja0ZpZWxkcy5qb2luKFwiLCBcIik7XG4gICAgcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBgSW52YWxpZCBzdGFuZGFsb25lIGJsb2NrIGZpZWxkKHMpICR7Zm10RmllbGRzfS4gQmxvY2sgY29udGVudCBtdXN0IGJlIGRlZmluZWQgYXMgYW4gYXJyYXkgb2YgYmxvY2tzYCxcbiAgICAgICAgSEVMUF9JRFMuU1RBTkRBTE9ORV9CTE9DS19UWVBFXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcHJvYmxlbXM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVByZXZpZXcocHJldmlldykge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdChwcmV2aWV3KSA/IHR5cGVvZiBwcmV2aWV3LnByZXBhcmUgPCBcInVcIiAmJiB0eXBlb2YgcHJldmlldy5wcmVwYXJlICE9IFwiZnVuY3Rpb25cIiA/IFtcbiAgICBlcnJvcihcbiAgICAgIGBUaGUgXCJwcmV2aWV3LnByZXBhcmVcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgc2F3IFwiJHt0eXBlb2YgcHJldmlldy5wcmVwYXJlfVwiYFxuICAgIClcbiAgXSA6IHByZXZpZXcuc2VsZWN0ID8gaXNQbGFpbk9iamVjdChwcmV2aWV3LnNlbGVjdCkgPyBPYmplY3Qua2V5cyhwcmV2aWV3LnNlbGVjdCkucmVkdWNlKChlcnJzLCBrZXkpID0+IHR5cGVvZiBwcmV2aWV3LnNlbGVjdFtrZXldID09IFwic3RyaW5nXCIgPyBlcnJzIDogZXJycy5jb25jYXQoXG4gICAgZXJyb3IoXG4gICAgICBgVGhlIGtleSBcIiR7a2V5fVwiIG9mIFwicHJldmlldy5zZWxlY3RcIiBtdXN0IGJlIGEgc3RyaW5nLCBpbnN0ZWFkIHNhdyBcIiR7dHlwZW9mIHByZXZpZXcuc2VsZWN0W2tleV19XCJgXG4gICAgKVxuICApLCBbXSkgOiBbXG4gICAgZXJyb3IoXG4gICAgICBgVGhlIFwicHJldmlldy5zZWxlY3RcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCwgaW5zdGVhZCBzYXcgXCIke3R5cGVvZiBwcmV2aWV3LnByZXBhcmV9XCJgXG4gICAgKVxuICBdIDogW10gOiBbZXJyb3IoYFRoZSBcInByZXZpZXdcIiBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCwgaW5zdGVhZCBzYXcgXCIke3R5cGVvZiBwcmV2aWV3fVwiYCldO1xufVxudmFyIG9iamVjdCA9ICh0eXBlRGVmLCB2aXNpdG9yQ29udGV4dCkgPT4ge1xuICBsZXQgcHJvYmxlbXMgPSB2YWxpZGF0ZUZpZWxkcyh0eXBlRGVmLmZpZWxkcyksIHByZXZpZXcgPSB0eXBlRGVmLnByZXZpZXc7XG4gIGlmIChwcmV2aWV3KSB7XG4gICAgY29uc3QgcHJldmlld0Vycm9ycyA9IHZhbGlkYXRlUHJldmlldyh0eXBlRGVmLnByZXZpZXcpO1xuICAgIHByb2JsZW1zID0gcHJvYmxlbXMuY29uY2F0KHByZXZpZXdFcnJvcnMpLCBwcmV2aWV3ID0gcHJldmlld0Vycm9ycy5zb21lKChlcnIpID0+IGVyci5zZXZlcml0eSA9PT0gXCJlcnJvclwiKSA/IHt9IDogcHJldmlldztcbiAgfVxuICByZXR1cm4gdHlwZURlZi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgdHlwZURlZi50eXBlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0eXBlRGVmLmluaXRpYWxWYWx1ZSA8IFwidVwiICYmIHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoJ1RoZSBcImluaXRpYWxWYWx1ZVwiIHByb3BlcnR5IGlzIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBmb3IgZG9jdW1lbnQgJiBvYmplY3QgdHlwZXMuJylcbiAgKSwge1xuICAgIC4uLnR5cGVEZWYsXG4gICAgcHJldmlldyxcbiAgICBmaWVsZHM6IChBcnJheS5pc0FycmF5KHR5cGVEZWYuZmllbGRzKSA/IHR5cGVEZWYuZmllbGRzIDogW10pLm1hcCgoZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLmZpZWxkVHlwZURlZiB9ID0gZmllbGQsIHsgX3Byb2JsZW1zLCAuLi5maWVsZFR5cGUgfSA9IHZpc2l0b3JDb250ZXh0LnZpc2l0KGZpZWxkVHlwZURlZiwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4uZmllbGRUeXBlLFxuICAgICAgICBfcHJvYmxlbXM6IHZhbGlkYXRlRmllbGQoZmllbGQpLmNvbmNhdChfcHJvYmxlbXMgfHwgW10pXG4gICAgICB9O1xuICAgIH0pLFxuICAgIF9wcm9ibGVtczogcHJvYmxlbXNcbiAgfTtcbn0sIGRvY3VtZW50VmlzaXRvciA9ICh0eXBlRGVmaW5pdGlvbiwgdmlzaXRvckNvbnRleHQpID0+IHtcbiAgY29uc3QgdHlwZURlZiA9IG9iamVjdCh0eXBlRGVmaW5pdGlvbiwgdmlzaXRvckNvbnRleHQpLCB7IGluaXRpYWxWYWx1ZSwgaW5pdGlhbFZhbHVlcyB9ID0gdHlwZURlZjtcbiAgcmV0dXJuIHR5cGVvZiBpbml0aWFsVmFsdWUgPCBcInVcIiAmJiAhaXNQbGFpbk9iamVjdChpbml0aWFsVmFsdWUpICYmIHR5cGVvZiBpbml0aWFsVmFsdWUgIT0gXCJmdW5jdGlvblwiICYmIHR5cGVEZWYuX3Byb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoJ1RoZSBcImluaXRpYWxWYWx1ZVwiIHByb3BlcnR5IG11c3QgYmUgZWl0aGVyIGEgcGxhaW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24nKVxuICApLCB0eXBlb2YgaW5pdGlhbFZhbHVlcyA8IFwidVwiICYmIHR5cGVEZWYuX3Byb2JsZW1zLnB1c2goZXJyb3IoJ0ZvdW5kIHByb3BlcnR5IFwiaW5pdGlhbFZhbHVlc1wiIC0gZGlkIHlvdSBtZWFuIFwiaW5pdGlhbFZhbHVlXCI/JykpLCB0eXBlRGVmO1xufSwgZmlsZSA9ICh0eXBlRGVmLCB2aXNpdG9yQ29udGV4dCkgPT4ge1xuICBjb25zdCBwcm9ibGVtcyA9IFtdLCBmaWVsZHMgPSB0eXBlRGVmLmZpZWxkcztcbiAgZmllbGRzICYmIHByb2JsZW1zLnB1c2goLi4udmFsaWRhdGVGaWVsZHMoZmllbGRzLCB7IGFsbG93RW1wdHk6ICEwIH0pKTtcbiAgY29uc3QgaW52YWxpZEZpZWxkTmFtZXMgPSBBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHM/LmZpbHRlcigoZmllbGQpID0+IGZpZWxkLm5hbWUgPT09IFwiYXNzZXRcIikgOiBbXTtcbiAgcmV0dXJuIHR5cGVEZWYub3B0aW9ucyAmJiB0eXBlb2YgdHlwZURlZi5vcHRpb25zLm1ldGFkYXRhIDwgXCJ1XCIgJiYgIUFycmF5LmlzQXJyYXkodHlwZURlZi5vcHRpb25zLm1ldGFkYXRhKSA/IHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICBcIkludmFsaWQgdHlwZSBmb3IgZmlsZSBgbWV0YWRhdGFgIGZpZWxkIC0gbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIsXG4gICAgICBIRUxQX0lEUy5BU1NFVF9NRVRBREFUQV9GSUVMRF9JTlZBTElEXG4gICAgKVxuICApIDogaW52YWxpZEZpZWxkTmFtZXMubGVuZ3RoID4gMCAmJiBwcm9ibGVtcy5wdXNoKGVycm9yKFwiVGhlIG5hbWUgYGFzc2V0YCBpcyBub3QgYSB2YWxpZCBmaWVsZCBuYW1lIGZvciB0eXBlIGBmaWxlYC5cIikpLCB7XG4gICAgLi4udHlwZURlZixcbiAgICBmaWVsZHM6IChBcnJheS5pc0FycmF5KGZpZWxkcykgPyBmaWVsZHMgOiBbXSkubWFwKChmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgLi4uZmllbGRUeXBlRGVmIH0gPSBmaWVsZCwgeyBfcHJvYmxlbXMsIC4uLmZpZWxkVHlwZSB9ID0gdmlzaXRvckNvbnRleHQudmlzaXQoZmllbGRUeXBlRGVmLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICAuLi5maWVsZFR5cGUsXG4gICAgICAgIF9wcm9ibGVtczogdmFsaWRhdGVGaWVsZChmaWVsZCkuY29uY2F0KF9wcm9ibGVtcyB8fCBbXSlcbiAgICAgIH07XG4gICAgfSksXG4gICAgX3Byb2JsZW1zOiBwcm9ibGVtc1xuICB9O1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVRvUHJvcCQxKHR5cGVEZWYpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHlwZURlZi50bykgPyB0eXBlRGVmLnRvIDogdHlwZURlZi50byA/IFt0eXBlRGVmLnRvXSA6IFtdO1xufVxuZnVuY3Rpb24gaXNWYWxpZFJlc291cmNlVHlwZShyZXNvdXJjZVR5cGUpIHtcbiAgcmV0dXJuIHJlc291cmNlVHlwZSA/IHJlc291cmNlVHlwZSAhPSBcIm1lZGlhLWxpYnJhcnlcIiAmJiByZXNvdXJjZVR5cGUgIT0gXCJkYXRhc2V0XCIgPyAnVGhlIHJlc291cmNlIHR5cGUgbXVzdCBiZSBlaXRoZXIgXCJtZWRpYS1saWJyYXJ5XCIgb3IgXCJkYXRhc2V0XCInIDogITAgOiBcIlRoZSByZXNvdXJjZSB0eXBlIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1ZhbGlkUmVzb3VyY2VJZChyZXNvdXJjZVR5cGUsIHJlc291cmNlSWQpIHtcbiAgcmV0dXJuIHJlc291cmNlSWQgPyByZXNvdXJjZVR5cGUgPT09IFwiZGF0YXNldFwiID8gcmVzb3VyY2VJZC5zcGxpdChcIi5cIikubGVuZ3RoICE9PSAyID8gJ1RoZSByZXNvdXJjZSBJRCBmb3IgYSBkYXRhc2V0IHJlZmVyZW5jZSBtdXN0IGJlIG9uIHRoZSBmb3JtIFwiPHByb2plY3RJZD4uPGRhdGFzZXROYW1lPlwiJyA6ICEwIDogcmVzb3VyY2VUeXBlID09PSBcIm1lZGlhLWxpYnJhcnlcIiA/ICEwIDogYENhbm5vdCB2YWxpZGF0ZSByZXNvdXJjZSBJRCBmb3IgcmVzb3VyY2UgdHlwZTogJHtyZXNvdXJjZVR5cGV9YCA6IFwiVGhlIHJlc291cmNlIElEIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCI7XG59XG52YXIgZ2xvYmFsRG9jdW1lbnRSZWZlcmVuY2UgPSAodHlwZURlZiwgdmlzaXRvckNvbnRleHQpID0+IHtcbiAgY29uc3QgaXNWYWxpZFRvID0gQXJyYXkuaXNBcnJheSh0eXBlRGVmLnRvKSB8fCBpc1BsYWluT2JqZWN0KHR5cGVEZWYudG8pLCBub3JtYWxpemVkVG8gPSBub3JtYWxpemVUb1Byb3AkMSh0eXBlRGVmKSwgcHJvYmxlbXMgPSBmbGF0dGVuKFtcbiAgICBpc1ZhbGlkVG8gPyBnZXREdXBlcyhub3JtYWxpemVkVG8sICh0KSA9PiBgJHt0Lm5hbWV9OyR7dC50eXBlfWApLm1hcChcbiAgICAgIChkdXBlcykgPT4gZXJyb3IoXG4gICAgICAgIGBGb3VuZCAke2R1cGVzLmxlbmd0aH0gbWVtYmVycyB3aXRoIHNhbWUgdHlwZSwgYnV0IG5vdCB1bmlxdWUgbmFtZXMgXCIke2R1cGVzWzBdLnR5cGV9XCIgaW4gcmVmZXJlbmNlLiBUaGlzIG1ha2VzIGl0IGltcG9zc2libGUgdG8gdGVsbCB0aGVpciB2YWx1ZXMgYXBhcnQgYW5kIHlvdSBzaG91bGQgY29uc2lkZXIgbmFtaW5nIHRoZW1gLFxuICAgICAgICBIRUxQX0lEUy5HTE9CQUxfRE9DVU1FTlRfUkVGRVJFTkNFX0lOVkFMSURcbiAgICAgIClcbiAgICApIDogZXJyb3IoXG4gICAgICAnVGhlIGdsb2JhbCBkb2N1bWVudCByZWZlcmVuY2UgdHlwZSBpcyBtaXNzaW5nIG9yIGhhdmluZyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgcmVxdWlyZWQgXCJ0b1wiIHByb3BlcnR5LiBJdCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgYWNjZXB0ZWQgdHlwZXMuJyxcbiAgICAgIEhFTFBfSURTLkdMT0JBTF9ET0NVTUVOVF9SRUZFUkVOQ0VfSU5WQUxJRFxuICAgIClcbiAgXSk7XG4gIGlmIChpc1ZhbGlkVG8gJiYgbm9ybWFsaXplZFRvLmxlbmd0aCA9PT0gMCAmJiBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKFxuICAgICAgJ1RoZSBnbG9iYWwgZG9jdW1lbnQgcmVmZXJlbmNlIHR5cGUgc2hvdWxkIGRlZmluZSBhdCBsZWFzdCBvbmUgcmVmZXJlbmNlZCB0eXBlLiBQbGVhc2UgY2hlY2sgdGhlIFwidG9cIiBwcm9wZXJ0eS4nLFxuICAgICAgSEVMUF9JRFMuR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgKVxuICApLCBub3JtYWxpemVkVG8uZm9yRWFjaCgoY3Jvc3NEYXRhc2V0VHlwZURlZiwgaW5kZXgpID0+IHtcbiAgICBjcm9zc0RhdGFzZXRUeXBlRGVmLnR5cGUgfHwgcHJvYmxlbXMucHVzaChcbiAgICAgIGVycm9yKFxuICAgICAgICBgVGhlIHJlZmVyZW5jZWQgdHlwZSBhdCBpbmRleCAke2luZGV4fSBtdXN0IGJlIG5hbWVkLiBTcGVjaWZ5IHRoZSBuYW1lIG9mIHRoZSB0eXBlIHlvdSB3YW50IHRvIGNyZWF0ZSByZWZlcmVuY2VzIHRvLmAsXG4gICAgICAgIEhFTFBfSURTLkdMT0JBTF9ET0NVTUVOVF9SRUZFUkVOQ0VfSU5WQUxJRFxuICAgICAgKVxuICAgICksIGlzUGxhaW5PYmplY3QoY3Jvc3NEYXRhc2V0VHlwZURlZi5wcmV2aWV3KSB8fCBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIGBNaXNzaW5nIHJlcXVpcmVkIHByZXZpZXcgY29uZmlnIGZvciB0aGUgcmVmZXJlbmNlZCB0eXBlIFwiJHtjcm9zc0RhdGFzZXRUeXBlRGVmLnR5cGUgfHwgXCI8dW5rbm93biB0eXBlPlwifVwiYCxcbiAgICAgICAgSEVMUF9JRFMuR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgICApXG4gICAgKTtcbiAgfSksIHR5cGVvZiB0eXBlRGVmLnJlc291cmNlVHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IGlzVmFsaWRSZXNvdXJjZVR5cGUodHlwZURlZi5yZXNvdXJjZVR5cGUpO1xuICAgIHZhbGlkYXRpb24gIT09ICEwICYmIHByb2JsZW1zLnB1c2goZXJyb3IodmFsaWRhdGlvbiwgSEVMUF9JRFMuR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9JTlZBTElEKSk7XG4gIH0gZWxzZVxuICAgIHByb2JsZW1zLnB1c2goXG4gICAgICBlcnJvcihcbiAgICAgICAgXCJBIGdsb2JhbCBkb2N1bWVudCByZWZlcmVuY2UgbXVzdCBzcGVjaWZ5IGEgYHJlc291cmNlVHlwZWBcIixcbiAgICAgICAgSEVMUF9JRFMuR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9JTlZBTElEXG4gICAgICApXG4gICAgKTtcbiAgaWYgKHR5cGVvZiB0eXBlRGVmLnJlc291cmNlSWQgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGRhdGFzZXRWYWxpZGF0aW9uID0gaXNWYWxpZFJlc291cmNlSWQodHlwZURlZi5yZXNvdXJjZVR5cGUsIHR5cGVEZWYucmVzb3VyY2VJZCk7XG4gICAgZGF0YXNldFZhbGlkYXRpb24gIT09ICEwICYmIHByb2JsZW1zLnB1c2goZXJyb3IoZGF0YXNldFZhbGlkYXRpb24sIEhFTFBfSURTLkdMT0JBTF9ET0NVTUVOVF9SRUZFUkVOQ0VfSU5WQUxJRCkpO1xuICB9IGVsc2VcbiAgICBwcm9ibGVtcy5wdXNoKFxuICAgICAgZXJyb3IoXG4gICAgICAgIFwiQSBnbG9iYWwgZG9jdW1lbnQgcmVmZXJlbmNlIG11c3Qgc3BlY2lmeSBhIGByZXNvdXJjZUlkYFwiLFxuICAgICAgICBIRUxQX0lEUy5HTE9CQUxfRE9DVU1FTlRfUkVGRVJFTkNFX0lOVkFMSURcbiAgICAgIClcbiAgICApO1xuICByZXR1cm4gdHlwZURlZi5zdHVkaW9VcmwgJiYgdHlwZW9mIHR5cGVEZWYuc3R1ZGlvVXJsICE9IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdHlwZURlZi5zdHVkaW9VcmwgIT0gXCJzdHJpbmdcIiAmJiBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKFxuICAgICAgJ1RoZSBcInN0dWRpb1VybFwiIHByb3BlcnR5IG9uIGEgZ2xvYmFsIGRvY3VtZW50IHJlZmVyZW5jZSBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIHRha2luZyBcIntpZCwgdHlwZX1cIiBhcyBhcmd1bWVudCBhbmQgcmV0dXJuaW5nIGEgc3R1ZGlvIHVybCwgb3IgYSBzdHJpbmcgYmVpbmcgdGhlIGJhc2UgdXJsIHBvaW50aW5nIHRvIGEgc3R1ZGlvLicsXG4gICAgICBIRUxQX0lEUy5HTE9CQUxfRE9DVU1FTlRfUkVGRVJFTkNFX0lOVkFMSURcbiAgICApXG4gICksIHByb2JsZW1zLnB1c2goLi4uZ2V0T3B0aW9uRXJyb3JzJDEodHlwZURlZikpLCB7XG4gICAgLi4udHlwZURlZixcbiAgICBfcHJvYmxlbXM6IHByb2JsZW1zXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3B0aW9uRXJyb3JzJDEodHlwZURlZikge1xuICBjb25zdCB7IG9wdGlvbnMgfSA9IHR5cGVEZWYsIHByb2JsZW1zID0gW107XG4gIHJldHVybiBwcm9ibGVtcy5wdXNoKFxuICAgIC4uLltcImZpbHRlclwiLCBcImZpbHRlclBhcmFtc1wiXS5maWx0ZXIoKGtleSkgPT4ga2V5IGluIHR5cGVEZWYpLm1hcChcbiAgICAgIChrZXkpID0+IGVycm9yKFxuICAgICAgICBgXFxgJHtrZXl9XFxgIGlzIG5vdCBhbGxvd2VkIG9uIGEgcmVmZXJlbmNlIHR5cGUgZGVmaW5pdGlvbiAtIGRpZCB5b3UgbWVhbiBcXGBvcHRpb25zLiR7a2V5fVxcYD9gLFxuICAgICAgICBIRUxQX0lEUy5SRUZFUkVOQ0VfSU5WQUxJRF9PUFRJT05TX0xPQ0FUSU9OXG4gICAgICApXG4gICAgKVxuICApLCBvcHRpb25zID8gaXNQbGFpbk9iamVjdChvcHRpb25zKSA/IHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9wdGlvbnMuZmlsdGVyUGFyYW1zIDwgXCJ1XCIgPyBwcm9ibGVtcy5jb25jYXQoXG4gICAgZXJyb3IoXG4gICAgICBcImBmaWx0ZXJQYXJhbXNgIGNhbm5vdCBiZSB1c2VkIGlmIGBmaWx0ZXJgIGlzIGEgZnVuY3Rpb24uIEVpdGhlciBzdGF0aWNhbGx5IGRlZmluZSBgZmlsdGVyYCBhcyBhIHN0cmluZywgb3IgcmV0dXJuIGBwYXJhbXNgIGZyb20gdGhlIGBmaWx0ZXJgLWZ1bmN0aW9uLlwiLFxuICAgICAgSEVMUF9JRFMuUkVGRVJFTkNFX0lOVkFMSURfRklMVEVSX1BBUkFNU19DT01CSU5BVElPTlxuICAgIClcbiAgKSA6IHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PSBcImZ1bmN0aW9uXCIgfHwgIW9wdGlvbnMuZmlsdGVyICYmICFvcHRpb25zLmZpbHRlclBhcmFtcyA/IHByb2JsZW1zIDogdHlwZW9mIG9wdGlvbnMuZmlsdGVyICE9IFwic3RyaW5nXCIgPyBwcm9ibGVtcy5jb25jYXQoXG4gICAgZXJyb3IoYElmIHNldCwgXFxgZmlsdGVyXFxgIG11c3QgYmUgYSBzdHJpbmcuIEdvdCAke3R5cGVvZiBvcHRpb25zLmZpbHRlcn1gKVxuICApIDogdHlwZW9mIG9wdGlvbnMuZmlsdGVyUGFyYW1zIDwgXCJ1XCIgJiYgIWlzUGxhaW5PYmplY3Qob3B0aW9ucy5maWx0ZXJQYXJhbXMpID8gcHJvYmxlbXMuY29uY2F0KGVycm9yKFwiSWYgc2V0LCBgZmlsdGVyUGFyYW1zYCBtdXN0IGJlIGFuIG9iamVjdC5cIikpIDogb3B0aW9ucy5maWx0ZXJQYXJhbXMgPyBwcm9ibGVtcy5jb25jYXQoXG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5maWx0ZXJQYXJhbXMpLmZpbHRlcigoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIl9fXCIpIHx8IGtleS5zdGFydHNXaXRoKFwiJFwiKSkubWFwKChrZXkpID0+IGVycm9yKGBGaWx0ZXIgcGFyYW1ldGVyIGNhbm5vdCBiZSBwcmVmaXhlZCB3aXRoIFwiJFwiIG9yIFwiX19cIi4gR290ICR7a2V5fVwiLmApKVxuICApIDogcHJvYmxlbXMgOiBwcm9ibGVtcy5jb25jYXQoXG4gICAgZXJyb3IoXG4gICAgICBcIlRoZSByZWZlcmVuY2UgdHlwZSBleHBlY3RzIGBvcHRpb25zYCB0byBiZSBhbiBvYmplY3RcIixcbiAgICAgIEhFTFBfSURTLlJFRkVSRU5DRV9JTlZBTElEX09QVElPTlNcbiAgICApXG4gICkgOiBwcm9ibGVtcztcbn1cbmNvbnN0IGF1dG9NZXRhID0gW1wiZGltZW5zaW9uc1wiLCBcImhhc0FscGhhXCIsIFwiaXNPcGFxdWVcIl07XG52YXIgaW1hZ2UgPSAodHlwZURlZiwgdmlzaXRvckNvbnRleHQpID0+IHtcbiAgY29uc3QgcHJvYmxlbXMgPSBbXSwgZmllbGRzID0gdHlwZURlZi5maWVsZHM7XG4gIGZpZWxkcyAmJiBwcm9ibGVtcy5wdXNoKC4uLnZhbGlkYXRlRmllbGRzKGZpZWxkcywgeyBhbGxvd0VtcHR5OiAhMCB9KSk7XG4gIGxldCBvcHRpb25zID0gdHlwZURlZi5vcHRpb25zO1xuICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhLCBzdXBlcmZsdW91c01ldGEgPSBBcnJheS5pc0FycmF5KG1ldGFkYXRhKSA/IG1ldGFkYXRhLmZpbHRlcigobWV0YSkgPT4gYXV0b01ldGEuaW5jbHVkZXMobWV0YSkpIDogW10sIGludmFsaWRGaWVsZE5hbWVzID0gW1wiYXNzZXRcIiwgXCJob3RzcG90XCIsIFwiY3JvcFwiXSwgZmllbGRzV2l0aEludmFsaWROYW1lID0gQXJyYXkuaXNBcnJheShmaWVsZHMpID8gZmllbGRzPy5maWx0ZXIoKGZpZWxkKSA9PiBpbnZhbGlkRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZC5uYW1lKSkgOiBbXTtcbiAgcmV0dXJuIHR5cGVvZiBtZXRhZGF0YSA8IFwidVwiICYmICFBcnJheS5pc0FycmF5KG1ldGFkYXRhKSA/IHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICBcIkludmFsaWQgdHlwZSBmb3IgaW1hZ2UgYG1ldGFkYXRhYCBmaWVsZCAtIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiLFxuICAgICAgSEVMUF9JRFMuQVNTRVRfTUVUQURBVEFfRklFTERfSU5WQUxJRFxuICAgIClcbiAgKSA6IHN1cGVyZmx1b3VzTWV0YS5sZW5ndGggPiAwID8gKHByb2JsZW1zLnB1c2goXG4gICAgd2FybmluZyhcbiAgICAgIGBJbWFnZSBcXGBtZXRhZGF0YVxcYCBmaWVsZCBjb250YWlucyBzdXBlcmZsdW91cyBwcm9wZXJ0aWVzICh0aGV5IGFyZSBhbHdheXMgaW5jbHVkZWQpOiAke3N1cGVyZmx1b3VzTWV0YS5qb2luKFxuICAgICAgICBcIiwgXCJcbiAgICAgICl9YFxuICAgIClcbiAgKSwgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgbWV0YWRhdGE6IG1ldGFkYXRhLmZpbHRlcigobWV0YSkgPT4gIWF1dG9NZXRhLmluY2x1ZGVzKG1ldGEpKSB9KSA6IGZpZWxkc1dpdGhJbnZhbGlkTmFtZS5sZW5ndGggPiAwICYmIHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICBgVGhlIG5hbWVzIFxcYCR7aW52YWxpZEZpZWxkTmFtZXMuam9pbihcbiAgICAgICAgXCJgLCBgXCJcbiAgICAgICl9XFxgIGFyZSBpbnZhbGlkIGZpZWxkIG5hbWVzIGZvciB0eXBlIFxcYGltYWdlXFxgLmBcbiAgICApXG4gICksIHtcbiAgICAuLi50eXBlRGVmLFxuICAgIG9wdGlvbnMsXG4gICAgZmllbGRzOiAoQXJyYXkuaXNBcnJheShmaWVsZHMpID8gZmllbGRzIDogW10pLm1hcCgoZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLmZpZWxkVHlwZURlZiB9ID0gZmllbGQsIHsgX3Byb2JsZW1zLCAuLi5maWVsZFR5cGUgfSA9IHZpc2l0b3JDb250ZXh0LnZpc2l0KGZpZWxkVHlwZURlZiwgaW5kZXgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgLi4uZmllbGRUeXBlLFxuICAgICAgICBfcHJvYmxlbXM6IHZhbGlkYXRlRmllbGQoZmllbGQpLmNvbmNhdChfcHJvYmxlbXMgfHwgW10pXG4gICAgICB9O1xuICAgIH0pLFxuICAgIF9wcm9ibGVtczogcHJvYmxlbXNcbiAgfTtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVUb1Byb3AodHlwZURlZikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh0eXBlRGVmLnRvKSA/IHR5cGVEZWYudG8gOiB0eXBlRGVmLnRvID8gW3R5cGVEZWYudG9dIDogdHlwZURlZi50bztcbn1cbnZhciByZWZlcmVuY2UgPSAodHlwZURlZiwgdmlzaXRvckNvbnRleHQpID0+IHtcbiAgY29uc3QgaXNWYWxpZFRvID0gQXJyYXkuaXNBcnJheSh0eXBlRGVmLnRvKSB8fCBpc1BsYWluT2JqZWN0KHR5cGVEZWYudG8pLCBub3JtYWxpemVkVG8gPSBub3JtYWxpemVUb1Byb3AodHlwZURlZiksIHByb2JsZW1zID0gZmxhdHRlbihbXG4gICAgaXNWYWxpZFRvID8gZ2V0RHVwZXMobm9ybWFsaXplZFRvLCAodCkgPT4gYCR7dC5uYW1lfTske3QudHlwZX1gKS5tYXAoXG4gICAgICAoZHVwZXMpID0+IGVycm9yKFxuICAgICAgICBgRm91bmQgJHtkdXBlcy5sZW5ndGh9IG1lbWJlcnMgd2l0aCBzYW1lIHR5cGUsIGJ1dCBub3QgdW5pcXVlIG5hbWVzIFwiJHtkdXBlc1swXS50eXBlfVwiIGluIHJlZmVyZW5jZS4gVGhpcyBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIHRlbGwgdGhlaXIgdmFsdWVzIGFwYXJ0IGFuZCB5b3Ugc2hvdWxkIGNvbnNpZGVyIG5hbWluZyB0aGVtYCxcbiAgICAgICAgSEVMUF9JRFMuUkVGRVJFTkNFX1RPX0lOVkFMSURcbiAgICAgIClcbiAgICApIDogZXJyb3IoXG4gICAgICAnVGhlIHJlZmVyZW5jZSB0eXBlIGlzIG1pc3Npbmcgb3IgaGF2aW5nIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSByZXF1aXJlZCBcInRvXCIgcHJvcGVydHkuIEl0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBhY2NlcHRlZCB0eXBlcy4nLFxuICAgICAgSEVMUF9JRFMuUkVGRVJFTkNFX1RPX0lOVkFMSURcbiAgICApXG4gIF0pO1xuICByZXR1cm4gaXNWYWxpZFRvICYmIG5vcm1hbGl6ZWRUby5sZW5ndGggPT09IDAgJiYgcHJvYmxlbXMucHVzaChcbiAgICBlcnJvcihcbiAgICAgICdUaGUgcmVmZXJlbmNlIHR5cGUgc2hvdWxkIGRlZmluZSBhdCBsZWFzdCBvbmUgYWNjZXB0ZWQgdHlwZS4gUGxlYXNlIGNoZWNrIHRoZSBcInRvXCIgcHJvcGVydHkuJyxcbiAgICAgIEhFTFBfSURTLlJFRkVSRU5DRV9UT19JTlZBTElEXG4gICAgKVxuICApLCBwcm9ibGVtcy5wdXNoKC4uLmdldE9wdGlvbkVycm9ycyh0eXBlRGVmKSksIHtcbiAgICAuLi50eXBlRGVmLFxuICAgIHRvOiAoaXNWYWxpZFRvID8gbm9ybWFsaXplZFRvIDogW10pLm1hcCh2aXNpdG9yQ29udGV4dC52aXNpdCksXG4gICAgX3Byb2JsZW1zOiBwcm9ibGVtc1xuICB9O1xufTtcbmZ1bmN0aW9uIGdldE9wdGlvbkVycm9ycyh0eXBlRGVmKSB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gdHlwZURlZiwgcHJvYmxlbXMgPSBbXTtcbiAgcmV0dXJuIHByb2JsZW1zLnB1c2goXG4gICAgLi4uW1wiZmlsdGVyXCIsIFwiZmlsdGVyUGFyYW1zXCJdLmZpbHRlcigoa2V5KSA9PiBrZXkgaW4gdHlwZURlZikubWFwKFxuICAgICAgKGtleSkgPT4gZXJyb3IoXG4gICAgICAgIGBcXGAke2tleX1cXGAgaXMgbm90IGFsbG93ZWQgb24gYSByZWZlcmVuY2UgdHlwZSBkZWZpbml0aW9uIC0gZGlkIHlvdSBtZWFuIFxcYG9wdGlvbnMuJHtrZXl9XFxgP2AsXG4gICAgICAgIEhFTFBfSURTLlJFRkVSRU5DRV9JTlZBTElEX09QVElPTlNfTE9DQVRJT05cbiAgICAgIClcbiAgICApXG4gICksIG9wdGlvbnMgPyBpc1BsYWluT2JqZWN0KG9wdGlvbnMpID8gdHlwZW9mIG9wdGlvbnMuZmlsdGVyID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJQYXJhbXMgPCBcInVcIiA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihcbiAgICAgIFwiYGZpbHRlclBhcmFtc2AgY2Fubm90IGJlIHVzZWQgaWYgYGZpbHRlcmAgaXMgYSBmdW5jdGlvbi4gRWl0aGVyIHN0YXRpY2FsbHkgZGVmaW5lIGBmaWx0ZXJgIGFzIGEgc3RyaW5nLCBvciByZXR1cm4gYHBhcmFtc2AgZnJvbSB0aGUgYGZpbHRlcmAtZnVuY3Rpb24uXCIsXG4gICAgICBIRUxQX0lEUy5SRUZFUkVOQ0VfSU5WQUxJRF9GSUxURVJfUEFSQU1TX0NPTUJJTkFUSU9OXG4gICAgKVxuICApIDogdHlwZW9mIG9wdGlvbnMuZmlsdGVyID09IFwiZnVuY3Rpb25cIiB8fCAhb3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuZmlsdGVyUGFyYW1zID8gcHJvYmxlbXMgOiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgIT0gXCJzdHJpbmdcIiA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihgSWYgc2V0LCBcXGBmaWx0ZXJcXGAgbXVzdCBiZSBhIHN0cmluZy4gR290ICR7dHlwZW9mIG9wdGlvbnMuZmlsdGVyfWApXG4gICkgOiB0eXBlb2Ygb3B0aW9ucy5maWx0ZXJQYXJhbXMgPCBcInVcIiAmJiAhaXNQbGFpbk9iamVjdChvcHRpb25zLmZpbHRlclBhcmFtcykgPyBwcm9ibGVtcy5jb25jYXQoZXJyb3IoXCJJZiBzZXQsIGBmaWx0ZXJQYXJhbXNgIG11c3QgYmUgYW4gb2JqZWN0LlwiKSkgOiBvcHRpb25zLmZpbHRlclBhcmFtcyA/IHByb2JsZW1zLmNvbmNhdChcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmZpbHRlclBhcmFtcykuZmlsdGVyKChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwiX19cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCIkXCIpKS5tYXAoKGtleSkgPT4gZXJyb3IoYEZpbHRlciBwYXJhbWV0ZXIgY2Fubm90IGJlIHByZWZpeGVkIHdpdGggXCIkXCIgb3IgXCJfX1wiLiBHb3QgJHtrZXl9XCIuYCkpXG4gICkgOiBwcm9ibGVtcyA6IHByb2JsZW1zLmNvbmNhdChcbiAgICBlcnJvcihcbiAgICAgIFwiVGhlIHJlZmVyZW5jZSB0eXBlIGV4cGVjdHMgYG9wdGlvbnNgIHRvIGJlIGFuIG9iamVjdFwiLFxuICAgICAgSEVMUF9JRFMuUkVGRVJFTkNFX0lOVkFMSURfT1BUSU9OU1xuICAgIClcbiAgKSA6IHByb2JsZW1zO1xufVxudmFyIHJvb3RUeXBlID0gKHR5cGVEZWYsIHZpc2l0b3JDb250ZXh0KSA9PiB7XG4gIGNvbnN0IGhhc05hbWUgPSAhIXR5cGVEZWYubmFtZTtcbiAgaWYgKCFoYXNOYW1lICYmIE9iamVjdC5rZXlzKHR5cGVEZWYpLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4ge1xuICAgICAgLi4udHlwZURlZixcbiAgICAgIF9wcm9ibGVtczogW1xuICAgICAgICBlcnJvcihcbiAgICAgICAgICBcIkludmFsaWQvdW5kZWZpbmVkIHR5cGUgZGVjbGFyYXRpb24sIGNoZWNrIGRlY2xhcmF0aW9uIG9yIHRoZSBpbXBvcnQvZXhwb3J0IG9mIHRoZSBzY2hlbWEgdHlwZS5cIixcbiAgICAgICAgICBIRUxQX0lEUy5UWVBFX0lOVkFMSURcbiAgICAgICAgKVxuICAgICAgXVxuICAgIH07XG4gIGNvbnN0IHByb2JsZW1zID0gW107XG4gIHJldHVybiBsb29rc0xpa2VFc21Nb2R1bGUodHlwZURlZikgPyBwcm9ibGVtcy5wdXNoKFxuICAgIGVycm9yKFxuICAgICAgXCJUeXBlIGFwcGVhcnMgdG8gYmUgYW4gRVM2IG1vZHVsZSBpbXBvcnRlZCB0aHJvdWdoIENvbW1vbkpTIHJlcXVpcmUgLSB1c2UgYW4gaW1wb3J0IHN0YXRlbWVudCBvciBhY2Nlc3MgdGhlIGAuZGVmYXVsdGAgcHJvcGVydHlcIixcbiAgICAgIEhFTFBfSURTLlRZUEVfSVNfRVNNX01PRFVMRVxuICAgIClcbiAgKSA6IGhhc05hbWUgPyB2aXNpdG9yQ29udGV4dC5pc1Jlc2VydmVkKHR5cGVEZWYubmFtZSkgJiYgcHJvYmxlbXMucHVzaChcbiAgICBlcnJvcihcbiAgICAgIGBJbnZhbGlkIHR5cGUgbmFtZTogXCIke3R5cGVEZWYubmFtZX1cIiBpcyBhIHJlc2VydmVkIG5hbWUuYCxcbiAgICAgIEhFTFBfSURTLlRZUEVfTkFNRV9SRVNFUlZFRFxuICAgIClcbiAgKSA6IHByb2JsZW1zLnB1c2goZXJyb3IoXCJNaXNzaW5nIHR5cGUgbmFtZVwiLCBIRUxQX0lEUy5UWVBFX01JU1NJTkdfTkFNRSkpLCB2aXNpdG9yQ29udGV4dC5pc0R1cGxpY2F0ZSh0eXBlRGVmLm5hbWUpICYmIHByb2JsZW1zLnB1c2goXG4gICAgZXJyb3IoXG4gICAgICBgSW52YWxpZCB0eXBlIG5hbWU6IEEgdHlwZSB3aXRoIG5hbWUgXCIke3R5cGVEZWYubmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjaGVtYS5gXG4gICAgKVxuICApLCBwcm9ibGVtcy5wdXNoKC4uLnZhbGlkYXRlQ29tcG9uZW50KHR5cGVEZWYpKSwgXCJ0aXRsZVwiIGluIHR5cGVEZWYgJiYgdHlwZW9mIHR5cGVEZWYudGl0bGUgIT0gXCJzdHJpbmdcIiAmJiBwcm9ibGVtcy5wdXNoKHdhcm5pbmcoXCJUeXBlIHRpdGxlIGlzIG5vdCBhIHN0cmluZy5cIiwgSEVMUF9JRFMuVFlQRV9USVRMRV9JTlZBTElEKSksIHtcbiAgICAuLi50eXBlRGVmLFxuICAgIF9wcm9ibGVtczogcHJvYmxlbXNcbiAgfTtcbn07XG5mdW5jdGlvbiBsb29rc0xpa2VFc21Nb2R1bGUodHlwZURlZikge1xuICByZXR1cm4gIXR5cGVEZWYubmFtZSAmJiB0eXBlRGVmLmRlZmF1bHQgJiYgKHR5cGVEZWYuZGVmYXVsdC5uYW1lIHx8IHR5cGVEZWYuZGVmYXVsdC50aXRsZSk7XG59XG52YXIgc2x1ZyA9ICh0eXBlRGVmLCB2aXNpdG9yQ29udGV4dCkgPT4ge1xuICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICByZXR1cm4gdHlwZURlZi5vcHRpb25zICYmIHR5cGVEZWYub3B0aW9ucy5zbHVnaWZ5Rm4gJiYgKHByb2JsZW1zLnB1c2goXG4gICAgd2FybmluZyhcbiAgICAgICdIZWFkcyB1cCEgVGhlIFwic2x1Z2lmeUZuXCIgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXCJzbHVnaWZ5XCIuJyxcbiAgICAgIEhFTFBfSURTLlNMVUdfU0xVR0lGWV9GTl9SRU5BTUVEXG4gICAgKVxuICApLCB0eXBlRGVmLm9wdGlvbnMuc2x1Z2lmeSA9IHR5cGVEZWYub3B0aW9ucy5zbHVnaWZ5Rm4pLCB7XG4gICAgLi4udHlwZURlZixcbiAgICBfcHJvYmxlbXM6IHByb2JsZW1zXG4gIH07XG59O1xuY29uc3QgdHlwZVZpc2l0b3JzID0ge1xuICBhcnJheSxcbiAgb2JqZWN0LFxuICBzbHVnLFxuICBmaWxlLFxuICBpbWFnZSxcbiAgYmxvY2s6IHZhbGlkYXRlQmxvY2tUeXBlLFxuICBkb2N1bWVudDogZG9jdW1lbnRWaXNpdG9yLFxuICByZWZlcmVuY2UsXG4gIGNyb3NzRGF0YXNldFJlZmVyZW5jZSxcbiAgZ2xvYmFsRG9jdW1lbnRSZWZlcmVuY2Vcbn0sIGdldE5vb3BWaXNpdG9yID0gKHZpc2l0b3JDb250ZXh0KSA9PiAoc2NoZW1hRGVmKSA9PiAoe1xuICBuYW1lOiBgPHVubmFtZWRfdHlwZV9AX2luZGV4XyR7dmlzaXRvckNvbnRleHQuaW5kZXh9PmAsXG4gIC4uLnNjaGVtYURlZixcbiAgX3Byb2JsZW1zOiBbXVxufSk7XG5mdW5jdGlvbiBjb21iaW5lKC4uLnZpc2l0b3JzKSB7XG4gIHJldHVybiAoc2NoZW1hVHlwZSwgdmlzaXRvckNvbnRleHQpID0+IHZpc2l0b3JzLnJlZHVjZShcbiAgICAocmVzdWx0LCB2aXNpdG9yKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSB2aXNpdG9yKHJlc3VsdCwgdmlzaXRvckNvbnRleHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzLFxuICAgICAgICBfcHJvYmxlbXM6IHJlc3VsdC5fcHJvYmxlbXMuY29uY2F0KHJlcy5fcHJvYmxlbXMpXG4gICAgICB9O1xuICAgIH0sXG4gICAgeyBfcHJvYmxlbXM6IFtdLCAuLi5zY2hlbWFUeXBlIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hKHNjaGVtYVR5cGVzLCB7IHRyYW5zZm9ybVR5cGVWaXNpdG9ycyA9ICh2aXNpdG9ycykgPT4gdmlzaXRvcnMgfSA9IHt9KSB7XG4gIHJldHVybiB0cmF2ZXJzZVNhbml0eVNjaGVtYShzY2hlbWFUeXBlcywgKHNjaGVtYURlZiwgdmlzaXRvckNvbnRleHQpID0+IHtcbiAgICBjb25zdCB0eXBlVmlzaXRvciA9IHNjaGVtYURlZiAmJiBzY2hlbWFEZWYudHlwZSAmJiB0cmFuc2Zvcm1UeXBlVmlzaXRvcnModHlwZVZpc2l0b3JzKVtzY2hlbWFEZWYudHlwZV0gfHwgZ2V0Tm9vcFZpc2l0b3IodmlzaXRvckNvbnRleHQpO1xuICAgIHJldHVybiB2aXNpdG9yQ29udGV4dC5pc1Jvb3QgPyBjb21iaW5lKHJvb3RUeXBlLCBjb21tb24sIHR5cGVWaXNpdG9yKShzY2hlbWFEZWYsIHZpc2l0b3JDb250ZXh0KSA6IGNvbWJpbmUoY29tbW9uLCB0eXBlVmlzaXRvcikoc2NoZW1hRGVmLCB2aXNpdG9yQ29udGV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5zdXBwb3J0ZWRUeXBlVmFsaWRhdG9yKHR5cGVMYWJlbCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9wcm9ibGVtczogW1xuICAgICAgICB7XG4gICAgICAgICAgc2V2ZXJpdHk6IFwiZXJyb3JcIixcbiAgICAgICAgICBtZXNzYWdlOiBgVHlwZSB1bnN1cHBvcnRlZCBpbiBNZWRpYSBMaWJyYXJ5IGFzcGVjdHM6ICR7dHlwZUxhYmVsfS5gXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZWRpYUxpYnJhcnlBc3NldEFzcGVjdChtYXliZUFzcGVjdCkge1xuICBjb25zdCB2YWxpZGF0ZWQgPSB2YWxpZGF0ZVNjaGVtYShbbWF5YmVBc3BlY3RdLCB7XG4gICAgdHJhbnNmb3JtVHlwZVZpc2l0b3JzOiAodHlwZVZpc2l0b3JzMikgPT4gKHtcbiAgICAgIC4uLnR5cGVWaXNpdG9yczIsXG4gICAgICBkb2N1bWVudDogdW5zdXBwb3J0ZWRUeXBlVmFsaWRhdG9yKFwiZG9jdW1lbnRcIiksXG4gICAgICBpbWFnZTogdW5zdXBwb3J0ZWRUeXBlVmFsaWRhdG9yKFwiaW1hZ2VcIiksXG4gICAgICBmaWxlOiB1bnN1cHBvcnRlZFR5cGVWYWxpZGF0b3IoXCJmaWxlXCIpLFxuICAgICAgdmlkZW86IHVuc3VwcG9ydGVkVHlwZVZhbGlkYXRvcihcInNhbml0eS52aWRlb1wiKSxcbiAgICAgIHJlZmVyZW5jZTogdW5zdXBwb3J0ZWRUeXBlVmFsaWRhdG9yKFwicmVmZXJlbmNlXCIpLFxuICAgICAgY3Jvc3NEYXRhc2V0UmVmZXJlbmNlOiB1bnN1cHBvcnRlZFR5cGVWYWxpZGF0b3IoXCJjcm9zcyBkYXRhc2V0IHJlZmVyZW5jZVwiKVxuICAgIH0pXG4gIH0pLCBlcnJvcnMgPSBncm91cFByb2JsZW1zKHZhbGlkYXRlZC5nZXRUeXBlcygpKS5tYXAoKGdyb3VwKSA9PiBncm91cC5wcm9ibGVtcy5maWx0ZXIoKHsgc2V2ZXJpdHkgfSkgPT4gc2V2ZXJpdHkgPT09IFwiZXJyb3JcIikpLmZpbHRlcigocHJvYmxlbXMpID0+IHByb2JsZW1zLmxlbmd0aCk7XG4gIHJldHVybiBbZXJyb3JzLmxlbmd0aCA9PT0gMCwgZXJyb3JzXTtcbn1cbmV4cG9ydCB7XG4gIERFRkFVTFRfTUFYX0ZJRUxEX0RFUFRILFxuICBEZXNjcmlwdG9yQ29udmVydGVyLFxuICBidWlsdGluVHlwZXMsXG4gIGV4dHJhY3RTY2hlbWEsXG4gIGdyb3VwUHJvYmxlbXMsXG4gIGlzQWN0aW9uRW5hYmxlZCxcbiAgcHJvY2Vzc1NjaGVtYVN5bmNocm9uaXphdGlvbixcbiAgcmVzb2x2ZVNlYXJjaENvbmZpZyxcbiAgcmVzb2x2ZVNlYXJjaENvbmZpZ0ZvckJhc2VGaWVsZFBhdGhzLFxuICB2YWxpZGF0ZU1lZGlhTGlicmFyeUFzc2V0QXNwZWN0LFxuICB2YWxpZGF0ZVNjaGVtYVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9pbnRlcm5hbC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_internal.mjs\n");

/***/ }),

/***/ "(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/index.mjs":
/*!******************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/index.mjs ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Schema: () => (/* binding */ Schema2),\n/* harmony export */   \"default\": () => (/* binding */ DeprecatedDefaultSchema)\n/* harmony export */ });\n/* harmony import */ var lodash_omit_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/omit.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/omit.js\");\n/* harmony import */ var lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/pick.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pick.js\");\n/* harmony import */ var _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_chunks-es/resolve.mjs */ \"(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/_chunks-es/resolve.mjs\");\n/* harmony import */ var arrify__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! arrify */ \"(ssr)/../node_modules/.pnpm/arrify@2.0.1/node_modules/arrify/index.js\");\n/* harmony import */ var lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isUndefined.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js\");\n/* harmony import */ var lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omitBy.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/omitBy.js\");\n/* harmony import */ var lodash_capitalize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/capitalize.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/capitalize.js\");\n/* harmony import */ var lodash_castArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/castArray.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/castArray.js\");\n/* harmony import */ var lodash_flatMap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/flatMap.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js\");\n/* harmony import */ var lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash/startCase.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/startCase.js\");\n/* harmony import */ var lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash/isPlainObject.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js\");\n/* harmony import */ var lodash_toPath_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash/toPath.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toPath.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction lazyGetter(target, key, getter, config = {}) {\n  return Object.defineProperty(target, key, {\n    configurable: !0,\n    enumerable: config.enumerable !== !1,\n    get() {\n      const val = getter();\n      return Object.defineProperty(target, key, {\n        value: val,\n        writable: !!config.writable,\n        configurable: !1\n      }), val;\n    }\n  }), target;\n}\nfunction hiddenGetter(target, key, value) {\n  Object.defineProperty(target, key, {\n    enumerable: !1,\n    writable: !1,\n    configurable: !1,\n    value\n  });\n}\nconst OVERRIDABLE_FIELDS$f = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], ANY_CORE = {\n  name: \"any\",\n  type: null,\n  jsonType: \"any\"\n}, AnyType = {\n  get() {\n    return ANY_CORE;\n  },\n  extend(subTypeDef, extendMember) {\n    const ownProps = {\n      ...subTypeDef,\n      of: subTypeDef.of.map((fieldDef) => ({\n        name: fieldDef.name,\n        type: extendMember(lodash_omit_js__WEBPACK_IMPORTED_MODULE_0__(fieldDef, \"name\"))\n      }))\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(ANY_CORE, OVERRIDABLE_FIELDS$f), ownProps, {\n      type: ANY_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.of)\n            throw new Error('Cannot override `of` property of subtypes of \"array\"');\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$f), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$e = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], ARRAY_CORE = {\n  name: \"array\",\n  type: null,\n  jsonType: \"array\",\n  of: []\n}, ArrayType = {\n  get() {\n    return ARRAY_CORE;\n  },\n  extend(subTypeDef, createMemberType) {\n    const parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(ARRAY_CORE, OVERRIDABLE_FIELDS$e), subTypeDef, {\n      type: ARRAY_CORE\n    });\n    return lazyGetter(parsed, \"of\", () => subTypeDef.of.map((ofTypeDef) => createMemberType(ofTypeDef))), lazyGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, () => ({ ...subTypeDef, of: parsed.of }), {\n      enumerable: !1,\n      writable: !1\n    }), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.of)\n            throw new Error('Cannot override `of` property of subtypes of \"array\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$e), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n};\nfunction warnIfPreviewOnOptions(type) {\n  type.options && type.options.preview && console.warn(`Heads up! The preview config is no longer defined on \"options\", but instead on the type/field itself.\nPlease move {options: {preview: ...}} to {..., preview: ...} on the type/field definition of \"${type.name}\".\n`);\n}\nfunction warnIfPreviewHasFields(type) {\n  const preview = type.preview || (type.options || {}).preview;\n  preview && \"fields\" in preview && console.warn(`Heads up! \"preview.fields\" should be renamed to \"preview.select\". Please update the preview config for \"${type.name}\".\n`);\n}\nfunction isEmpty(object) {\n  for (const key in object)\n    if (object.hasOwnProperty(key))\n      return !1;\n  return !0;\n}\nfunction _stringify(value, options, depth) {\n  if (depth > options.maxDepth)\n    return \"...\";\n  if (Array.isArray(value)) {\n    if (value.length === 0)\n      return \"[empty]\";\n    const capLength = Math.max(value.length - options.maxBreadth), asString2 = value.slice(0, options.maxBreadth).map((item, index) => _stringify(item, options, depth + 1)).concat(capLength > 0 ? `\\u2026+${capLength}` : []).join(\", \");\n    return depth === 0 ? asString2 : `[${asString2}]`;\n  }\n  if (typeof value == \"object\" && value !== null) {\n    const keys = Object.keys(value).filter(\n      (key) => !options.ignoreKeys.includes(key) && typeof value[key] < \"u\"\n    );\n    if (isEmpty(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(value, keys)))\n      return \"{empty}\";\n    const asString2 = keys.slice(0, options.maxBreadth).map((key) => `${key}: ${_stringify(value[key], options, depth + 1)}`).join(\", \");\n    return depth === 0 ? asString2 : `{${asString2}}`;\n  }\n  const asString = String(value);\n  return asString === \"\" ? '\"\"' : asString;\n}\nfunction stringify(value, options = {}) {\n  const opts = {\n    maxDepth: \"maxDepth\" in options ? options.maxDepth : 2,\n    maxBreadth: \"maxBreadth\" in options ? options.maxBreadth : 2,\n    ignoreKeys: \"ignoreKeys\" in options ? options.ignoreKeys : []\n  };\n  return _stringify(value, opts, 0);\n}\nconst OPTIONS = {\n  maxEntries: 2,\n  maxDepth: 2,\n  maxBreadth: 2,\n  ignoreKeys: [\"_id\", \"_type\", \"_key\", \"_ref\"]\n};\nfunction createFallbackPrepare(fieldNames) {\n  return (value) => ({\n    title: stringify(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(value, fieldNames), OPTIONS)\n  });\n}\nfunction isBlockField(field) {\n  return field.type === \"array\" && field.of && field.of.some((member) => member.type === \"block\") || !1;\n}\nconst TITLE_CANDIDATES = [\"title\", \"name\", \"label\", \"heading\", \"header\", \"caption\"], DESCRIPTION_CANDIDATES = [\"description\", ...TITLE_CANDIDATES];\nfunction fieldHasReferenceTo(fieldDef, refType) {\n  return arrify__WEBPACK_IMPORTED_MODULE_2__(fieldDef.to || []).some((memberTypeDef) => memberTypeDef.type === refType);\n}\nfunction isImageAssetField(fieldDef) {\n  return fieldHasReferenceTo(fieldDef, \"sanity.imageAsset\");\n}\nfunction resolveImageAssetPath(typeDef) {\n  const fields = typeDef.fields || [], imageAssetField = fields.find(isImageAssetField);\n  if (imageAssetField)\n    return imageAssetField.name;\n  const fieldWithImageAsset = fields.find(\n    (fieldDef) => (fieldDef.fields || []).some(isImageAssetField)\n  );\n  return fieldWithImageAsset ? `${fieldWithImageAsset.name}.asset` : void 0;\n}\nfunction isFileAssetField(fieldDef) {\n  return fieldHasReferenceTo(fieldDef, \"sanity.fileAsset\");\n}\nfunction resolveFileAssetPath(typeDef) {\n  const fields = typeDef.fields || [], assetField = fields.find(isFileAssetField);\n  if (assetField)\n    return assetField.name;\n  const fieldWithFileAsset = fields.find(\n    (fieldDef) => (fieldDef.fields || []).some(isFileAssetField)\n  );\n  return fieldWithFileAsset ? `${fieldWithFileAsset.name}.asset` : void 0;\n}\nfunction guessPreviewFields(rawObjectTypeDef) {\n  const objectTypeDef = { fields: [], ...rawObjectTypeDef }, stringFieldNames = objectTypeDef.fields.filter((field) => field.type === \"string\").map((field) => field.name), blockFieldNames = objectTypeDef.fields.filter(isBlockField).map((field) => field.name);\n  let titleField = TITLE_CANDIDATES.find(\n    (candidate) => stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate)\n  ), descField = DESCRIPTION_CANDIDATES.find(\n    (candidate) => candidate !== titleField && (stringFieldNames.includes(candidate) || blockFieldNames.includes(candidate))\n  );\n  titleField || (titleField = stringFieldNames[0] || blockFieldNames[0], descField = stringFieldNames[1] || blockFieldNames[1]);\n  const mediaField = objectTypeDef.fields.find((field) => field.type === \"image\"), imageAssetPath = resolveImageAssetPath(objectTypeDef);\n  if (!titleField) {\n    const fileAssetPath = resolveFileAssetPath(objectTypeDef);\n    fileAssetPath && (titleField = `${fileAssetPath}.originalFilename`), imageAssetPath && (titleField = `${imageAssetPath}.originalFilename`);\n  }\n  if (!titleField && !imageAssetPath) {\n    const fieldNames = objectTypeDef.fields.map((field) => field.name);\n    return {\n      select: fieldNames.reduce((acc, fieldName) => (acc[fieldName] = fieldName, acc), {}),\n      prepare: createFallbackPrepare(fieldNames)\n    };\n  }\n  return {\n    select: lodash_omitBy_js__WEBPACK_IMPORTED_MODULE_4__(\n      {\n        title: titleField,\n        description: descField,\n        media: mediaField ? mediaField.name : imageAssetPath\n      },\n      lodash_isUndefined_js__WEBPACK_IMPORTED_MODULE_3__\n    )\n  };\n}\nfunction parseSelection(selection) {\n  return selection.reduce((acc, field) => (acc[field] = field, acc), {});\n}\nfunction parsePreview(preview) {\n  if (!preview)\n    return preview;\n  const select = preview.select || preview.fields || {};\n  return Array.isArray(select) ? {\n    ...lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(preview, [\"prepare\", \"component\"]),\n    select: parseSelection(select)\n  } : {\n    ...lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(preview, [\"prepare\", \"component\"]),\n    select\n  };\n}\nfunction createPreviewGetter(objectTypeDef) {\n  return function() {\n    return warnIfPreviewOnOptions(objectTypeDef), warnIfPreviewHasFields(objectTypeDef), parsePreview(objectTypeDef.preview || (objectTypeDef.options || {}).preview) || guessPreviewFields(objectTypeDef);\n  };\n}\nconst DEFAULT_LINK_ANNOTATION = {\n  type: \"object\",\n  name: \"link\",\n  title: \"Link\",\n  i18nTitleKey: \"inputs.portable-text.annotation.link\",\n  options: {\n    modal: { type: \"popover\" }\n  },\n  fields: [\n    {\n      name: \"href\",\n      type: \"url\",\n      title: \"Link\",\n      description: \"A valid web, email, phone, or relative link.\",\n      validation: (Rule) => Rule.uri({\n        scheme: [\"http\", \"https\", \"tel\", \"mailto\"],\n        allowRelative: !0\n      })\n    }\n  ]\n}, DEFAULT_TEXT_FIELD = {\n  type: \"text\",\n  name: \"text\",\n  title: \"Text\"\n}, DEFAULT_MARKS_FIELD = {\n  name: \"marks\",\n  type: \"array\",\n  of: [{ type: \"string\" }],\n  title: \"Marks\"\n}, LIST_TYPES = {\n  bullet: {\n    title: \"Bulleted list\",\n    value: \"bullet\",\n    i18nTitleKey: \"inputs.portable-text.list-type.bullet\"\n  },\n  numbered: {\n    title: \"Numbered list\",\n    value: \"number\",\n    i18nTitleKey: \"inputs.portable-text.list-type.number\"\n  }\n}, DEFAULT_LIST_TYPES = [LIST_TYPES.bullet, LIST_TYPES.numbered], BLOCK_STYLES = {\n  normal: { title: \"Normal\", value: \"normal\", i18nTitleKey: \"inputs.portable-text.style.normal\" },\n  h1: { title: \"Heading 1\", value: \"h1\", i18nTitleKey: \"inputs.portable-text.style.h1\" },\n  h2: { title: \"Heading 2\", value: \"h2\", i18nTitleKey: \"inputs.portable-text.style.h2\" },\n  h3: { title: \"Heading 3\", value: \"h3\", i18nTitleKey: \"inputs.portable-text.style.h3\" },\n  h4: { title: \"Heading 4\", value: \"h4\", i18nTitleKey: \"inputs.portable-text.style.h4\" },\n  h5: { title: \"Heading 5\", value: \"h5\", i18nTitleKey: \"inputs.portable-text.style.h5\" },\n  h6: { title: \"Heading 6\", value: \"h6\", i18nTitleKey: \"inputs.portable-text.style.h6\" },\n  blockquote: {\n    title: \"Quote\",\n    value: \"blockquote\",\n    i18nTitleKey: \"inputs.portable-text.style.quote\"\n  }\n}, DEFAULT_BLOCK_STYLES = [\n  BLOCK_STYLES.normal,\n  BLOCK_STYLES.h1,\n  BLOCK_STYLES.h2,\n  BLOCK_STYLES.h3,\n  BLOCK_STYLES.h4,\n  BLOCK_STYLES.h5,\n  BLOCK_STYLES.h6,\n  BLOCK_STYLES.blockquote\n], DECORATOR_STRONG = {\n  title: \"Strong\",\n  value: \"strong\",\n  i18nTitleKey: \"inputs.portable-text.decorator.strong\"\n}, DECORATOR_EMPHASIS = {\n  title: \"Italic\",\n  value: \"em\",\n  i18nTitleKey: \"inputs.portable-text.decorator.emphasis\"\n}, DECORATOR_CODE = {\n  title: \"Code\",\n  value: \"code\",\n  i18nTitleKey: \"inputs.portable-text.decorator.code\"\n}, DECORATOR_UNDERLINE = {\n  title: \"Underline\",\n  value: \"underline\",\n  i18nTitleKey: \"inputs.portable-text.decorator.underline\"\n}, DECORATOR_STRIKE = {\n  title: \"Strike\",\n  value: \"strike-through\",\n  i18nTitleKey: \"inputs.portable-text.decorator.strike-through\"\n}, DECORATORS = {\n  strong: DECORATOR_STRONG,\n  em: DECORATOR_EMPHASIS,\n  code: DECORATOR_CODE,\n  underline: DECORATOR_UNDERLINE,\n  strikeThrough: DECORATOR_STRIKE\n}, DEFAULT_DECORATORS = [\n  DECORATORS.strong,\n  DECORATORS.em,\n  DECORATORS.code,\n  DECORATORS.underline,\n  DECORATORS.strikeThrough\n], INHERITED_FIELDS$1 = [\n  \"type\",\n  \"name\",\n  \"title\",\n  \"jsonType\",\n  \"description\",\n  \"options\",\n  \"fieldsets\",\n  \"icon\"\n], BLOCK_CORE = {\n  name: \"block\",\n  title: \"Block\",\n  type: null,\n  jsonType: \"object\"\n}, DEFAULT_OPTIONS$3 = {}, BlockType = {\n  get() {\n    return BLOCK_CORE;\n  },\n  extend(subTypeDef, extendMember) {\n    const options = { ...subTypeDef.options || DEFAULT_OPTIONS$3 }, { marks, styles, lists, of, ...rest } = subTypeDef, childrenField = createChildrenField(marks, of), styleField = createStyleField(styles), listItemField = createListItemField(lists), markDefsField = {\n      name: \"markDefs\",\n      title: \"Mark definitions\",\n      type: \"array\",\n      of: marks?.annotations || DEFAULT_ANNOTATIONS\n    }, fields = [childrenField, styleField, listItemField, markDefsField, {\n      name: \"level\",\n      title: \"Indentation\",\n      type: \"number\"\n    }].concat(\n      subTypeDef.fields || []\n    ), ownProps = { ...rest, options }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(BLOCK_CORE, INHERITED_FIELDS$1), ownProps, {\n      type: BLOCK_CORE\n    });\n    return lazyGetter(parsed, \"fields\", () => fields.map((fieldDef) => {\n      const { name, ...type } = fieldDef;\n      return {\n        name,\n        type: extendMember(type)\n      };\n    })), lazyGetter(parsed, \"preview\", createPreviewGetter(subTypeDef)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...ownProps,\n        fields: parsed.fields,\n        preview: parsed.preview\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.fields)\n            throw new Error('Cannot override `fields` of subtypes of \"block\"');\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, INHERITED_FIELDS$1), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n};\nfunction ensureNormalStyle(styles) {\n  return styles.some((style) => style.value === \"normal\") ? styles : [BLOCK_STYLES.normal, ...styles];\n}\nfunction createStyleField(styles) {\n  return {\n    name: \"style\",\n    title: \"Style\",\n    type: \"string\",\n    options: {\n      list: ensureNormalStyle(styles || DEFAULT_BLOCK_STYLES)\n    }\n  };\n}\nfunction createListItemField(lists) {\n  return {\n    name: \"listItem\",\n    title: \"List type\",\n    type: \"string\",\n    options: {\n      list: lists || DEFAULT_LIST_TYPES\n    }\n  };\n}\nconst DEFAULT_ANNOTATIONS = [DEFAULT_LINK_ANNOTATION];\nfunction createChildrenField(marks, of = []) {\n  return {\n    name: \"children\",\n    title: \"Content\",\n    type: \"array\",\n    of: [\n      {\n        type: \"span\",\n        fields: [DEFAULT_TEXT_FIELD, DEFAULT_MARKS_FIELD],\n        annotations: marks && marks.annotations ? marks.annotations : DEFAULT_ANNOTATIONS,\n        decorators: marks && marks.decorators ? marks.decorators : DEFAULT_DECORATORS\n      },\n      ...of.filter((memberType) => memberType.type !== \"span\")\n    ]\n  };\n}\nconst INHERITED_FIELDS = [\n  \"type\",\n  \"name\",\n  \"title\",\n  \"jsonType\",\n  \"description\",\n  \"options\",\n  \"fieldsets\",\n  \"icon\"\n], SPAN_CORE = {\n  name: \"span\",\n  title: \"Span\",\n  type: null,\n  jsonType: \"object\"\n}, MARKS_FIELD = {\n  name: \"marks\",\n  title: \"Marks\",\n  type: \"array\",\n  of: [{ type: \"string\" }]\n}, TEXT_FIELD = {\n  name: \"text\",\n  title: \"Text\",\n  type: \"string\"\n}, DEFAULT_OPTIONS$2 = {}, SpanType = {\n  get() {\n    return SPAN_CORE;\n  },\n  extend(subTypeDef, extendMember) {\n    const options = { ...subTypeDef.options || DEFAULT_OPTIONS$2 }, { annotations = [], marks = [] } = subTypeDef, fields = [MARKS_FIELD, TEXT_FIELD], ownProps = { ...subTypeDef, options }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(SPAN_CORE, INHERITED_FIELDS), ownProps, {\n      type: SPAN_CORE\n    });\n    return lazyGetter(parsed, \"fields\", () => fields.map((fieldDef) => {\n      const { name, ...type } = fieldDef;\n      return {\n        name,\n        type: extendMember(type)\n      };\n    })), lazyGetter(parsed, \"annotations\", () => annotations.map(extendMember)), lazyGetter(parsed, \"marks\", () => marks.map(extendMember)), lazyGetter(parsed, \"preview\", createPreviewGetter(subTypeDef)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...ownProps,\n        fields: parsed.fields,\n        annotations: parsed.annotations,\n        marks: parsed.marks,\n        preview: parsed.preview\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.fields)\n            throw new Error('Cannot override `fields` of subtypes of \"span\"');\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, INHERITED_FIELDS), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n};\nvar primitivePreview = {\n  prepare: (val) => ({ title: String(val) })\n};\nconst OVERRIDABLE_FIELDS$d = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], BOOLEAN_CORE = {\n  name: \"boolean\",\n  title: \"Boolean\",\n  type: null,\n  jsonType: \"boolean\"\n}, BooleanType = {\n  get() {\n    return BOOLEAN_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(BOOLEAN_CORE, OVERRIDABLE_FIELDS$d), ownProps, {\n      type: BOOLEAN_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$d), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, REF_FIELD$2 = {\n  name: \"_ref\",\n  title: \"Referenced document ID\",\n  type: \"string\"\n}, WEAK_FIELD$2 = {\n  name: \"_weak\",\n  title: \"Weak reference marker\",\n  type: \"boolean\"\n}, DATASET_FIELD = {\n  name: \"_dataset\",\n  title: \"Target dataset\",\n  type: \"string\"\n}, PROJECT_ID_FIELD = {\n  name: \"_projectId\",\n  title: \"Target project ID\",\n  type: \"string\",\n  hidden: !0\n}, REFERENCE_FIELDS$2 = [REF_FIELD$2, WEAK_FIELD$2, DATASET_FIELD, PROJECT_ID_FIELD], OVERRIDABLE_FIELDS$c = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], CROSS_DATASET_REFERENCE_CORE = {\n  name: \"crossDatasetReference\",\n  type: null,\n  jsonType: \"object\"\n};\nfunction humanize$2(arr, conjunction) {\n  const len = arr.length;\n  if (len === 1)\n    return arr[0];\n  const first = arr.slice(0, len - 1), last = arr[len - 1];\n  return `${first.join(\", \")} ${conjunction} ${last}`;\n}\nfunction buildTitle$2(type) {\n  return !type.to || type.to.length === 0 ? \"Cross dataset Reference\" : `Cross dataset reference to ${humanize$2(\n    arrify__WEBPACK_IMPORTED_MODULE_2__(type.to).map((toType) => toType.title || lodash_capitalize_js__WEBPACK_IMPORTED_MODULE_5__(toType.type)),\n    \"or\"\n  ).toLowerCase()}`;\n}\nconst CrossDatasetReferenceType = {\n  get() {\n    return CROSS_DATASET_REFERENCE_CORE;\n  },\n  extend(subTypeDef, createMemberType) {\n    if (!subTypeDef.to)\n      throw new Error(\n        `Missing \"to\" field in cross dataset reference definition. Check the type ${subTypeDef.name}`\n      );\n    const parsed = Object.assign(\n      lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(CROSS_DATASET_REFERENCE_CORE, OVERRIDABLE_FIELDS$c),\n      subTypeDef,\n      {\n        type: CROSS_DATASET_REFERENCE_CORE\n      }\n    );\n    return lazyGetter(parsed, \"fields\", () => REFERENCE_FIELDS$2.map((fieldDef) => {\n      const { name, ...type } = fieldDef;\n      return {\n        name,\n        type: createMemberType(type)\n      };\n    })), lazyGetter(parsed, \"to\", () => arrify__WEBPACK_IMPORTED_MODULE_2__(subTypeDef.to).map((toType) => ({\n      ...toType,\n      // eslint-disable-next-line camelcase\n      __experimental_search: (0,_chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.resolveSearchConfigForBaseFieldPaths)(toType)\n    }))), lazyGetter(parsed, \"title\", () => subTypeDef.title || buildTitle$2(parsed)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...subTypeDef,\n        fields: parsed.fields,\n        to: parsed.to,\n        title: parsed.title\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.of)\n            throw new Error('Cannot override `of` of subtypes of \"reference\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$c), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$b = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], DATE_CORE = {\n  name: \"date\",\n  title: \"Datetime\",\n  type: null,\n  jsonType: \"string\"\n}, DateType = {\n  get() {\n    return DATE_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(DATE_CORE, OVERRIDABLE_FIELDS$b), ownProps, {\n      type: DATE_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$b), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$a = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], DATETIME_CORE = {\n  name: \"datetime\",\n  title: \"Datetime\",\n  type: null,\n  jsonType: \"string\"\n}, DateTimeType = {\n  get() {\n    return DATETIME_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(DATETIME_CORE, OVERRIDABLE_FIELDS$a), ownProps, {\n      type: DATETIME_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$a), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, CANDIDATES = [\"title\", \"name\", \"label\", \"heading\", \"header\", \"caption\", \"description\"], PRIMITIVES = [\"string\", \"boolean\", \"number\"], isPrimitive = (field) => PRIMITIVES.includes(field.type);\nfunction guessOrderingConfig(objectTypeDef) {\n  let candidates = CANDIDATES.filter(\n    (candidate) => objectTypeDef.fields.some((field) => isPrimitive(field) && field.name === candidate)\n  );\n  return candidates.length === 0 && (candidates = objectTypeDef.fields.filter(isPrimitive).map((field) => field.name)), candidates.map(\n    (name) => ({\n      name,\n      i18n: {\n        title: { key: `default-orderings.${name}`, ns: \"studio\" }\n      },\n      title: lodash_capitalize_js__WEBPACK_IMPORTED_MODULE_5__(lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(name)),\n      by: [{ field: name, direction: \"asc\" }]\n    })\n  );\n}\nfunction normalizeSearchConfigs(configs) {\n  if (!Array.isArray(configs))\n    throw new Error(\n      \"The search config of a document type must be an array of search config objects\"\n    );\n  return configs.map((conf) => {\n    if (conf === \"defaults\")\n      return conf;\n    if (!lodash_isPlainObject_js__WEBPACK_IMPORTED_MODULE_9__(conf))\n      throw new Error(\"Search config must be an object of {path: string, weight: number}\");\n    return {\n      weight: \"weight\" in conf ? conf.weight : 1,\n      path: lodash_toPath_js__WEBPACK_IMPORTED_MODULE_10__(conf.path),\n      mapWith: typeof conf.mapWith == \"string\" ? conf.mapWith : void 0\n    };\n  });\n}\nconst OVERRIDABLE_FIELDS$9 = [\n  ..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS,\n  \"orderings\",\n  \"__experimental_search\",\n  \"blockEditor\",\n  \"icon\"\n], ObjectType = {\n  get() {\n    return {\n      name: \"object\",\n      title: \"Object\",\n      type: null,\n      jsonType: \"object\"\n    };\n  },\n  extend(rawSubTypeDef, createMemberType) {\n    const subTypeDef = { fields: [], ...rawSubTypeDef }, options = { ...subTypeDef.options }, ownProps = {\n      ...subTypeDef,\n      title: subTypeDef.title || (subTypeDef.name ? lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(subTypeDef.name) : \"Object\"),\n      options,\n      orderings: subTypeDef.orderings || guessOrderingConfig(subTypeDef),\n      fields: subTypeDef.fields.map((fieldDef) => {\n        const { name, fieldset, group, ...rest } = fieldDef;\n        return lazyGetter({\n          name,\n          group,\n          fieldset\n        }, \"type\", () => createMemberType({\n          ...rest,\n          title: fieldDef.title || lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(name)\n        }));\n      })\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(this.get(), OVERRIDABLE_FIELDS$9), ownProps, {\n      type: this.get()\n    });\n    return lazyGetter(parsed, \"fieldsets\", () => createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, \"groups\", () => createFieldsGroups(subTypeDef, parsed.fields)), lazyGetter(parsed, \"preview\", createPreviewGetter(subTypeDef)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...ownProps,\n        preview: parsed.preview\n      }),\n      { enumerable: !1, writable: !1 }\n    ), lazyGetter(\n      parsed,\n      \"__experimental_search\",\n      () => {\n        const userProvidedSearchConfig = subTypeDef.__experimental_search ? normalizeSearchConfigs(subTypeDef.__experimental_search) : null;\n        return userProvidedSearchConfig ? userProvidedSearchConfig.map(\n          (entry) => entry === \"defaults\" ? normalizeSearchConfigs(subTypeDef) : entry\n        ) : (0,_chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.resolveSearchConfig)(parsed);\n      },\n      {\n        enumerable: !1\n      }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.fields)\n            throw new Error('Cannot override `fields` of subtypes of \"object\"');\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$9);\n          subOwnProps.title = extensionDef.title || subTypeDef.title || (subTypeDef.name ? lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(subTypeDef.name) : \"Object\");\n          const current = Object.assign({}, parent, lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$9), {\n            type: parent\n          });\n          return lazyGetter(current, \"__experimental_search\", () => parent.__experimental_search), hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n};\nfunction createFieldsets(typeDef, fields) {\n  const fieldsetsByName = {};\n  for (const fieldset of typeDef.fieldsets || []) {\n    if (fieldsetsByName[fieldset.name])\n      throw new Error(\n        `Duplicate fieldset name \"${fieldset.name}\" found for type '${typeDef.title ? typeDef.title : lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(typeDef.name)}'`\n      );\n    fieldsetsByName[fieldset.name] = { title: lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(fieldset.name), ...fieldset, fields: [] };\n  }\n  const fieldsets = /* @__PURE__ */ new Set();\n  for (const field of fields) {\n    if (!field.fieldset) {\n      fieldsets.add({ single: !0, field });\n      continue;\n    }\n    const fieldset = fieldsetsByName[field.fieldset];\n    if (!fieldset)\n      throw new Error(\n        `Fieldset '${field.fieldset}' is not defined in schema for type '${typeDef.name}'`\n      );\n    fieldset.fields.push(field), fieldsets.add(fieldset);\n  }\n  return Array.from(fieldsets);\n}\nfunction createFieldsGroups(typeDef, fields) {\n  const groupsByName = {};\n  let numDefaultGroups = 0;\n  for (const group of typeDef.groups || []) {\n    if (groupsByName[group.name])\n      throw new Error(\n        `Duplicate group name \"${group.name}\" found for type '${typeDef.title ? typeDef.title : lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(typeDef.name)}'`\n      );\n    if (groupsByName[group.name] = { title: lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(group.name), ...group, fields: [] }, group.default && ++numDefaultGroups > 1)\n      throw new Error(\n        `More than one field group defined as default for type '${typeDef.title ? typeDef.title : lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(typeDef.name)}' - only 1 is supported`\n      );\n  }\n  return fields.forEach((field) => {\n    const fieldGroupNames = lodash_castArray_js__WEBPACK_IMPORTED_MODULE_6__(field.group || []);\n    fieldGroupNames.length !== 0 && fieldGroupNames.forEach((fieldGroupName) => {\n      const currentGroup = groupsByName[fieldGroupName];\n      if (!currentGroup)\n        throw new Error(\n          `Field group '${fieldGroupName}' is not defined in schema for type '${typeDef.title ? typeDef.name : lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(typeDef.name)}'`\n        );\n      currentGroup.fields.push(field);\n    });\n  }), lodash_flatMap_js__WEBPACK_IMPORTED_MODULE_7__(groupsByName).filter((group) => group.fields.length > 0);\n}\nconst DOCUMENT_CORE = {\n  name: \"document\",\n  title: \"Document\",\n  type: null,\n  jsonType: \"object\"\n}, DocumentType = {\n  get() {\n    return DOCUMENT_CORE;\n  },\n  extend: ObjectType.extend\n}, OVERRIDABLE_FIELDS$8 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], EMAIL_CORE = {\n  name: \"email\",\n  title: \"Email\",\n  type: null,\n  jsonType: \"string\"\n};\nlazyGetter(\n  EMAIL_CORE,\n  _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n  () => ({\n    ...EMAIL_CORE,\n    validation: (Rule) => Rule.email()\n  }),\n  { enumerable: !1 }\n);\nconst EmailType = {\n  get() {\n    return EMAIL_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(EMAIL_CORE, OVERRIDABLE_FIELDS$8), ownProps, {\n      type: EMAIL_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$8), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, ASSET_FIELD$1 = {\n  name: \"asset\",\n  type: \"reference\",\n  to: { type: \"sanity.fileAsset\" }\n}, MEDIA_LIBRARY_ASSET_FIELD$1 = {\n  name: \"media\",\n  type: \"globalDocumentReference\",\n  hidden: !0,\n  to: [{ type: \"sanity.asset\" }]\n}, OVERRIDABLE_FIELDS$7 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], FILE_CORE = {\n  name: \"file\",\n  title: \"File\",\n  type: null,\n  jsonType: \"object\"\n}, DEFAULT_OPTIONS$1 = {\n  accept: \"\"\n}, FileType = {\n  get() {\n    return FILE_CORE;\n  },\n  extend(rawSubTypeDef, createMemberType) {\n    const options = { ...rawSubTypeDef.options || DEFAULT_OPTIONS$1 }, fields = [ASSET_FIELD$1, MEDIA_LIBRARY_ASSET_FIELD$1, ...rawSubTypeDef.fields || []], subTypeDef = { ...rawSubTypeDef, fields }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(FILE_CORE, OVERRIDABLE_FIELDS$7), subTypeDef, {\n      type: FILE_CORE,\n      title: subTypeDef.title || (subTypeDef.name ? lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(subTypeDef.name) : FILE_CORE.title),\n      options,\n      fields: subTypeDef.fields.map((fieldDef) => {\n        const { name, fieldset, ...rest } = fieldDef, compiledField = {\n          name,\n          fieldset,\n          isCustomized: !!rawSubTypeDef.fields\n        };\n        return lazyGetter(compiledField, \"type\", () => createMemberType({\n          ...rest,\n          title: fieldDef.title || lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(name)\n        }));\n      })\n    });\n    return lazyGetter(parsed, \"fieldsets\", () => createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, \"preview\", createPreviewGetter(Object.assign({}, subTypeDef, { fields }))), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...subTypeDef,\n        options,\n        fields: parsed.fields,\n        title: parsed.title,\n        fieldsets: parsed.fieldsets,\n        preview: parsed.preview\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.fields)\n            throw new Error('Cannot override `fields` of subtypes of \"file\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$7), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n}, REF_FIELD$1 = {\n  name: \"_ref\",\n  title: \"Referenced document ID\",\n  type: \"string\"\n}, WEAK_FIELD$1 = {\n  name: \"_weak\",\n  title: \"Weak reference\",\n  type: \"boolean\"\n}, REFERENCE_FIELDS$1 = [REF_FIELD$1, WEAK_FIELD$1], OVERRIDABLE_FIELDS$6 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], GLOBAL_DOCUMENT_REFERENCE_CORE = {\n  name: \"globalDocumentReference\",\n  title: \"Global Document Reference\",\n  type: null,\n  jsonType: \"object\"\n};\nfunction humanize$1(arr, conjunction) {\n  const len = arr.length;\n  if (len === 1)\n    return arr[0];\n  const first = arr.slice(0, len - 1), last = arr[len - 1];\n  return `${first.join(\", \")} ${conjunction} ${last}`;\n}\nfunction buildTitle$1(type) {\n  return !type.to || type.to.length === 0 ? \"Global Document Reference\" : `Global Document Reference to ${humanize$1(\n    arrify__WEBPACK_IMPORTED_MODULE_2__(type.to).map((toType) => toType.title),\n    \"or\"\n  ).toLowerCase()}`;\n}\nconst GlobalDocumentReferenceType = {\n  get() {\n    return GLOBAL_DOCUMENT_REFERENCE_CORE;\n  },\n  extend(subTypeDef, createMemberType) {\n    if (!subTypeDef.to)\n      throw new Error(\n        `Missing \"to\" field in global document reference definition. Check the type ${subTypeDef.name}`\n      );\n    const parsed = Object.assign(\n      lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(GLOBAL_DOCUMENT_REFERENCE_CORE, OVERRIDABLE_FIELDS$6),\n      subTypeDef,\n      {\n        type: GLOBAL_DOCUMENT_REFERENCE_CORE\n      }\n    );\n    return lazyGetter(parsed, \"fields\", () => REFERENCE_FIELDS$1.map((fieldDef) => {\n      const { name, ...type } = fieldDef;\n      return {\n        name,\n        type: createMemberType(type)\n      };\n    })), lazyGetter(parsed, \"to\", () => arrify__WEBPACK_IMPORTED_MODULE_2__(subTypeDef.to).map((toType) => ({\n      ...toType\n    }))), lazyGetter(parsed, \"title\", () => subTypeDef.title || buildTitle$1(parsed)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...subTypeDef,\n        fields: parsed.fields,\n        to: parsed.to,\n        title: parsed.title\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.of)\n            throw new Error('Cannot override `of` of subtypes of \"globalDocumentReference\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$6), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n}, ASSET_FIELD = {\n  name: \"asset\",\n  type: \"reference\",\n  to: [{ type: \"sanity.imageAsset\" }]\n}, HOTSPOT_FIELD = {\n  name: \"hotspot\",\n  type: \"sanity.imageHotspot\"\n}, CROP_FIELD = {\n  name: \"crop\",\n  type: \"sanity.imageCrop\"\n}, MEDIA_LIBRARY_ASSET_FIELD = {\n  name: \"media\",\n  type: \"globalDocumentReference\",\n  hidden: !0,\n  to: [{ type: \"sanity.asset\" }]\n}, OVERRIDABLE_FIELDS$5 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], IMAGE_CORE = {\n  name: \"image\",\n  title: \"Image\",\n  type: null,\n  jsonType: \"object\"\n}, DEFAULT_OPTIONS = {}, ImageType = {\n  get() {\n    return IMAGE_CORE;\n  },\n  extend(rawSubTypeDef, createMemberType) {\n    const options = { ...rawSubTypeDef.options || DEFAULT_OPTIONS };\n    let hotspotFields = [HOTSPOT_FIELD, CROP_FIELD];\n    options.hotspot || (hotspotFields = hotspotFields.map((field) => ({ ...field, hidden: !0 })));\n    const fields = [\n      ASSET_FIELD,\n      MEDIA_LIBRARY_ASSET_FIELD,\n      ...hotspotFields,\n      ...rawSubTypeDef.fields || []\n    ], subTypeDef = { ...rawSubTypeDef, fields }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(this.get(), OVERRIDABLE_FIELDS$5), subTypeDef, {\n      type: IMAGE_CORE,\n      title: subTypeDef.title || (subTypeDef.name ? lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(subTypeDef.name) : IMAGE_CORE.title),\n      options,\n      fields: subTypeDef.fields.map((fieldDef) => {\n        const { name, fieldset, ...rest } = fieldDef, compiledField = {\n          name,\n          fieldset,\n          isCustomized: !!rawSubTypeDef.fields\n        };\n        return lazyGetter(compiledField, \"type\", () => createMemberType({\n          ...rest,\n          title: fieldDef.title || lodash_startCase_js__WEBPACK_IMPORTED_MODULE_8__(name)\n        }));\n      })\n    });\n    return lazyGetter(parsed, \"fieldsets\", () => createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, \"preview\", createPreviewGetter(Object.assign({}, subTypeDef, { fields }))), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...subTypeDef,\n        options,\n        fields: parsed.fields,\n        title: parsed.title,\n        fieldsets: parsed.fieldsets,\n        preview: parsed.preview\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.fields)\n            throw new Error('Cannot override `fields` of subtypes of \"image\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$5), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$4 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], NUMBER_CORE = {\n  name: \"number\",\n  title: \"Number\",\n  type: null,\n  jsonType: \"number\"\n}, NumberType = {\n  get() {\n    return NUMBER_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(NUMBER_CORE, OVERRIDABLE_FIELDS$4), ownProps, {\n      type: NUMBER_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$4), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, REF_FIELD = {\n  name: \"_ref\",\n  title: \"Referenced document ID\",\n  type: \"string\"\n}, WEAK_FIELD = {\n  name: \"_weak\",\n  title: \"Weak reference\",\n  type: \"boolean\"\n}, REFERENCE_FIELDS = [REF_FIELD, WEAK_FIELD], OVERRIDABLE_FIELDS$3 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], REFERENCE_CORE = {\n  name: \"reference\",\n  title: \"Reference\",\n  type: null,\n  jsonType: \"object\"\n};\nfunction humanize(arr, conjunction) {\n  const len = arr.length;\n  if (len === 1)\n    return arr[0];\n  const first = arr.slice(0, len - 1), last = arr[len - 1];\n  return `${first.join(\", \")} ${conjunction} ${last}`;\n}\nfunction buildTitle(type) {\n  return !type.to || type.to.length === 0 ? \"Reference\" : `Reference to ${humanize(\n    arrify__WEBPACK_IMPORTED_MODULE_2__(type.to).map((toType) => toType.title),\n    \"or\"\n  ).toLowerCase()}`;\n}\nconst ReferenceType = {\n  get() {\n    return REFERENCE_CORE;\n  },\n  extend(subTypeDef, createMemberType) {\n    if (!subTypeDef.to)\n      throw new Error(\n        `Missing \"to\" field in reference definition. Check the type ${subTypeDef.name}`\n      );\n    const parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(REFERENCE_CORE, OVERRIDABLE_FIELDS$3), subTypeDef, {\n      type: REFERENCE_CORE\n    });\n    return lazyGetter(parsed, \"fields\", () => REFERENCE_FIELDS.map((fieldDef) => {\n      const { name, ...type } = fieldDef;\n      return {\n        name,\n        type: createMemberType(type)\n      };\n    })), lazyGetter(parsed, \"fieldsets\", () => createFieldsets(subTypeDef, parsed.fields)), lazyGetter(parsed, \"to\", () => arrify__WEBPACK_IMPORTED_MODULE_2__(subTypeDef.to).map((toType) => createMemberType(toType))), lazyGetter(parsed, \"title\", () => subTypeDef.title || buildTitle(parsed)), lazyGetter(\n      parsed,\n      _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME,\n      () => ({\n        ...subTypeDef,\n        fields: parsed.fields,\n        fieldsets: parsed.fieldsets,\n        to: parsed.to,\n        title: parsed.title\n      }),\n      { enumerable: !1, writable: !1 }\n    ), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          if (extensionDef.of)\n            throw new Error('Cannot override `of` of subtypes of \"reference\"');\n          const ownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$3), current = Object.assign({}, parent, ownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$2 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], STRING_CORE = {\n  name: \"string\",\n  title: \"String\",\n  type: null,\n  jsonType: \"string\"\n}, StringType = {\n  get() {\n    return STRING_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(STRING_CORE, OVERRIDABLE_FIELDS$2), ownProps, {\n      type: STRING_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$2), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS$1 = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS, \"rows\"], TEXT_CORE = {\n  name: \"text\",\n  title: \"Text\",\n  type: null,\n  jsonType: \"string\"\n}, TextType = {\n  get() {\n    return TEXT_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(TEXT_CORE, OVERRIDABLE_FIELDS$1), ownProps, {\n      type: TEXT_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS$1), current = Object.assign({}, parent, subOwnProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnProps), subtype(current);\n        }\n      };\n    }\n  }\n}, OVERRIDABLE_FIELDS = [..._chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.DEFAULT_OVERRIDEABLE_FIELDS], URL_CORE = {\n  name: \"url\",\n  title: \"Url\",\n  type: null,\n  jsonType: \"string\"\n}, UrlType = {\n  get() {\n    return URL_CORE;\n  },\n  extend(subTypeDef) {\n    const ownProps = {\n      ...subTypeDef,\n      preview: primitivePreview\n    }, parsed = Object.assign(lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(URL_CORE, OVERRIDABLE_FIELDS), ownProps, {\n      type: URL_CORE\n    });\n    return hiddenGetter(parsed, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, ownProps), subtype(parsed);\n    function subtype(parent) {\n      return {\n        get() {\n          return parent;\n        },\n        extend: (extensionDef) => {\n          const subOwnownProps = lodash_pick_js__WEBPACK_IMPORTED_MODULE_1__(extensionDef, OVERRIDABLE_FIELDS), current = Object.assign({}, parent, subOwnownProps, {\n            type: parent\n          });\n          return hiddenGetter(current, _chunks_es_resolve_mjs__WEBPACK_IMPORTED_MODULE_11__.OWN_PROPS_NAME, subOwnownProps), subtype(current);\n        }\n      };\n    }\n  }\n};\nvar types = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  any: AnyType,\n  array: ArrayType,\n  block: BlockType,\n  boolean: BooleanType,\n  crossDatasetReference: CrossDatasetReferenceType,\n  date: DateType,\n  datetime: DateTimeType,\n  document: DocumentType,\n  email: EmailType,\n  file: FileType,\n  globalDocumentReference: GlobalDocumentReferenceType,\n  image: ImageType,\n  number: NumberType,\n  object: ObjectType,\n  reference: ReferenceType,\n  span: SpanType,\n  string: StringType,\n  text: TextType,\n  url: UrlType\n});\nfunction compileRegistry(schemaDef) {\n  const registry = /* @__PURE__ */ Object.create(null);\n  let localTypeNames;\n  schemaDef.parent ? (Object.assign(registry, schemaDef.parent._registry), localTypeNames = []) : (Object.assign(registry, types), localTypeNames = Object.keys(types));\n  const defsByName = schemaDef.types.reduce((acc, def) => {\n    if (acc[def.name])\n      throw new Error(`Duplicate type name added to schema: ${def.name}`);\n    return acc[def.name] = def, acc;\n  }, {});\n  return schemaDef.types.forEach(add), {\n    registry,\n    localTypeNames\n  };\n  function ensure(typeName) {\n    if (!registry[typeName]) {\n      if (!defsByName[typeName])\n        throw new Error(`Unknown type: ${typeName}`);\n      add(defsByName[typeName]);\n    }\n  }\n  function extendMember(memberDef) {\n    return ensure(memberDef.type), registry[memberDef.type].extend(memberDef, extendMember).get();\n  }\n  function add(typeDef) {\n    ensure(typeDef.type), !registry[typeDef.name] && (localTypeNames.push(typeDef.name), registry[typeDef.name] = registry[typeDef.type].extend(typeDef, extendMember));\n  }\n}\nlet Schema$1 = class Schema {\n  _original;\n  _registry;\n  #localTypeNames;\n  static compile(schemaDef) {\n    return new Schema(schemaDef);\n  }\n  constructor(schemaDef) {\n    this._original = schemaDef;\n    const { registry, localTypeNames } = compileRegistry(schemaDef);\n    this._registry = registry, this.#localTypeNames = localTypeNames;\n  }\n  get name() {\n    return this._original.name;\n  }\n  /**\n   * Returns the parent schema.\n   */\n  get parent() {\n    return this._original.parent;\n  }\n  get(name) {\n    return this._registry[name] && this._registry[name].get();\n  }\n  has(name) {\n    return name in this._registry;\n  }\n  getTypeNames() {\n    return Object.keys(this._registry);\n  }\n  getLocalTypeNames() {\n    return this.#localTypeNames;\n  }\n};\nclass DeprecatedDefaultSchema extends Schema$1 {\n  static compile(schemaDef) {\n    return new DeprecatedDefaultSchema(schemaDef);\n  }\n  constructor(schemaDef) {\n    super(schemaDef);\n    const stack = new Error(\n      'The default export of `@sanity/schema` is deprecated. Use `import {Schema} from \"@sanity/schema\"` instead.'\n    ).stack.replace(/^Error/, \"Warning\");\n    console.warn(stack);\n  }\n}\nconst Schema2 = Schema$1;\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrc2NoZW1hQDMuOTkuMF9AdHlwZXMrcmVhY3RAMTguMy4yNF9kZWJ1Z0A0LjQuMy9ub2RlX21vZHVsZXMvQHNhbml0eS9zY2hlbWEvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNBO0FBQ2dIO0FBQ3RIO0FBQ29CO0FBQ1Y7QUFDUTtBQUNGO0FBQ0o7QUFDSTtBQUNRO0FBQ2Q7QUFDdEMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlDQUFpQyxnRkFBMkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQ0FBSTtBQUMvQixPQUFPO0FBQ1AsS0FBSyx5QkFBeUIsMkNBQUk7QUFDbEM7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLG1FQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQ0FBSSxnRUFBZ0U7QUFDbEc7QUFDQSxXQUFXO0FBQ1gsdUNBQXVDLG1FQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkIsZ0ZBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUMsMkNBQUk7QUFDckM7QUFDQSxLQUFLO0FBQ0wsNkhBQTZILG1FQUFjLFdBQVcsOEJBQThCO0FBQ3BMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBzYW5pdHkrc2NoZW1hQDMuOTkuMF9AdHlwZXMrcmVhY3RAMTguMy4yNF9kZWJ1Z0A0LjQuM1xcbm9kZV9tb2R1bGVzXFxAc2FuaXR5XFxzY2hlbWFcXGxpYlxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvbWl0IGZyb20gXCJsb2Rhc2gvb21pdC5qc1wiO1xuaW1wb3J0IHBpY2sgZnJvbSBcImxvZGFzaC9waWNrLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFMsIE9XTl9QUk9QU19OQU1FLCByZXNvbHZlU2VhcmNoQ29uZmlnRm9yQmFzZUZpZWxkUGF0aHMsIHJlc29sdmVTZWFyY2hDb25maWcgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3Jlc29sdmUubWpzXCI7XG5pbXBvcnQgYXJyaWZ5IGZyb20gXCJhcnJpZnlcIjtcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tIFwibG9kYXNoL2lzVW5kZWZpbmVkLmpzXCI7XG5pbXBvcnQgb21pdEJ5IGZyb20gXCJsb2Rhc2gvb21pdEJ5LmpzXCI7XG5pbXBvcnQgY2FwaXRhbGl6ZSBmcm9tIFwibG9kYXNoL2NhcGl0YWxpemUuanNcIjtcbmltcG9ydCBjYXN0QXJyYXkgZnJvbSBcImxvZGFzaC9jYXN0QXJyYXkuanNcIjtcbmltcG9ydCBmbGF0TWFwIGZyb20gXCJsb2Rhc2gvZmxhdE1hcC5qc1wiO1xuaW1wb3J0IHN0YXJ0Q2FzZSBmcm9tIFwibG9kYXNoL3N0YXJ0Q2FzZS5qc1wiO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSBcImxvZGFzaC9pc1BsYWluT2JqZWN0LmpzXCI7XG5pbXBvcnQgdG9QYXRoIGZyb20gXCJsb2Rhc2gvdG9QYXRoLmpzXCI7XG5mdW5jdGlvbiBsYXp5R2V0dGVyKHRhcmdldCwga2V5LCBnZXR0ZXIsIGNvbmZpZyA9IHt9KSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6IGNvbmZpZy5lbnVtZXJhYmxlICE9PSAhMSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCB2YWwgPSBnZXR0ZXIoKTtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgd3JpdGFibGU6ICEhY29uZmlnLndyaXRhYmxlLFxuICAgICAgICBjb25maWd1cmFibGU6ICExXG4gICAgICB9KSwgdmFsO1xuICAgIH1cbiAgfSksIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGhpZGRlbkdldHRlcih0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogITEsXG4gICAgd3JpdGFibGU6ICExLFxuICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgdmFsdWVcbiAgfSk7XG59XG5jb25zdCBPVkVSUklEQUJMRV9GSUVMRFMkZiA9IFsuLi5ERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFNdLCBBTllfQ09SRSA9IHtcbiAgbmFtZTogXCJhbnlcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwiYW55XCJcbn0sIEFueVR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gQU5ZX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmLCBleHRlbmRNZW1iZXIpIHtcbiAgICBjb25zdCBvd25Qcm9wcyA9IHtcbiAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICBvZjogc3ViVHlwZURlZi5vZi5tYXAoKGZpZWxkRGVmKSA9PiAoe1xuICAgICAgICBuYW1lOiBmaWVsZERlZi5uYW1lLFxuICAgICAgICB0eXBlOiBleHRlbmRNZW1iZXIob21pdChmaWVsZERlZiwgXCJuYW1lXCIpKVxuICAgICAgfSkpXG4gICAgfSwgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKEFOWV9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkZiksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBBTllfQ09SRVxuICAgIH0pO1xuICAgIHJldHVybiBoaWRkZW5HZXR0ZXIocGFyc2VkLCBPV05fUFJPUFNfTkFNRSwgb3duUHJvcHMpLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLm9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcnJpZGUgYG9mYCBwcm9wZXJ0eSBvZiBzdWJ0eXBlcyBvZiBcImFycmF5XCInKTtcbiAgICAgICAgICBjb25zdCBzdWJPd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBPVkVSUklEQUJMRV9GSUVMRFMkZiksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIHN1Yk93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBzdWJPd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59LCBPVkVSUklEQUJMRV9GSUVMRFMkZSA9IFsuLi5ERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFNdLCBBUlJBWV9DT1JFID0ge1xuICBuYW1lOiBcImFycmF5XCIsXG4gIHR5cGU6IG51bGwsXG4gIGpzb25UeXBlOiBcImFycmF5XCIsXG4gIG9mOiBbXVxufSwgQXJyYXlUeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIEFSUkFZX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmLCBjcmVhdGVNZW1iZXJUeXBlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKEFSUkFZX0NPUkUsIE9WRVJSSURBQkxFX0ZJRUxEUyRlKSwgc3ViVHlwZURlZiwge1xuICAgICAgdHlwZTogQVJSQVlfQ09SRVxuICAgIH0pO1xuICAgIHJldHVybiBsYXp5R2V0dGVyKHBhcnNlZCwgXCJvZlwiLCAoKSA9PiBzdWJUeXBlRGVmLm9mLm1hcCgob2ZUeXBlRGVmKSA9PiBjcmVhdGVNZW1iZXJUeXBlKG9mVHlwZURlZikpKSwgbGF6eUdldHRlcihwYXJzZWQsIE9XTl9QUk9QU19OQU1FLCAoKSA9PiAoeyAuLi5zdWJUeXBlRGVmLCBvZjogcGFyc2VkLm9mIH0pLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIHdyaXRhYmxlOiAhMVxuICAgIH0pLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLm9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcnJpZGUgYG9mYCBwcm9wZXJ0eSBvZiBzdWJ0eXBlcyBvZiBcImFycmF5XCInKTtcbiAgICAgICAgICBjb25zdCBvd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBPVkVSUklEQUJMRV9GSUVMRFMkZSksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIG93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gd2FybklmUHJldmlld09uT3B0aW9ucyh0eXBlKSB7XG4gIHR5cGUub3B0aW9ucyAmJiB0eXBlLm9wdGlvbnMucHJldmlldyAmJiBjb25zb2xlLndhcm4oYEhlYWRzIHVwISBUaGUgcHJldmlldyBjb25maWcgaXMgbm8gbG9uZ2VyIGRlZmluZWQgb24gXCJvcHRpb25zXCIsIGJ1dCBpbnN0ZWFkIG9uIHRoZSB0eXBlL2ZpZWxkIGl0c2VsZi5cblBsZWFzZSBtb3ZlIHtvcHRpb25zOiB7cHJldmlldzogLi4ufX0gdG8gey4uLiwgcHJldmlldzogLi4ufSBvbiB0aGUgdHlwZS9maWVsZCBkZWZpbml0aW9uIG9mIFwiJHt0eXBlLm5hbWV9XCIuXG5gKTtcbn1cbmZ1bmN0aW9uIHdhcm5JZlByZXZpZXdIYXNGaWVsZHModHlwZSkge1xuICBjb25zdCBwcmV2aWV3ID0gdHlwZS5wcmV2aWV3IHx8ICh0eXBlLm9wdGlvbnMgfHwge30pLnByZXZpZXc7XG4gIHByZXZpZXcgJiYgXCJmaWVsZHNcIiBpbiBwcmV2aWV3ICYmIGNvbnNvbGUud2FybihgSGVhZHMgdXAhIFwicHJldmlldy5maWVsZHNcIiBzaG91bGQgYmUgcmVuYW1lZCB0byBcInByZXZpZXcuc2VsZWN0XCIuIFBsZWFzZSB1cGRhdGUgdGhlIHByZXZpZXcgY29uZmlnIGZvciBcIiR7dHlwZS5uYW1lfVwiLlxuYCk7XG59XG5mdW5jdGlvbiBpc0VtcHR5KG9iamVjdCkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpXG4gICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zLCBkZXB0aCkge1xuICBpZiAoZGVwdGggPiBvcHRpb25zLm1heERlcHRoKVxuICAgIHJldHVybiBcIi4uLlwiO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFwiW2VtcHR5XVwiO1xuICAgIGNvbnN0IGNhcExlbmd0aCA9IE1hdGgubWF4KHZhbHVlLmxlbmd0aCAtIG9wdGlvbnMubWF4QnJlYWR0aCksIGFzU3RyaW5nMiA9IHZhbHVlLnNsaWNlKDAsIG9wdGlvbnMubWF4QnJlYWR0aCkubWFwKChpdGVtLCBpbmRleCkgPT4gX3N0cmluZ2lmeShpdGVtLCBvcHRpb25zLCBkZXB0aCArIDEpKS5jb25jYXQoY2FwTGVuZ3RoID4gMCA/IGBcXHUyMDI2KyR7Y2FwTGVuZ3RofWAgOiBbXSkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBkZXB0aCA9PT0gMCA/IGFzU3RyaW5nMiA6IGBbJHthc1N0cmluZzJ9XWA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoXG4gICAgICAoa2V5KSA9PiAhb3B0aW9ucy5pZ25vcmVLZXlzLmluY2x1ZGVzKGtleSkgJiYgdHlwZW9mIHZhbHVlW2tleV0gPCBcInVcIlxuICAgICk7XG4gICAgaWYgKGlzRW1wdHkocGljayh2YWx1ZSwga2V5cykpKVxuICAgICAgcmV0dXJuIFwie2VtcHR5fVwiO1xuICAgIGNvbnN0IGFzU3RyaW5nMiA9IGtleXMuc2xpY2UoMCwgb3B0aW9ucy5tYXhCcmVhZHRoKS5tYXAoKGtleSkgPT4gYCR7a2V5fTogJHtfc3RyaW5naWZ5KHZhbHVlW2tleV0sIG9wdGlvbnMsIGRlcHRoICsgMSl9YCkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBkZXB0aCA9PT0gMCA/IGFzU3RyaW5nMiA6IGB7JHthc1N0cmluZzJ9fWA7XG4gIH1cbiAgY29uc3QgYXNTdHJpbmcgPSBTdHJpbmcodmFsdWUpO1xuICByZXR1cm4gYXNTdHJpbmcgPT09IFwiXCIgPyAnXCJcIicgOiBhc1N0cmluZztcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgbWF4RGVwdGg6IFwibWF4RGVwdGhcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5tYXhEZXB0aCA6IDIsXG4gICAgbWF4QnJlYWR0aDogXCJtYXhCcmVhZHRoXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWF4QnJlYWR0aCA6IDIsXG4gICAgaWdub3JlS2V5czogXCJpZ25vcmVLZXlzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaWdub3JlS2V5cyA6IFtdXG4gIH07XG4gIHJldHVybiBfc3RyaW5naWZ5KHZhbHVlLCBvcHRzLCAwKTtcbn1cbmNvbnN0IE9QVElPTlMgPSB7XG4gIG1heEVudHJpZXM6IDIsXG4gIG1heERlcHRoOiAyLFxuICBtYXhCcmVhZHRoOiAyLFxuICBpZ25vcmVLZXlzOiBbXCJfaWRcIiwgXCJfdHlwZVwiLCBcIl9rZXlcIiwgXCJfcmVmXCJdXG59O1xuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tQcmVwYXJlKGZpZWxkTmFtZXMpIHtcbiAgcmV0dXJuICh2YWx1ZSkgPT4gKHtcbiAgICB0aXRsZTogc3RyaW5naWZ5KHBpY2sodmFsdWUsIGZpZWxkTmFtZXMpLCBPUFRJT05TKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tGaWVsZChmaWVsZCkge1xuICByZXR1cm4gZmllbGQudHlwZSA9PT0gXCJhcnJheVwiICYmIGZpZWxkLm9mICYmIGZpZWxkLm9mLnNvbWUoKG1lbWJlcikgPT4gbWVtYmVyLnR5cGUgPT09IFwiYmxvY2tcIikgfHwgITE7XG59XG5jb25zdCBUSVRMRV9DQU5ESURBVEVTID0gW1widGl0bGVcIiwgXCJuYW1lXCIsIFwibGFiZWxcIiwgXCJoZWFkaW5nXCIsIFwiaGVhZGVyXCIsIFwiY2FwdGlvblwiXSwgREVTQ1JJUFRJT05fQ0FORElEQVRFUyA9IFtcImRlc2NyaXB0aW9uXCIsIC4uLlRJVExFX0NBTkRJREFURVNdO1xuZnVuY3Rpb24gZmllbGRIYXNSZWZlcmVuY2VUbyhmaWVsZERlZiwgcmVmVHlwZSkge1xuICByZXR1cm4gYXJyaWZ5KGZpZWxkRGVmLnRvIHx8IFtdKS5zb21lKChtZW1iZXJUeXBlRGVmKSA9PiBtZW1iZXJUeXBlRGVmLnR5cGUgPT09IHJlZlR5cGUpO1xufVxuZnVuY3Rpb24gaXNJbWFnZUFzc2V0RmllbGQoZmllbGREZWYpIHtcbiAgcmV0dXJuIGZpZWxkSGFzUmVmZXJlbmNlVG8oZmllbGREZWYsIFwic2FuaXR5LmltYWdlQXNzZXRcIik7XG59XG5mdW5jdGlvbiByZXNvbHZlSW1hZ2VBc3NldFBhdGgodHlwZURlZikge1xuICBjb25zdCBmaWVsZHMgPSB0eXBlRGVmLmZpZWxkcyB8fCBbXSwgaW1hZ2VBc3NldEZpZWxkID0gZmllbGRzLmZpbmQoaXNJbWFnZUFzc2V0RmllbGQpO1xuICBpZiAoaW1hZ2VBc3NldEZpZWxkKVxuICAgIHJldHVybiBpbWFnZUFzc2V0RmllbGQubmFtZTtcbiAgY29uc3QgZmllbGRXaXRoSW1hZ2VBc3NldCA9IGZpZWxkcy5maW5kKFxuICAgIChmaWVsZERlZikgPT4gKGZpZWxkRGVmLmZpZWxkcyB8fCBbXSkuc29tZShpc0ltYWdlQXNzZXRGaWVsZClcbiAgKTtcbiAgcmV0dXJuIGZpZWxkV2l0aEltYWdlQXNzZXQgPyBgJHtmaWVsZFdpdGhJbWFnZUFzc2V0Lm5hbWV9LmFzc2V0YCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzRmlsZUFzc2V0RmllbGQoZmllbGREZWYpIHtcbiAgcmV0dXJuIGZpZWxkSGFzUmVmZXJlbmNlVG8oZmllbGREZWYsIFwic2FuaXR5LmZpbGVBc3NldFwiKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGaWxlQXNzZXRQYXRoKHR5cGVEZWYpIHtcbiAgY29uc3QgZmllbGRzID0gdHlwZURlZi5maWVsZHMgfHwgW10sIGFzc2V0RmllbGQgPSBmaWVsZHMuZmluZChpc0ZpbGVBc3NldEZpZWxkKTtcbiAgaWYgKGFzc2V0RmllbGQpXG4gICAgcmV0dXJuIGFzc2V0RmllbGQubmFtZTtcbiAgY29uc3QgZmllbGRXaXRoRmlsZUFzc2V0ID0gZmllbGRzLmZpbmQoXG4gICAgKGZpZWxkRGVmKSA9PiAoZmllbGREZWYuZmllbGRzIHx8IFtdKS5zb21lKGlzRmlsZUFzc2V0RmllbGQpXG4gICk7XG4gIHJldHVybiBmaWVsZFdpdGhGaWxlQXNzZXQgPyBgJHtmaWVsZFdpdGhGaWxlQXNzZXQubmFtZX0uYXNzZXRgIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ3Vlc3NQcmV2aWV3RmllbGRzKHJhd09iamVjdFR5cGVEZWYpIHtcbiAgY29uc3Qgb2JqZWN0VHlwZURlZiA9IHsgZmllbGRzOiBbXSwgLi4ucmF3T2JqZWN0VHlwZURlZiB9LCBzdHJpbmdGaWVsZE5hbWVzID0gb2JqZWN0VHlwZURlZi5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gZmllbGQudHlwZSA9PT0gXCJzdHJpbmdcIikubWFwKChmaWVsZCkgPT4gZmllbGQubmFtZSksIGJsb2NrRmllbGROYW1lcyA9IG9iamVjdFR5cGVEZWYuZmllbGRzLmZpbHRlcihpc0Jsb2NrRmllbGQpLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpO1xuICBsZXQgdGl0bGVGaWVsZCA9IFRJVExFX0NBTkRJREFURVMuZmluZChcbiAgICAoY2FuZGlkYXRlKSA9PiBzdHJpbmdGaWVsZE5hbWVzLmluY2x1ZGVzKGNhbmRpZGF0ZSkgfHwgYmxvY2tGaWVsZE5hbWVzLmluY2x1ZGVzKGNhbmRpZGF0ZSlcbiAgKSwgZGVzY0ZpZWxkID0gREVTQ1JJUFRJT05fQ0FORElEQVRFUy5maW5kKFxuICAgIChjYW5kaWRhdGUpID0+IGNhbmRpZGF0ZSAhPT0gdGl0bGVGaWVsZCAmJiAoc3RyaW5nRmllbGROYW1lcy5pbmNsdWRlcyhjYW5kaWRhdGUpIHx8IGJsb2NrRmllbGROYW1lcy5pbmNsdWRlcyhjYW5kaWRhdGUpKVxuICApO1xuICB0aXRsZUZpZWxkIHx8ICh0aXRsZUZpZWxkID0gc3RyaW5nRmllbGROYW1lc1swXSB8fCBibG9ja0ZpZWxkTmFtZXNbMF0sIGRlc2NGaWVsZCA9IHN0cmluZ0ZpZWxkTmFtZXNbMV0gfHwgYmxvY2tGaWVsZE5hbWVzWzFdKTtcbiAgY29uc3QgbWVkaWFGaWVsZCA9IG9iamVjdFR5cGVEZWYuZmllbGRzLmZpbmQoKGZpZWxkKSA9PiBmaWVsZC50eXBlID09PSBcImltYWdlXCIpLCBpbWFnZUFzc2V0UGF0aCA9IHJlc29sdmVJbWFnZUFzc2V0UGF0aChvYmplY3RUeXBlRGVmKTtcbiAgaWYgKCF0aXRsZUZpZWxkKSB7XG4gICAgY29uc3QgZmlsZUFzc2V0UGF0aCA9IHJlc29sdmVGaWxlQXNzZXRQYXRoKG9iamVjdFR5cGVEZWYpO1xuICAgIGZpbGVBc3NldFBhdGggJiYgKHRpdGxlRmllbGQgPSBgJHtmaWxlQXNzZXRQYXRofS5vcmlnaW5hbEZpbGVuYW1lYCksIGltYWdlQXNzZXRQYXRoICYmICh0aXRsZUZpZWxkID0gYCR7aW1hZ2VBc3NldFBhdGh9Lm9yaWdpbmFsRmlsZW5hbWVgKTtcbiAgfVxuICBpZiAoIXRpdGxlRmllbGQgJiYgIWltYWdlQXNzZXRQYXRoKSB7XG4gICAgY29uc3QgZmllbGROYW1lcyA9IG9iamVjdFR5cGVEZWYuZmllbGRzLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3Q6IGZpZWxkTmFtZXMucmVkdWNlKChhY2MsIGZpZWxkTmFtZSkgPT4gKGFjY1tmaWVsZE5hbWVdID0gZmllbGROYW1lLCBhY2MpLCB7fSksXG4gICAgICBwcmVwYXJlOiBjcmVhdGVGYWxsYmFja1ByZXBhcmUoZmllbGROYW1lcylcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2VsZWN0OiBvbWl0QnkoXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiB0aXRsZUZpZWxkLFxuICAgICAgICBkZXNjcmlwdGlvbjogZGVzY0ZpZWxkLFxuICAgICAgICBtZWRpYTogbWVkaWFGaWVsZCA/IG1lZGlhRmllbGQubmFtZSA6IGltYWdlQXNzZXRQYXRoXG4gICAgICB9LFxuICAgICAgaXNVbmRlZmluZWRcbiAgICApXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIHNlbGVjdGlvbi5yZWR1Y2UoKGFjYywgZmllbGQpID0+IChhY2NbZmllbGRdID0gZmllbGQsIGFjYyksIHt9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJldmlldyhwcmV2aWV3KSB7XG4gIGlmICghcHJldmlldylcbiAgICByZXR1cm4gcHJldmlldztcbiAgY29uc3Qgc2VsZWN0ID0gcHJldmlldy5zZWxlY3QgfHwgcHJldmlldy5maWVsZHMgfHwge307XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHNlbGVjdCkgPyB7XG4gICAgLi4ucGljayhwcmV2aWV3LCBbXCJwcmVwYXJlXCIsIFwiY29tcG9uZW50XCJdKSxcbiAgICBzZWxlY3Q6IHBhcnNlU2VsZWN0aW9uKHNlbGVjdClcbiAgfSA6IHtcbiAgICAuLi5waWNrKHByZXZpZXcsIFtcInByZXBhcmVcIiwgXCJjb21wb25lbnRcIl0pLFxuICAgIHNlbGVjdFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUHJldmlld0dldHRlcihvYmplY3RUeXBlRGVmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd2FybklmUHJldmlld09uT3B0aW9ucyhvYmplY3RUeXBlRGVmKSwgd2FybklmUHJldmlld0hhc0ZpZWxkcyhvYmplY3RUeXBlRGVmKSwgcGFyc2VQcmV2aWV3KG9iamVjdFR5cGVEZWYucHJldmlldyB8fCAob2JqZWN0VHlwZURlZi5vcHRpb25zIHx8IHt9KS5wcmV2aWV3KSB8fCBndWVzc1ByZXZpZXdGaWVsZHMob2JqZWN0VHlwZURlZik7XG4gIH07XG59XG5jb25zdCBERUZBVUxUX0xJTktfQU5OT1RBVElPTiA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgbmFtZTogXCJsaW5rXCIsXG4gIHRpdGxlOiBcIkxpbmtcIixcbiAgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmFubm90YXRpb24ubGlua1wiLFxuICBvcHRpb25zOiB7XG4gICAgbW9kYWw6IHsgdHlwZTogXCJwb3BvdmVyXCIgfVxuICB9LFxuICBmaWVsZHM6IFtcbiAgICB7XG4gICAgICBuYW1lOiBcImhyZWZcIixcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICB0aXRsZTogXCJMaW5rXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBIHZhbGlkIHdlYiwgZW1haWwsIHBob25lLCBvciByZWxhdGl2ZSBsaW5rLlwiLFxuICAgICAgdmFsaWRhdGlvbjogKFJ1bGUpID0+IFJ1bGUudXJpKHtcbiAgICAgICAgc2NoZW1lOiBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJ0ZWxcIiwgXCJtYWlsdG9cIl0sXG4gICAgICAgIGFsbG93UmVsYXRpdmU6ICEwXG4gICAgICB9KVxuICAgIH1cbiAgXVxufSwgREVGQVVMVF9URVhUX0ZJRUxEID0ge1xuICB0eXBlOiBcInRleHRcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHRpdGxlOiBcIlRleHRcIlxufSwgREVGQVVMVF9NQVJLU19GSUVMRCA9IHtcbiAgbmFtZTogXCJtYXJrc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIG9mOiBbeyB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICB0aXRsZTogXCJNYXJrc1wiXG59LCBMSVNUX1RZUEVTID0ge1xuICBidWxsZXQ6IHtcbiAgICB0aXRsZTogXCJCdWxsZXRlZCBsaXN0XCIsXG4gICAgdmFsdWU6IFwiYnVsbGV0XCIsXG4gICAgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0Lmxpc3QtdHlwZS5idWxsZXRcIlxuICB9LFxuICBudW1iZXJlZDoge1xuICAgIHRpdGxlOiBcIk51bWJlcmVkIGxpc3RcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBpMThuVGl0bGVLZXk6IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQubGlzdC10eXBlLm51bWJlclwiXG4gIH1cbn0sIERFRkFVTFRfTElTVF9UWVBFUyA9IFtMSVNUX1RZUEVTLmJ1bGxldCwgTElTVF9UWVBFUy5udW1iZXJlZF0sIEJMT0NLX1NUWUxFUyA9IHtcbiAgbm9ybWFsOiB7IHRpdGxlOiBcIk5vcm1hbFwiLCB2YWx1ZTogXCJub3JtYWxcIiwgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LnN0eWxlLm5vcm1hbFwiIH0sXG4gIGgxOiB7IHRpdGxlOiBcIkhlYWRpbmcgMVwiLCB2YWx1ZTogXCJoMVwiLCBpMThuVGl0bGVLZXk6IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuc3R5bGUuaDFcIiB9LFxuICBoMjogeyB0aXRsZTogXCJIZWFkaW5nIDJcIiwgdmFsdWU6IFwiaDJcIiwgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LnN0eWxlLmgyXCIgfSxcbiAgaDM6IHsgdGl0bGU6IFwiSGVhZGluZyAzXCIsIHZhbHVlOiBcImgzXCIsIGkxOG5UaXRsZUtleTogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5zdHlsZS5oM1wiIH0sXG4gIGg0OiB7IHRpdGxlOiBcIkhlYWRpbmcgNFwiLCB2YWx1ZTogXCJoNFwiLCBpMThuVGl0bGVLZXk6IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuc3R5bGUuaDRcIiB9LFxuICBoNTogeyB0aXRsZTogXCJIZWFkaW5nIDVcIiwgdmFsdWU6IFwiaDVcIiwgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LnN0eWxlLmg1XCIgfSxcbiAgaDY6IHsgdGl0bGU6IFwiSGVhZGluZyA2XCIsIHZhbHVlOiBcImg2XCIsIGkxOG5UaXRsZUtleTogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5zdHlsZS5oNlwiIH0sXG4gIGJsb2NrcXVvdGU6IHtcbiAgICB0aXRsZTogXCJRdW90ZVwiLFxuICAgIHZhbHVlOiBcImJsb2NrcXVvdGVcIixcbiAgICBpMThuVGl0bGVLZXk6IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuc3R5bGUucXVvdGVcIlxuICB9XG59LCBERUZBVUxUX0JMT0NLX1NUWUxFUyA9IFtcbiAgQkxPQ0tfU1RZTEVTLm5vcm1hbCxcbiAgQkxPQ0tfU1RZTEVTLmgxLFxuICBCTE9DS19TVFlMRVMuaDIsXG4gIEJMT0NLX1NUWUxFUy5oMyxcbiAgQkxPQ0tfU1RZTEVTLmg0LFxuICBCTE9DS19TVFlMRVMuaDUsXG4gIEJMT0NLX1NUWUxFUy5oNixcbiAgQkxPQ0tfU1RZTEVTLmJsb2NrcXVvdGVcbl0sIERFQ09SQVRPUl9TVFJPTkcgPSB7XG4gIHRpdGxlOiBcIlN0cm9uZ1wiLFxuICB2YWx1ZTogXCJzdHJvbmdcIixcbiAgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmRlY29yYXRvci5zdHJvbmdcIlxufSwgREVDT1JBVE9SX0VNUEhBU0lTID0ge1xuICB0aXRsZTogXCJJdGFsaWNcIixcbiAgdmFsdWU6IFwiZW1cIixcbiAgaTE4blRpdGxlS2V5OiBcImlucHV0cy5wb3J0YWJsZS10ZXh0LmRlY29yYXRvci5lbXBoYXNpc1wiXG59LCBERUNPUkFUT1JfQ09ERSA9IHtcbiAgdGl0bGU6IFwiQ29kZVwiLFxuICB2YWx1ZTogXCJjb2RlXCIsXG4gIGkxOG5UaXRsZUtleTogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5kZWNvcmF0b3IuY29kZVwiXG59LCBERUNPUkFUT1JfVU5ERVJMSU5FID0ge1xuICB0aXRsZTogXCJVbmRlcmxpbmVcIixcbiAgdmFsdWU6IFwidW5kZXJsaW5lXCIsXG4gIGkxOG5UaXRsZUtleTogXCJpbnB1dHMucG9ydGFibGUtdGV4dC5kZWNvcmF0b3IudW5kZXJsaW5lXCJcbn0sIERFQ09SQVRPUl9TVFJJS0UgPSB7XG4gIHRpdGxlOiBcIlN0cmlrZVwiLFxuICB2YWx1ZTogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBpMThuVGl0bGVLZXk6IFwiaW5wdXRzLnBvcnRhYmxlLXRleHQuZGVjb3JhdG9yLnN0cmlrZS10aHJvdWdoXCJcbn0sIERFQ09SQVRPUlMgPSB7XG4gIHN0cm9uZzogREVDT1JBVE9SX1NUUk9ORyxcbiAgZW06IERFQ09SQVRPUl9FTVBIQVNJUyxcbiAgY29kZTogREVDT1JBVE9SX0NPREUsXG4gIHVuZGVybGluZTogREVDT1JBVE9SX1VOREVSTElORSxcbiAgc3RyaWtlVGhyb3VnaDogREVDT1JBVE9SX1NUUklLRVxufSwgREVGQVVMVF9ERUNPUkFUT1JTID0gW1xuICBERUNPUkFUT1JTLnN0cm9uZyxcbiAgREVDT1JBVE9SUy5lbSxcbiAgREVDT1JBVE9SUy5jb2RlLFxuICBERUNPUkFUT1JTLnVuZGVybGluZSxcbiAgREVDT1JBVE9SUy5zdHJpa2VUaHJvdWdoXG5dLCBJTkhFUklURURfRklFTERTJDEgPSBbXG4gIFwidHlwZVwiLFxuICBcIm5hbWVcIixcbiAgXCJ0aXRsZVwiLFxuICBcImpzb25UeXBlXCIsXG4gIFwiZGVzY3JpcHRpb25cIixcbiAgXCJvcHRpb25zXCIsXG4gIFwiZmllbGRzZXRzXCIsXG4gIFwiaWNvblwiXG5dLCBCTE9DS19DT1JFID0ge1xuICBuYW1lOiBcImJsb2NrXCIsXG4gIHRpdGxlOiBcIkJsb2NrXCIsXG4gIHR5cGU6IG51bGwsXG4gIGpzb25UeXBlOiBcIm9iamVjdFwiXG59LCBERUZBVUxUX09QVElPTlMkMyA9IHt9LCBCbG9ja1R5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gQkxPQ0tfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHN1YlR5cGVEZWYsIGV4dGVuZE1lbWJlcikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLnN1YlR5cGVEZWYub3B0aW9ucyB8fCBERUZBVUxUX09QVElPTlMkMyB9LCB7IG1hcmtzLCBzdHlsZXMsIGxpc3RzLCBvZiwgLi4ucmVzdCB9ID0gc3ViVHlwZURlZiwgY2hpbGRyZW5GaWVsZCA9IGNyZWF0ZUNoaWxkcmVuRmllbGQobWFya3MsIG9mKSwgc3R5bGVGaWVsZCA9IGNyZWF0ZVN0eWxlRmllbGQoc3R5bGVzKSwgbGlzdEl0ZW1GaWVsZCA9IGNyZWF0ZUxpc3RJdGVtRmllbGQobGlzdHMpLCBtYXJrRGVmc0ZpZWxkID0ge1xuICAgICAgbmFtZTogXCJtYXJrRGVmc1wiLFxuICAgICAgdGl0bGU6IFwiTWFyayBkZWZpbml0aW9uc1wiLFxuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgb2Y6IG1hcmtzPy5hbm5vdGF0aW9ucyB8fCBERUZBVUxUX0FOTk9UQVRJT05TXG4gICAgfSwgZmllbGRzID0gW2NoaWxkcmVuRmllbGQsIHN0eWxlRmllbGQsIGxpc3RJdGVtRmllbGQsIG1hcmtEZWZzRmllbGQsIHtcbiAgICAgIG5hbWU6IFwibGV2ZWxcIixcbiAgICAgIHRpdGxlOiBcIkluZGVudGF0aW9uXCIsXG4gICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgfV0uY29uY2F0KFxuICAgICAgc3ViVHlwZURlZi5maWVsZHMgfHwgW11cbiAgICApLCBvd25Qcm9wcyA9IHsgLi4ucmVzdCwgb3B0aW9ucyB9LCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKHBpY2soQkxPQ0tfQ09SRSwgSU5IRVJJVEVEX0ZJRUxEUyQxKSwgb3duUHJvcHMsIHtcbiAgICAgIHR5cGU6IEJMT0NLX0NPUkVcbiAgICB9KTtcbiAgICByZXR1cm4gbGF6eUdldHRlcihwYXJzZWQsIFwiZmllbGRzXCIsICgpID0+IGZpZWxkcy5tYXAoKGZpZWxkRGVmKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLnR5cGUgfSA9IGZpZWxkRGVmO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdHlwZTogZXh0ZW5kTWVtYmVyKHR5cGUpXG4gICAgICB9O1xuICAgIH0pKSwgbGF6eUdldHRlcihwYXJzZWQsIFwicHJldmlld1wiLCBjcmVhdGVQcmV2aWV3R2V0dGVyKHN1YlR5cGVEZWYpKSwgbGF6eUdldHRlcihcbiAgICAgIHBhcnNlZCxcbiAgICAgIE9XTl9QUk9QU19OQU1FLFxuICAgICAgKCkgPT4gKHtcbiAgICAgICAgLi4ub3duUHJvcHMsXG4gICAgICAgIGZpZWxkczogcGFyc2VkLmZpZWxkcyxcbiAgICAgICAgcHJldmlldzogcGFyc2VkLnByZXZpZXdcbiAgICAgIH0pLFxuICAgICAgeyBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICExIH1cbiAgICApLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLmZpZWxkcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJyaWRlIGBmaWVsZHNgIG9mIHN1YnR5cGVzIG9mIFwiYmxvY2tcIicpO1xuICAgICAgICAgIGNvbnN0IHN1Yk93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIElOSEVSSVRFRF9GSUVMRFMkMSksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIHN1Yk93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBzdWJPd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gZW5zdXJlTm9ybWFsU3R5bGUoc3R5bGVzKSB7XG4gIHJldHVybiBzdHlsZXMuc29tZSgoc3R5bGUpID0+IHN0eWxlLnZhbHVlID09PSBcIm5vcm1hbFwiKSA/IHN0eWxlcyA6IFtCTE9DS19TVFlMRVMubm9ybWFsLCAuLi5zdHlsZXNdO1xufVxuZnVuY3Rpb24gY3JlYXRlU3R5bGVGaWVsZChzdHlsZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcInN0eWxlXCIsXG4gICAgdGl0bGU6IFwiU3R5bGVcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGxpc3Q6IGVuc3VyZU5vcm1hbFN0eWxlKHN0eWxlcyB8fCBERUZBVUxUX0JMT0NLX1NUWUxFUylcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMaXN0SXRlbUZpZWxkKGxpc3RzKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJsaXN0SXRlbVwiLFxuICAgIHRpdGxlOiBcIkxpc3QgdHlwZVwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgb3B0aW9uczoge1xuICAgICAgbGlzdDogbGlzdHMgfHwgREVGQVVMVF9MSVNUX1RZUEVTXG4gICAgfVxuICB9O1xufVxuY29uc3QgREVGQVVMVF9BTk5PVEFUSU9OUyA9IFtERUZBVUxUX0xJTktfQU5OT1RBVElPTl07XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkZpZWxkKG1hcmtzLCBvZiA9IFtdKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJjaGlsZHJlblwiLFxuICAgIHRpdGxlOiBcIkNvbnRlbnRcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgb2Y6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIGZpZWxkczogW0RFRkFVTFRfVEVYVF9GSUVMRCwgREVGQVVMVF9NQVJLU19GSUVMRF0sXG4gICAgICAgIGFubm90YXRpb25zOiBtYXJrcyAmJiBtYXJrcy5hbm5vdGF0aW9ucyA/IG1hcmtzLmFubm90YXRpb25zIDogREVGQVVMVF9BTk5PVEFUSU9OUyxcbiAgICAgICAgZGVjb3JhdG9yczogbWFya3MgJiYgbWFya3MuZGVjb3JhdG9ycyA/IG1hcmtzLmRlY29yYXRvcnMgOiBERUZBVUxUX0RFQ09SQVRPUlNcbiAgICAgIH0sXG4gICAgICAuLi5vZi5maWx0ZXIoKG1lbWJlclR5cGUpID0+IG1lbWJlclR5cGUudHlwZSAhPT0gXCJzcGFuXCIpXG4gICAgXVxuICB9O1xufVxuY29uc3QgSU5IRVJJVEVEX0ZJRUxEUyA9IFtcbiAgXCJ0eXBlXCIsXG4gIFwibmFtZVwiLFxuICBcInRpdGxlXCIsXG4gIFwianNvblR5cGVcIixcbiAgXCJkZXNjcmlwdGlvblwiLFxuICBcIm9wdGlvbnNcIixcbiAgXCJmaWVsZHNldHNcIixcbiAgXCJpY29uXCJcbl0sIFNQQU5fQ09SRSA9IHtcbiAgbmFtZTogXCJzcGFuXCIsXG4gIHRpdGxlOiBcIlNwYW5cIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwib2JqZWN0XCJcbn0sIE1BUktTX0ZJRUxEID0ge1xuICBuYW1lOiBcIm1hcmtzXCIsXG4gIHRpdGxlOiBcIk1hcmtzXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgb2Y6IFt7IHR5cGU6IFwic3RyaW5nXCIgfV1cbn0sIFRFWFRfRklFTEQgPSB7XG4gIG5hbWU6IFwidGV4dFwiLFxuICB0aXRsZTogXCJUZXh0XCIsXG4gIHR5cGU6IFwic3RyaW5nXCJcbn0sIERFRkFVTFRfT1BUSU9OUyQyID0ge30sIFNwYW5UeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFNQQU5fQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHN1YlR5cGVEZWYsIGV4dGVuZE1lbWJlcikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLnN1YlR5cGVEZWYub3B0aW9ucyB8fCBERUZBVUxUX09QVElPTlMkMiB9LCB7IGFubm90YXRpb25zID0gW10sIG1hcmtzID0gW10gfSA9IHN1YlR5cGVEZWYsIGZpZWxkcyA9IFtNQVJLU19GSUVMRCwgVEVYVF9GSUVMRF0sIG93blByb3BzID0geyAuLi5zdWJUeXBlRGVmLCBvcHRpb25zIH0sIHBhcnNlZCA9IE9iamVjdC5hc3NpZ24ocGljayhTUEFOX0NPUkUsIElOSEVSSVRFRF9GSUVMRFMpLCBvd25Qcm9wcywge1xuICAgICAgdHlwZTogU1BBTl9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGxhenlHZXR0ZXIocGFyc2VkLCBcImZpZWxkc1wiLCAoKSA9PiBmaWVsZHMubWFwKChmaWVsZERlZikgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lLCAuLi50eXBlIH0gPSBmaWVsZERlZjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGU6IGV4dGVuZE1lbWJlcih0eXBlKVxuICAgICAgfTtcbiAgICB9KSksIGxhenlHZXR0ZXIocGFyc2VkLCBcImFubm90YXRpb25zXCIsICgpID0+IGFubm90YXRpb25zLm1hcChleHRlbmRNZW1iZXIpKSwgbGF6eUdldHRlcihwYXJzZWQsIFwibWFya3NcIiwgKCkgPT4gbWFya3MubWFwKGV4dGVuZE1lbWJlcikpLCBsYXp5R2V0dGVyKHBhcnNlZCwgXCJwcmV2aWV3XCIsIGNyZWF0ZVByZXZpZXdHZXR0ZXIoc3ViVHlwZURlZikpLCBsYXp5R2V0dGVyKFxuICAgICAgcGFyc2VkLFxuICAgICAgT1dOX1BST1BTX05BTUUsXG4gICAgICAoKSA9PiAoe1xuICAgICAgICAuLi5vd25Qcm9wcyxcbiAgICAgICAgZmllbGRzOiBwYXJzZWQuZmllbGRzLFxuICAgICAgICBhbm5vdGF0aW9uczogcGFyc2VkLmFubm90YXRpb25zLFxuICAgICAgICBtYXJrczogcGFyc2VkLm1hcmtzLFxuICAgICAgICBwcmV2aWV3OiBwYXJzZWQucHJldmlld1xuICAgICAgfSksXG4gICAgICB7IGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITEgfVxuICAgICksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGlmIChleHRlbnNpb25EZWYuZmllbGRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcnJpZGUgYGZpZWxkc2Agb2Ygc3VidHlwZXMgb2YgXCJzcGFuXCInKTtcbiAgICAgICAgICBjb25zdCBzdWJPd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBJTkhFUklURURfRklFTERTKSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgc3ViT3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIHN1Yk93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG52YXIgcHJpbWl0aXZlUHJldmlldyA9IHtcbiAgcHJlcGFyZTogKHZhbCkgPT4gKHsgdGl0bGU6IFN0cmluZyh2YWwpIH0pXG59O1xuY29uc3QgT1ZFUlJJREFCTEVfRklFTERTJGQgPSBbLi4uREVGQVVMVF9PVkVSUklERUFCTEVfRklFTERTXSwgQk9PTEVBTl9DT1JFID0ge1xuICBuYW1lOiBcImJvb2xlYW5cIixcbiAgdGl0bGU6IFwiQm9vbGVhblwiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJib29sZWFuXCJcbn0sIEJvb2xlYW5UeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIEJPT0xFQU5fQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHN1YlR5cGVEZWYpIHtcbiAgICBjb25zdCBvd25Qcm9wcyA9IHtcbiAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICBwcmV2aWV3OiBwcmltaXRpdmVQcmV2aWV3XG4gICAgfSwgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKEJPT0xFQU5fQ09SRSwgT1ZFUlJJREFCTEVfRklFTERTJGQpLCBvd25Qcm9wcywge1xuICAgICAgdHlwZTogQk9PTEVBTl9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZGRlbkdldHRlcihwYXJzZWQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Yk93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyRkKSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgc3ViT3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIHN1Yk93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIFJFRl9GSUVMRCQyID0ge1xuICBuYW1lOiBcIl9yZWZcIixcbiAgdGl0bGU6IFwiUmVmZXJlbmNlZCBkb2N1bWVudCBJRFwiLFxuICB0eXBlOiBcInN0cmluZ1wiXG59LCBXRUFLX0ZJRUxEJDIgPSB7XG4gIG5hbWU6IFwiX3dlYWtcIixcbiAgdGl0bGU6IFwiV2VhayByZWZlcmVuY2UgbWFya2VyXCIsXG4gIHR5cGU6IFwiYm9vbGVhblwiXG59LCBEQVRBU0VUX0ZJRUxEID0ge1xuICBuYW1lOiBcIl9kYXRhc2V0XCIsXG4gIHRpdGxlOiBcIlRhcmdldCBkYXRhc2V0XCIsXG4gIHR5cGU6IFwic3RyaW5nXCJcbn0sIFBST0pFQ1RfSURfRklFTEQgPSB7XG4gIG5hbWU6IFwiX3Byb2plY3RJZFwiLFxuICB0aXRsZTogXCJUYXJnZXQgcHJvamVjdCBJRFwiLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBoaWRkZW46ICEwXG59LCBSRUZFUkVOQ0VfRklFTERTJDIgPSBbUkVGX0ZJRUxEJDIsIFdFQUtfRklFTEQkMiwgREFUQVNFVF9GSUVMRCwgUFJPSkVDVF9JRF9GSUVMRF0sIE9WRVJSSURBQkxFX0ZJRUxEUyRjID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIENST1NTX0RBVEFTRVRfUkVGRVJFTkNFX0NPUkUgPSB7XG4gIG5hbWU6IFwiY3Jvc3NEYXRhc2V0UmVmZXJlbmNlXCIsXG4gIHR5cGU6IG51bGwsXG4gIGpzb25UeXBlOiBcIm9iamVjdFwiXG59O1xuZnVuY3Rpb24gaHVtYW5pemUkMihhcnIsIGNvbmp1bmN0aW9uKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDEpXG4gICAgcmV0dXJuIGFyclswXTtcbiAgY29uc3QgZmlyc3QgPSBhcnIuc2xpY2UoMCwgbGVuIC0gMSksIGxhc3QgPSBhcnJbbGVuIC0gMV07XG4gIHJldHVybiBgJHtmaXJzdC5qb2luKFwiLCBcIil9ICR7Y29uanVuY3Rpb259ICR7bGFzdH1gO1xufVxuZnVuY3Rpb24gYnVpbGRUaXRsZSQyKHR5cGUpIHtcbiAgcmV0dXJuICF0eXBlLnRvIHx8IHR5cGUudG8ubGVuZ3RoID09PSAwID8gXCJDcm9zcyBkYXRhc2V0IFJlZmVyZW5jZVwiIDogYENyb3NzIGRhdGFzZXQgcmVmZXJlbmNlIHRvICR7aHVtYW5pemUkMihcbiAgICBhcnJpZnkodHlwZS50bykubWFwKCh0b1R5cGUpID0+IHRvVHlwZS50aXRsZSB8fCBjYXBpdGFsaXplKHRvVHlwZS50eXBlKSksXG4gICAgXCJvclwiXG4gICkudG9Mb3dlckNhc2UoKX1gO1xufVxuY29uc3QgQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVHlwZSA9IHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBDUk9TU19EQVRBU0VUX1JFRkVSRU5DRV9DT1JFO1xuICB9LFxuICBleHRlbmQoc3ViVHlwZURlZiwgY3JlYXRlTWVtYmVyVHlwZSkge1xuICAgIGlmICghc3ViVHlwZURlZi50bylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE1pc3NpbmcgXCJ0b1wiIGZpZWxkIGluIGNyb3NzIGRhdGFzZXQgcmVmZXJlbmNlIGRlZmluaXRpb24uIENoZWNrIHRoZSB0eXBlICR7c3ViVHlwZURlZi5uYW1lfWBcbiAgICAgICk7XG4gICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHBpY2soQ1JPU1NfREFUQVNFVF9SRUZFUkVOQ0VfQ09SRSwgT1ZFUlJJREFCTEVfRklFTERTJGMpLFxuICAgICAgc3ViVHlwZURlZixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogQ1JPU1NfREFUQVNFVF9SRUZFUkVOQ0VfQ09SRVxuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGxhenlHZXR0ZXIocGFyc2VkLCBcImZpZWxkc1wiLCAoKSA9PiBSRUZFUkVOQ0VfRklFTERTJDIubWFwKChmaWVsZERlZikgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lLCAuLi50eXBlIH0gPSBmaWVsZERlZjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHR5cGU6IGNyZWF0ZU1lbWJlclR5cGUodHlwZSlcbiAgICAgIH07XG4gICAgfSkpLCBsYXp5R2V0dGVyKHBhcnNlZCwgXCJ0b1wiLCAoKSA9PiBhcnJpZnkoc3ViVHlwZURlZi50bykubWFwKCh0b1R5cGUpID0+ICh7XG4gICAgICAuLi50b1R5cGUsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgICBfX2V4cGVyaW1lbnRhbF9zZWFyY2g6IHJlc29sdmVTZWFyY2hDb25maWdGb3JCYXNlRmllbGRQYXRocyh0b1R5cGUpXG4gICAgfSkpKSwgbGF6eUdldHRlcihwYXJzZWQsIFwidGl0bGVcIiwgKCkgPT4gc3ViVHlwZURlZi50aXRsZSB8fCBidWlsZFRpdGxlJDIocGFyc2VkKSksIGxhenlHZXR0ZXIoXG4gICAgICBwYXJzZWQsXG4gICAgICBPV05fUFJPUFNfTkFNRSxcbiAgICAgICgpID0+ICh7XG4gICAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICAgIGZpZWxkczogcGFyc2VkLmZpZWxkcyxcbiAgICAgICAgdG86IHBhcnNlZC50byxcbiAgICAgICAgdGl0bGU6IHBhcnNlZC50aXRsZVxuICAgICAgfSksXG4gICAgICB7IGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITEgfVxuICAgICksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGlmIChleHRlbnNpb25EZWYub2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVycmlkZSBgb2ZgIG9mIHN1YnR5cGVzIG9mIFwicmVmZXJlbmNlXCInKTtcbiAgICAgICAgICBjb25zdCBvd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBPVkVSUklEQUJMRV9GSUVMRFMkYyksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIG93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59LCBPVkVSUklEQUJMRV9GSUVMRFMkYiA9IFsuLi5ERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFNdLCBEQVRFX0NPUkUgPSB7XG4gIG5hbWU6IFwiZGF0ZVwiLFxuICB0aXRsZTogXCJEYXRldGltZVwiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJzdHJpbmdcIlxufSwgRGF0ZVR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gREFURV9DT1JFO1xuICB9LFxuICBleHRlbmQoc3ViVHlwZURlZikge1xuICAgIGNvbnN0IG93blByb3BzID0ge1xuICAgICAgLi4uc3ViVHlwZURlZixcbiAgICAgIHByZXZpZXc6IHByaW1pdGl2ZVByZXZpZXdcbiAgICB9LCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKHBpY2soREFURV9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkYiksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBEQVRFX0NPUkVcbiAgICB9KTtcbiAgICByZXR1cm4gaGlkZGVuR2V0dGVyKHBhcnNlZCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShwYXJzZWQpO1xuICAgIGZ1bmN0aW9uIHN1YnR5cGUocGFyZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiAoZXh0ZW5zaW9uRGVmKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3ViT3duUHJvcHMgPSBwaWNrKGV4dGVuc2lvbkRlZiwgT1ZFUlJJREFCTEVfRklFTERTJGIpLCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LCBzdWJPd25Qcm9wcywge1xuICAgICAgICAgICAgdHlwZTogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhpZGRlbkdldHRlcihjdXJyZW50LCBPV05fUFJPUFNfTkFNRSwgc3ViT3duUHJvcHMpLCBzdWJ0eXBlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSwgT1ZFUlJJREFCTEVfRklFTERTJGEgPSBbLi4uREVGQVVMVF9PVkVSUklERUFCTEVfRklFTERTXSwgREFURVRJTUVfQ09SRSA9IHtcbiAgbmFtZTogXCJkYXRldGltZVwiLFxuICB0aXRsZTogXCJEYXRldGltZVwiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJzdHJpbmdcIlxufSwgRGF0ZVRpbWVUeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIERBVEVUSU1FX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmKSB7XG4gICAgY29uc3Qgb3duUHJvcHMgPSB7XG4gICAgICAuLi5zdWJUeXBlRGVmLFxuICAgICAgcHJldmlldzogcHJpbWl0aXZlUHJldmlld1xuICAgIH0sIHBhcnNlZCA9IE9iamVjdC5hc3NpZ24ocGljayhEQVRFVElNRV9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkYSksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBEQVRFVElNRV9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZGRlbkdldHRlcihwYXJzZWQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Yk93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyRhKSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgc3ViT3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIHN1Yk93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIENBTkRJREFURVMgPSBbXCJ0aXRsZVwiLCBcIm5hbWVcIiwgXCJsYWJlbFwiLCBcImhlYWRpbmdcIiwgXCJoZWFkZXJcIiwgXCJjYXB0aW9uXCIsIFwiZGVzY3JpcHRpb25cIl0sIFBSSU1JVElWRVMgPSBbXCJzdHJpbmdcIiwgXCJib29sZWFuXCIsIFwibnVtYmVyXCJdLCBpc1ByaW1pdGl2ZSA9IChmaWVsZCkgPT4gUFJJTUlUSVZFUy5pbmNsdWRlcyhmaWVsZC50eXBlKTtcbmZ1bmN0aW9uIGd1ZXNzT3JkZXJpbmdDb25maWcob2JqZWN0VHlwZURlZikge1xuICBsZXQgY2FuZGlkYXRlcyA9IENBTkRJREFURVMuZmlsdGVyKFxuICAgIChjYW5kaWRhdGUpID0+IG9iamVjdFR5cGVEZWYuZmllbGRzLnNvbWUoKGZpZWxkKSA9PiBpc1ByaW1pdGl2ZShmaWVsZCkgJiYgZmllbGQubmFtZSA9PT0gY2FuZGlkYXRlKVxuICApO1xuICByZXR1cm4gY2FuZGlkYXRlcy5sZW5ndGggPT09IDAgJiYgKGNhbmRpZGF0ZXMgPSBvYmplY3RUeXBlRGVmLmZpZWxkcy5maWx0ZXIoaXNQcmltaXRpdmUpLm1hcCgoZmllbGQpID0+IGZpZWxkLm5hbWUpKSwgY2FuZGlkYXRlcy5tYXAoXG4gICAgKG5hbWUpID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgaTE4bjoge1xuICAgICAgICB0aXRsZTogeyBrZXk6IGBkZWZhdWx0LW9yZGVyaW5ncy4ke25hbWV9YCwgbnM6IFwic3R1ZGlvXCIgfVxuICAgICAgfSxcbiAgICAgIHRpdGxlOiBjYXBpdGFsaXplKHN0YXJ0Q2FzZShuYW1lKSksXG4gICAgICBieTogW3sgZmllbGQ6IG5hbWUsIGRpcmVjdGlvbjogXCJhc2NcIiB9XVxuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWFyY2hDb25maWdzKGNvbmZpZ3MpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZ3MpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGhlIHNlYXJjaCBjb25maWcgb2YgYSBkb2N1bWVudCB0eXBlIG11c3QgYmUgYW4gYXJyYXkgb2Ygc2VhcmNoIGNvbmZpZyBvYmplY3RzXCJcbiAgICApO1xuICByZXR1cm4gY29uZmlncy5tYXAoKGNvbmYpID0+IHtcbiAgICBpZiAoY29uZiA9PT0gXCJkZWZhdWx0c1wiKVxuICAgICAgcmV0dXJuIGNvbmY7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGNvbmYpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VhcmNoIGNvbmZpZyBtdXN0IGJlIGFuIG9iamVjdCBvZiB7cGF0aDogc3RyaW5nLCB3ZWlnaHQ6IG51bWJlcn1cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdlaWdodDogXCJ3ZWlnaHRcIiBpbiBjb25mID8gY29uZi53ZWlnaHQgOiAxLFxuICAgICAgcGF0aDogdG9QYXRoKGNvbmYucGF0aCksXG4gICAgICBtYXBXaXRoOiB0eXBlb2YgY29uZi5tYXBXaXRoID09IFwic3RyaW5nXCIgPyBjb25mLm1hcFdpdGggOiB2b2lkIDBcbiAgICB9O1xuICB9KTtcbn1cbmNvbnN0IE9WRVJSSURBQkxFX0ZJRUxEUyQ5ID0gW1xuICAuLi5ERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFMsXG4gIFwib3JkZXJpbmdzXCIsXG4gIFwiX19leHBlcmltZW50YWxfc2VhcmNoXCIsXG4gIFwiYmxvY2tFZGl0b3JcIixcbiAgXCJpY29uXCJcbl0sIE9iamVjdFR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogXCJvYmplY3RcIixcbiAgICAgIHRpdGxlOiBcIk9iamVjdFwiLFxuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIGpzb25UeXBlOiBcIm9iamVjdFwiXG4gICAgfTtcbiAgfSxcbiAgZXh0ZW5kKHJhd1N1YlR5cGVEZWYsIGNyZWF0ZU1lbWJlclR5cGUpIHtcbiAgICBjb25zdCBzdWJUeXBlRGVmID0geyBmaWVsZHM6IFtdLCAuLi5yYXdTdWJUeXBlRGVmIH0sIG9wdGlvbnMgPSB7IC4uLnN1YlR5cGVEZWYub3B0aW9ucyB9LCBvd25Qcm9wcyA9IHtcbiAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICB0aXRsZTogc3ViVHlwZURlZi50aXRsZSB8fCAoc3ViVHlwZURlZi5uYW1lID8gc3RhcnRDYXNlKHN1YlR5cGVEZWYubmFtZSkgOiBcIk9iamVjdFwiKSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcmRlcmluZ3M6IHN1YlR5cGVEZWYub3JkZXJpbmdzIHx8IGd1ZXNzT3JkZXJpbmdDb25maWcoc3ViVHlwZURlZiksXG4gICAgICBmaWVsZHM6IHN1YlR5cGVEZWYuZmllbGRzLm1hcCgoZmllbGREZWYpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBmaWVsZHNldCwgZ3JvdXAsIC4uLnJlc3QgfSA9IGZpZWxkRGVmO1xuICAgICAgICByZXR1cm4gbGF6eUdldHRlcih7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBncm91cCxcbiAgICAgICAgICBmaWVsZHNldFxuICAgICAgICB9LCBcInR5cGVcIiwgKCkgPT4gY3JlYXRlTWVtYmVyVHlwZSh7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICB0aXRsZTogZmllbGREZWYudGl0bGUgfHwgc3RhcnRDYXNlKG5hbWUpXG4gICAgICAgIH0pKTtcbiAgICAgIH0pXG4gICAgfSwgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKHRoaXMuZ2V0KCksIE9WRVJSSURBQkxFX0ZJRUxEUyQ5KSwgb3duUHJvcHMsIHtcbiAgICAgIHR5cGU6IHRoaXMuZ2V0KClcbiAgICB9KTtcbiAgICByZXR1cm4gbGF6eUdldHRlcihwYXJzZWQsIFwiZmllbGRzZXRzXCIsICgpID0+IGNyZWF0ZUZpZWxkc2V0cyhzdWJUeXBlRGVmLCBwYXJzZWQuZmllbGRzKSksIGxhenlHZXR0ZXIocGFyc2VkLCBcImdyb3Vwc1wiLCAoKSA9PiBjcmVhdGVGaWVsZHNHcm91cHMoc3ViVHlwZURlZiwgcGFyc2VkLmZpZWxkcykpLCBsYXp5R2V0dGVyKHBhcnNlZCwgXCJwcmV2aWV3XCIsIGNyZWF0ZVByZXZpZXdHZXR0ZXIoc3ViVHlwZURlZikpLCBsYXp5R2V0dGVyKFxuICAgICAgcGFyc2VkLFxuICAgICAgT1dOX1BST1BTX05BTUUsXG4gICAgICAoKSA9PiAoe1xuICAgICAgICAuLi5vd25Qcm9wcyxcbiAgICAgICAgcHJldmlldzogcGFyc2VkLnByZXZpZXdcbiAgICAgIH0pLFxuICAgICAgeyBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICExIH1cbiAgICApLCBsYXp5R2V0dGVyKFxuICAgICAgcGFyc2VkLFxuICAgICAgXCJfX2V4cGVyaW1lbnRhbF9zZWFyY2hcIixcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgdXNlclByb3ZpZGVkU2VhcmNoQ29uZmlnID0gc3ViVHlwZURlZi5fX2V4cGVyaW1lbnRhbF9zZWFyY2ggPyBub3JtYWxpemVTZWFyY2hDb25maWdzKHN1YlR5cGVEZWYuX19leHBlcmltZW50YWxfc2VhcmNoKSA6IG51bGw7XG4gICAgICAgIHJldHVybiB1c2VyUHJvdmlkZWRTZWFyY2hDb25maWcgPyB1c2VyUHJvdmlkZWRTZWFyY2hDb25maWcubWFwKFxuICAgICAgICAgIChlbnRyeSkgPT4gZW50cnkgPT09IFwiZGVmYXVsdHNcIiA/IG5vcm1hbGl6ZVNlYXJjaENvbmZpZ3Moc3ViVHlwZURlZikgOiBlbnRyeVxuICAgICAgICApIDogcmVzb2x2ZVNlYXJjaENvbmZpZyhwYXJzZWQpO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZW51bWVyYWJsZTogITFcbiAgICAgIH1cbiAgICApLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLmZpZWxkcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJyaWRlIGBmaWVsZHNgIG9mIHN1YnR5cGVzIG9mIFwib2JqZWN0XCInKTtcbiAgICAgICAgICBjb25zdCBzdWJPd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBPVkVSUklEQUJMRV9GSUVMRFMkOSk7XG4gICAgICAgICAgc3ViT3duUHJvcHMudGl0bGUgPSBleHRlbnNpb25EZWYudGl0bGUgfHwgc3ViVHlwZURlZi50aXRsZSB8fCAoc3ViVHlwZURlZi5uYW1lID8gc3RhcnRDYXNlKHN1YlR5cGVEZWYubmFtZSkgOiBcIk9iamVjdFwiKTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LCBwaWNrKGV4dGVuc2lvbkRlZiwgT1ZFUlJJREFCTEVfRklFTERTJDkpLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbGF6eUdldHRlcihjdXJyZW50LCBcIl9fZXhwZXJpbWVudGFsX3NlYXJjaFwiLCAoKSA9PiBwYXJlbnQuX19leHBlcmltZW50YWxfc2VhcmNoKSwgaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBzdWJPd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlRmllbGRzZXRzKHR5cGVEZWYsIGZpZWxkcykge1xuICBjb25zdCBmaWVsZHNldHNCeU5hbWUgPSB7fTtcbiAgZm9yIChjb25zdCBmaWVsZHNldCBvZiB0eXBlRGVmLmZpZWxkc2V0cyB8fCBbXSkge1xuICAgIGlmIChmaWVsZHNldHNCeU5hbWVbZmllbGRzZXQubmFtZV0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBEdXBsaWNhdGUgZmllbGRzZXQgbmFtZSBcIiR7ZmllbGRzZXQubmFtZX1cIiBmb3VuZCBmb3IgdHlwZSAnJHt0eXBlRGVmLnRpdGxlID8gdHlwZURlZi50aXRsZSA6IHN0YXJ0Q2FzZSh0eXBlRGVmLm5hbWUpfSdgXG4gICAgICApO1xuICAgIGZpZWxkc2V0c0J5TmFtZVtmaWVsZHNldC5uYW1lXSA9IHsgdGl0bGU6IHN0YXJ0Q2FzZShmaWVsZHNldC5uYW1lKSwgLi4uZmllbGRzZXQsIGZpZWxkczogW10gfTtcbiAgfVxuICBjb25zdCBmaWVsZHNldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgIGlmICghZmllbGQuZmllbGRzZXQpIHtcbiAgICAgIGZpZWxkc2V0cy5hZGQoeyBzaW5nbGU6ICEwLCBmaWVsZCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZHNldCA9IGZpZWxkc2V0c0J5TmFtZVtmaWVsZC5maWVsZHNldF07XG4gICAgaWYgKCFmaWVsZHNldClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZpZWxkc2V0ICcke2ZpZWxkLmZpZWxkc2V0fScgaXMgbm90IGRlZmluZWQgaW4gc2NoZW1hIGZvciB0eXBlICcke3R5cGVEZWYubmFtZX0nYFxuICAgICAgKTtcbiAgICBmaWVsZHNldC5maWVsZHMucHVzaChmaWVsZCksIGZpZWxkc2V0cy5hZGQoZmllbGRzZXQpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGZpZWxkc2V0cyk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWVsZHNHcm91cHModHlwZURlZiwgZmllbGRzKSB7XG4gIGNvbnN0IGdyb3Vwc0J5TmFtZSA9IHt9O1xuICBsZXQgbnVtRGVmYXVsdEdyb3VwcyA9IDA7XG4gIGZvciAoY29uc3QgZ3JvdXAgb2YgdHlwZURlZi5ncm91cHMgfHwgW10pIHtcbiAgICBpZiAoZ3JvdXBzQnlOYW1lW2dyb3VwLm5hbWVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRHVwbGljYXRlIGdyb3VwIG5hbWUgXCIke2dyb3VwLm5hbWV9XCIgZm91bmQgZm9yIHR5cGUgJyR7dHlwZURlZi50aXRsZSA/IHR5cGVEZWYudGl0bGUgOiBzdGFydENhc2UodHlwZURlZi5uYW1lKX0nYFxuICAgICAgKTtcbiAgICBpZiAoZ3JvdXBzQnlOYW1lW2dyb3VwLm5hbWVdID0geyB0aXRsZTogc3RhcnRDYXNlKGdyb3VwLm5hbWUpLCAuLi5ncm91cCwgZmllbGRzOiBbXSB9LCBncm91cC5kZWZhdWx0ICYmICsrbnVtRGVmYXVsdEdyb3VwcyA+IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNb3JlIHRoYW4gb25lIGZpZWxkIGdyb3VwIGRlZmluZWQgYXMgZGVmYXVsdCBmb3IgdHlwZSAnJHt0eXBlRGVmLnRpdGxlID8gdHlwZURlZi50aXRsZSA6IHN0YXJ0Q2FzZSh0eXBlRGVmLm5hbWUpfScgLSBvbmx5IDEgaXMgc3VwcG9ydGVkYFxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgY29uc3QgZmllbGRHcm91cE5hbWVzID0gY2FzdEFycmF5KGZpZWxkLmdyb3VwIHx8IFtdKTtcbiAgICBmaWVsZEdyb3VwTmFtZXMubGVuZ3RoICE9PSAwICYmIGZpZWxkR3JvdXBOYW1lcy5mb3JFYWNoKChmaWVsZEdyb3VwTmFtZSkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudEdyb3VwID0gZ3JvdXBzQnlOYW1lW2ZpZWxkR3JvdXBOYW1lXTtcbiAgICAgIGlmICghY3VycmVudEdyb3VwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZpZWxkIGdyb3VwICcke2ZpZWxkR3JvdXBOYW1lfScgaXMgbm90IGRlZmluZWQgaW4gc2NoZW1hIGZvciB0eXBlICcke3R5cGVEZWYudGl0bGUgPyB0eXBlRGVmLm5hbWUgOiBzdGFydENhc2UodHlwZURlZi5uYW1lKX0nYFxuICAgICAgICApO1xuICAgICAgY3VycmVudEdyb3VwLmZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICB9KTtcbiAgfSksIGZsYXRNYXAoZ3JvdXBzQnlOYW1lKS5maWx0ZXIoKGdyb3VwKSA9PiBncm91cC5maWVsZHMubGVuZ3RoID4gMCk7XG59XG5jb25zdCBET0NVTUVOVF9DT1JFID0ge1xuICBuYW1lOiBcImRvY3VtZW50XCIsXG4gIHRpdGxlOiBcIkRvY3VtZW50XCIsXG4gIHR5cGU6IG51bGwsXG4gIGpzb25UeXBlOiBcIm9iamVjdFwiXG59LCBEb2N1bWVudFR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gRE9DVU1FTlRfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kOiBPYmplY3RUeXBlLmV4dGVuZFxufSwgT1ZFUlJJREFCTEVfRklFTERTJDggPSBbLi4uREVGQVVMVF9PVkVSUklERUFCTEVfRklFTERTXSwgRU1BSUxfQ09SRSA9IHtcbiAgbmFtZTogXCJlbWFpbFwiLFxuICB0aXRsZTogXCJFbWFpbFwiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJzdHJpbmdcIlxufTtcbmxhenlHZXR0ZXIoXG4gIEVNQUlMX0NPUkUsXG4gIE9XTl9QUk9QU19OQU1FLFxuICAoKSA9PiAoe1xuICAgIC4uLkVNQUlMX0NPUkUsXG4gICAgdmFsaWRhdGlvbjogKFJ1bGUpID0+IFJ1bGUuZW1haWwoKVxuICB9KSxcbiAgeyBlbnVtZXJhYmxlOiAhMSB9XG4pO1xuY29uc3QgRW1haWxUeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIEVNQUlMX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmKSB7XG4gICAgY29uc3Qgb3duUHJvcHMgPSB7XG4gICAgICAuLi5zdWJUeXBlRGVmLFxuICAgICAgcHJldmlldzogcHJpbWl0aXZlUHJldmlld1xuICAgIH0sIHBhcnNlZCA9IE9iamVjdC5hc3NpZ24ocGljayhFTUFJTF9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkOCksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBFTUFJTF9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZGRlbkdldHRlcihwYXJzZWQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Yk93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyQ4KSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgc3ViT3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIHN1Yk93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIEFTU0VUX0ZJRUxEJDEgPSB7XG4gIG5hbWU6IFwiYXNzZXRcIixcbiAgdHlwZTogXCJyZWZlcmVuY2VcIixcbiAgdG86IHsgdHlwZTogXCJzYW5pdHkuZmlsZUFzc2V0XCIgfVxufSwgTUVESUFfTElCUkFSWV9BU1NFVF9GSUVMRCQxID0ge1xuICBuYW1lOiBcIm1lZGlhXCIsXG4gIHR5cGU6IFwiZ2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VcIixcbiAgaGlkZGVuOiAhMCxcbiAgdG86IFt7IHR5cGU6IFwic2FuaXR5LmFzc2V0XCIgfV1cbn0sIE9WRVJSSURBQkxFX0ZJRUxEUyQ3ID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIEZJTEVfQ09SRSA9IHtcbiAgbmFtZTogXCJmaWxlXCIsXG4gIHRpdGxlOiBcIkZpbGVcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwib2JqZWN0XCJcbn0sIERFRkFVTFRfT1BUSU9OUyQxID0ge1xuICBhY2NlcHQ6IFwiXCJcbn0sIEZpbGVUeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIEZJTEVfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHJhd1N1YlR5cGVEZWYsIGNyZWF0ZU1lbWJlclR5cGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi5yYXdTdWJUeXBlRGVmLm9wdGlvbnMgfHwgREVGQVVMVF9PUFRJT05TJDEgfSwgZmllbGRzID0gW0FTU0VUX0ZJRUxEJDEsIE1FRElBX0xJQlJBUllfQVNTRVRfRklFTEQkMSwgLi4ucmF3U3ViVHlwZURlZi5maWVsZHMgfHwgW11dLCBzdWJUeXBlRGVmID0geyAuLi5yYXdTdWJUeXBlRGVmLCBmaWVsZHMgfSwgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKEZJTEVfQ09SRSwgT1ZFUlJJREFCTEVfRklFTERTJDcpLCBzdWJUeXBlRGVmLCB7XG4gICAgICB0eXBlOiBGSUxFX0NPUkUsXG4gICAgICB0aXRsZTogc3ViVHlwZURlZi50aXRsZSB8fCAoc3ViVHlwZURlZi5uYW1lID8gc3RhcnRDYXNlKHN1YlR5cGVEZWYubmFtZSkgOiBGSUxFX0NPUkUudGl0bGUpLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGZpZWxkczogc3ViVHlwZURlZi5maWVsZHMubWFwKChmaWVsZERlZikgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGZpZWxkc2V0LCAuLi5yZXN0IH0gPSBmaWVsZERlZiwgY29tcGlsZWRGaWVsZCA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGZpZWxkc2V0LFxuICAgICAgICAgIGlzQ3VzdG9taXplZDogISFyYXdTdWJUeXBlRGVmLmZpZWxkc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbGF6eUdldHRlcihjb21waWxlZEZpZWxkLCBcInR5cGVcIiwgKCkgPT4gY3JlYXRlTWVtYmVyVHlwZSh7XG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgICB0aXRsZTogZmllbGREZWYudGl0bGUgfHwgc3RhcnRDYXNlKG5hbWUpXG4gICAgICAgIH0pKTtcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIGxhenlHZXR0ZXIocGFyc2VkLCBcImZpZWxkc2V0c1wiLCAoKSA9PiBjcmVhdGVGaWVsZHNldHMoc3ViVHlwZURlZiwgcGFyc2VkLmZpZWxkcykpLCBsYXp5R2V0dGVyKHBhcnNlZCwgXCJwcmV2aWV3XCIsIGNyZWF0ZVByZXZpZXdHZXR0ZXIoT2JqZWN0LmFzc2lnbih7fSwgc3ViVHlwZURlZiwgeyBmaWVsZHMgfSkpKSwgbGF6eUdldHRlcihcbiAgICAgIHBhcnNlZCxcbiAgICAgIE9XTl9QUk9QU19OQU1FLFxuICAgICAgKCkgPT4gKHtcbiAgICAgICAgLi4uc3ViVHlwZURlZixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZmllbGRzOiBwYXJzZWQuZmllbGRzLFxuICAgICAgICB0aXRsZTogcGFyc2VkLnRpdGxlLFxuICAgICAgICBmaWVsZHNldHM6IHBhcnNlZC5maWVsZHNldHMsXG4gICAgICAgIHByZXZpZXc6IHBhcnNlZC5wcmV2aWV3XG4gICAgICB9KSxcbiAgICAgIHsgZW51bWVyYWJsZTogITEsIHdyaXRhYmxlOiAhMSB9XG4gICAgKSwgc3VidHlwZShwYXJzZWQpO1xuICAgIGZ1bmN0aW9uIHN1YnR5cGUocGFyZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiAoZXh0ZW5zaW9uRGVmKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkRlZi5maWVsZHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVycmlkZSBgZmllbGRzYCBvZiBzdWJ0eXBlcyBvZiBcImZpbGVcIicpO1xuICAgICAgICAgIGNvbnN0IG93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyQ3KSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgb3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIFJFRl9GSUVMRCQxID0ge1xuICBuYW1lOiBcIl9yZWZcIixcbiAgdGl0bGU6IFwiUmVmZXJlbmNlZCBkb2N1bWVudCBJRFwiLFxuICB0eXBlOiBcInN0cmluZ1wiXG59LCBXRUFLX0ZJRUxEJDEgPSB7XG4gIG5hbWU6IFwiX3dlYWtcIixcbiAgdGl0bGU6IFwiV2VhayByZWZlcmVuY2VcIixcbiAgdHlwZTogXCJib29sZWFuXCJcbn0sIFJFRkVSRU5DRV9GSUVMRFMkMSA9IFtSRUZfRklFTEQkMSwgV0VBS19GSUVMRCQxXSwgT1ZFUlJJREFCTEVfRklFTERTJDYgPSBbLi4uREVGQVVMVF9PVkVSUklERUFCTEVfRklFTERTXSwgR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9DT1JFID0ge1xuICBuYW1lOiBcImdsb2JhbERvY3VtZW50UmVmZXJlbmNlXCIsXG4gIHRpdGxlOiBcIkdsb2JhbCBEb2N1bWVudCBSZWZlcmVuY2VcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwib2JqZWN0XCJcbn07XG5mdW5jdGlvbiBodW1hbml6ZSQxKGFyciwgY29uanVuY3Rpb24pIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMSlcbiAgICByZXR1cm4gYXJyWzBdO1xuICBjb25zdCBmaXJzdCA9IGFyci5zbGljZSgwLCBsZW4gLSAxKSwgbGFzdCA9IGFycltsZW4gLSAxXTtcbiAgcmV0dXJuIGAke2ZpcnN0LmpvaW4oXCIsIFwiKX0gJHtjb25qdW5jdGlvbn0gJHtsYXN0fWA7XG59XG5mdW5jdGlvbiBidWlsZFRpdGxlJDEodHlwZSkge1xuICByZXR1cm4gIXR5cGUudG8gfHwgdHlwZS50by5sZW5ndGggPT09IDAgPyBcIkdsb2JhbCBEb2N1bWVudCBSZWZlcmVuY2VcIiA6IGBHbG9iYWwgRG9jdW1lbnQgUmVmZXJlbmNlIHRvICR7aHVtYW5pemUkMShcbiAgICBhcnJpZnkodHlwZS50bykubWFwKCh0b1R5cGUpID0+IHRvVHlwZS50aXRsZSksXG4gICAgXCJvclwiXG4gICkudG9Mb3dlckNhc2UoKX1gO1xufVxuY29uc3QgR2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VUeXBlID0ge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIEdMT0JBTF9ET0NVTUVOVF9SRUZFUkVOQ0VfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHN1YlR5cGVEZWYsIGNyZWF0ZU1lbWJlclR5cGUpIHtcbiAgICBpZiAoIXN1YlR5cGVEZWYudG8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNaXNzaW5nIFwidG9cIiBmaWVsZCBpbiBnbG9iYWwgZG9jdW1lbnQgcmVmZXJlbmNlIGRlZmluaXRpb24uIENoZWNrIHRoZSB0eXBlICR7c3ViVHlwZURlZi5uYW1lfWBcbiAgICAgICk7XG4gICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHBpY2soR0xPQkFMX0RPQ1VNRU5UX1JFRkVSRU5DRV9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkNiksXG4gICAgICBzdWJUeXBlRGVmLFxuICAgICAge1xuICAgICAgICB0eXBlOiBHTE9CQUxfRE9DVU1FTlRfUkVGRVJFTkNFX0NPUkVcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBsYXp5R2V0dGVyKHBhcnNlZCwgXCJmaWVsZHNcIiwgKCkgPT4gUkVGRVJFTkNFX0ZJRUxEUyQxLm1hcCgoZmllbGREZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgLi4udHlwZSB9ID0gZmllbGREZWY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlOiBjcmVhdGVNZW1iZXJUeXBlKHR5cGUpXG4gICAgICB9O1xuICAgIH0pKSwgbGF6eUdldHRlcihwYXJzZWQsIFwidG9cIiwgKCkgPT4gYXJyaWZ5KHN1YlR5cGVEZWYudG8pLm1hcCgodG9UeXBlKSA9PiAoe1xuICAgICAgLi4udG9UeXBlXG4gICAgfSkpKSwgbGF6eUdldHRlcihwYXJzZWQsIFwidGl0bGVcIiwgKCkgPT4gc3ViVHlwZURlZi50aXRsZSB8fCBidWlsZFRpdGxlJDEocGFyc2VkKSksIGxhenlHZXR0ZXIoXG4gICAgICBwYXJzZWQsXG4gICAgICBPV05fUFJPUFNfTkFNRSxcbiAgICAgICgpID0+ICh7XG4gICAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICAgIGZpZWxkczogcGFyc2VkLmZpZWxkcyxcbiAgICAgICAgdG86IHBhcnNlZC50byxcbiAgICAgICAgdGl0bGU6IHBhcnNlZC50aXRsZVxuICAgICAgfSksXG4gICAgICB7IGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITEgfVxuICAgICksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGlmIChleHRlbnNpb25EZWYub2YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVycmlkZSBgb2ZgIG9mIHN1YnR5cGVzIG9mIFwiZ2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VcIicpO1xuICAgICAgICAgIGNvbnN0IG93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyQ2KSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgb3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIEFTU0VUX0ZJRUxEID0ge1xuICBuYW1lOiBcImFzc2V0XCIsXG4gIHR5cGU6IFwicmVmZXJlbmNlXCIsXG4gIHRvOiBbeyB0eXBlOiBcInNhbml0eS5pbWFnZUFzc2V0XCIgfV1cbn0sIEhPVFNQT1RfRklFTEQgPSB7XG4gIG5hbWU6IFwiaG90c3BvdFwiLFxuICB0eXBlOiBcInNhbml0eS5pbWFnZUhvdHNwb3RcIlxufSwgQ1JPUF9GSUVMRCA9IHtcbiAgbmFtZTogXCJjcm9wXCIsXG4gIHR5cGU6IFwic2FuaXR5LmltYWdlQ3JvcFwiXG59LCBNRURJQV9MSUJSQVJZX0FTU0VUX0ZJRUxEID0ge1xuICBuYW1lOiBcIm1lZGlhXCIsXG4gIHR5cGU6IFwiZ2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VcIixcbiAgaGlkZGVuOiAhMCxcbiAgdG86IFt7IHR5cGU6IFwic2FuaXR5LmFzc2V0XCIgfV1cbn0sIE9WRVJSSURBQkxFX0ZJRUxEUyQ1ID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIElNQUdFX0NPUkUgPSB7XG4gIG5hbWU6IFwiaW1hZ2VcIixcbiAgdGl0bGU6IFwiSW1hZ2VcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwib2JqZWN0XCJcbn0sIERFRkFVTFRfT1BUSU9OUyA9IHt9LCBJbWFnZVR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gSU1BR0VfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHJhd1N1YlR5cGVEZWYsIGNyZWF0ZU1lbWJlclR5cGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyAuLi5yYXdTdWJUeXBlRGVmLm9wdGlvbnMgfHwgREVGQVVMVF9PUFRJT05TIH07XG4gICAgbGV0IGhvdHNwb3RGaWVsZHMgPSBbSE9UU1BPVF9GSUVMRCwgQ1JPUF9GSUVMRF07XG4gICAgb3B0aW9ucy5ob3RzcG90IHx8IChob3RzcG90RmllbGRzID0gaG90c3BvdEZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoeyAuLi5maWVsZCwgaGlkZGVuOiAhMCB9KSkpO1xuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgIEFTU0VUX0ZJRUxELFxuICAgICAgTUVESUFfTElCUkFSWV9BU1NFVF9GSUVMRCxcbiAgICAgIC4uLmhvdHNwb3RGaWVsZHMsXG4gICAgICAuLi5yYXdTdWJUeXBlRGVmLmZpZWxkcyB8fCBbXVxuICAgIF0sIHN1YlR5cGVEZWYgPSB7IC4uLnJhd1N1YlR5cGVEZWYsIGZpZWxkcyB9LCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKHBpY2sodGhpcy5nZXQoKSwgT1ZFUlJJREFCTEVfRklFTERTJDUpLCBzdWJUeXBlRGVmLCB7XG4gICAgICB0eXBlOiBJTUFHRV9DT1JFLFxuICAgICAgdGl0bGU6IHN1YlR5cGVEZWYudGl0bGUgfHwgKHN1YlR5cGVEZWYubmFtZSA/IHN0YXJ0Q2FzZShzdWJUeXBlRGVmLm5hbWUpIDogSU1BR0VfQ09SRS50aXRsZSksXG4gICAgICBvcHRpb25zLFxuICAgICAgZmllbGRzOiBzdWJUeXBlRGVmLmZpZWxkcy5tYXAoKGZpZWxkRGVmKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZmllbGRzZXQsIC4uLnJlc3QgfSA9IGZpZWxkRGVmLCBjb21waWxlZEZpZWxkID0ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZmllbGRzZXQsXG4gICAgICAgICAgaXNDdXN0b21pemVkOiAhIXJhd1N1YlR5cGVEZWYuZmllbGRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBsYXp5R2V0dGVyKGNvbXBpbGVkRmllbGQsIFwidHlwZVwiLCAoKSA9PiBjcmVhdGVNZW1iZXJUeXBlKHtcbiAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgIHRpdGxlOiBmaWVsZERlZi50aXRsZSB8fCBzdGFydENhc2UobmFtZSlcbiAgICAgICAgfSkpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgICByZXR1cm4gbGF6eUdldHRlcihwYXJzZWQsIFwiZmllbGRzZXRzXCIsICgpID0+IGNyZWF0ZUZpZWxkc2V0cyhzdWJUeXBlRGVmLCBwYXJzZWQuZmllbGRzKSksIGxhenlHZXR0ZXIocGFyc2VkLCBcInByZXZpZXdcIiwgY3JlYXRlUHJldmlld0dldHRlcihPYmplY3QuYXNzaWduKHt9LCBzdWJUeXBlRGVmLCB7IGZpZWxkcyB9KSkpLCBsYXp5R2V0dGVyKFxuICAgICAgcGFyc2VkLFxuICAgICAgT1dOX1BST1BTX05BTUUsXG4gICAgICAoKSA9PiAoe1xuICAgICAgICAuLi5zdWJUeXBlRGVmLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBmaWVsZHM6IHBhcnNlZC5maWVsZHMsXG4gICAgICAgIHRpdGxlOiBwYXJzZWQudGl0bGUsXG4gICAgICAgIGZpZWxkc2V0czogcGFyc2VkLmZpZWxkc2V0cyxcbiAgICAgICAgcHJldmlldzogcGFyc2VkLnByZXZpZXdcbiAgICAgIH0pLFxuICAgICAgeyBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICExIH1cbiAgICApLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLmZpZWxkcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG92ZXJyaWRlIGBmaWVsZHNgIG9mIHN1YnR5cGVzIG9mIFwiaW1hZ2VcIicpO1xuICAgICAgICAgIGNvbnN0IG93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyQ1KSwgY3VycmVudCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCwgb3duUHJvcHMsIHtcbiAgICAgICAgICAgIHR5cGU6IHBhcmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBoaWRkZW5HZXR0ZXIoY3VycmVudCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn0sIE9WRVJSSURBQkxFX0ZJRUxEUyQ0ID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIE5VTUJFUl9DT1JFID0ge1xuICBuYW1lOiBcIm51bWJlclwiLFxuICB0aXRsZTogXCJOdW1iZXJcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwibnVtYmVyXCJcbn0sIE51bWJlclR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gTlVNQkVSX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmKSB7XG4gICAgY29uc3Qgb3duUHJvcHMgPSB7XG4gICAgICAuLi5zdWJUeXBlRGVmLFxuICAgICAgcHJldmlldzogcHJpbWl0aXZlUHJldmlld1xuICAgIH0sIHBhcnNlZCA9IE9iamVjdC5hc3NpZ24ocGljayhOVU1CRVJfQ09SRSwgT1ZFUlJJREFCTEVfRklFTERTJDQpLCBvd25Qcm9wcywge1xuICAgICAgdHlwZTogTlVNQkVSX0NPUkVcbiAgICB9KTtcbiAgICByZXR1cm4gaGlkZGVuR2V0dGVyKHBhcnNlZCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShwYXJzZWQpO1xuICAgIGZ1bmN0aW9uIHN1YnR5cGUocGFyZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiAoZXh0ZW5zaW9uRGVmKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3ViT3duUHJvcHMgPSBwaWNrKGV4dGVuc2lvbkRlZiwgT1ZFUlJJREFCTEVfRklFTERTJDQpLCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LCBzdWJPd25Qcm9wcywge1xuICAgICAgICAgICAgdHlwZTogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhpZGRlbkdldHRlcihjdXJyZW50LCBPV05fUFJPUFNfTkFNRSwgc3ViT3duUHJvcHMpLCBzdWJ0eXBlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSwgUkVGX0ZJRUxEID0ge1xuICBuYW1lOiBcIl9yZWZcIixcbiAgdGl0bGU6IFwiUmVmZXJlbmNlZCBkb2N1bWVudCBJRFwiLFxuICB0eXBlOiBcInN0cmluZ1wiXG59LCBXRUFLX0ZJRUxEID0ge1xuICBuYW1lOiBcIl93ZWFrXCIsXG4gIHRpdGxlOiBcIldlYWsgcmVmZXJlbmNlXCIsXG4gIHR5cGU6IFwiYm9vbGVhblwiXG59LCBSRUZFUkVOQ0VfRklFTERTID0gW1JFRl9GSUVMRCwgV0VBS19GSUVMRF0sIE9WRVJSSURBQkxFX0ZJRUxEUyQzID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIFJFRkVSRU5DRV9DT1JFID0ge1xuICBuYW1lOiBcInJlZmVyZW5jZVwiLFxuICB0aXRsZTogXCJSZWZlcmVuY2VcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwib2JqZWN0XCJcbn07XG5mdW5jdGlvbiBodW1hbml6ZShhcnIsIGNvbmp1bmN0aW9uKSB7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGlmIChsZW4gPT09IDEpXG4gICAgcmV0dXJuIGFyclswXTtcbiAgY29uc3QgZmlyc3QgPSBhcnIuc2xpY2UoMCwgbGVuIC0gMSksIGxhc3QgPSBhcnJbbGVuIC0gMV07XG4gIHJldHVybiBgJHtmaXJzdC5qb2luKFwiLCBcIil9ICR7Y29uanVuY3Rpb259ICR7bGFzdH1gO1xufVxuZnVuY3Rpb24gYnVpbGRUaXRsZSh0eXBlKSB7XG4gIHJldHVybiAhdHlwZS50byB8fCB0eXBlLnRvLmxlbmd0aCA9PT0gMCA/IFwiUmVmZXJlbmNlXCIgOiBgUmVmZXJlbmNlIHRvICR7aHVtYW5pemUoXG4gICAgYXJyaWZ5KHR5cGUudG8pLm1hcCgodG9UeXBlKSA9PiB0b1R5cGUudGl0bGUpLFxuICAgIFwib3JcIlxuICApLnRvTG93ZXJDYXNlKCl9YDtcbn1cbmNvbnN0IFJlZmVyZW5jZVR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUkVGRVJFTkNFX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmLCBjcmVhdGVNZW1iZXJUeXBlKSB7XG4gICAgaWYgKCFzdWJUeXBlRGVmLnRvKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWlzc2luZyBcInRvXCIgZmllbGQgaW4gcmVmZXJlbmNlIGRlZmluaXRpb24uIENoZWNrIHRoZSB0eXBlICR7c3ViVHlwZURlZi5uYW1lfWBcbiAgICAgICk7XG4gICAgY29uc3QgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKFJFRkVSRU5DRV9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkMyksIHN1YlR5cGVEZWYsIHtcbiAgICAgIHR5cGU6IFJFRkVSRU5DRV9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGxhenlHZXR0ZXIocGFyc2VkLCBcImZpZWxkc1wiLCAoKSA9PiBSRUZFUkVOQ0VfRklFTERTLm1hcCgoZmllbGREZWYpID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgLi4udHlwZSB9ID0gZmllbGREZWY7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlOiBjcmVhdGVNZW1iZXJUeXBlKHR5cGUpXG4gICAgICB9O1xuICAgIH0pKSwgbGF6eUdldHRlcihwYXJzZWQsIFwiZmllbGRzZXRzXCIsICgpID0+IGNyZWF0ZUZpZWxkc2V0cyhzdWJUeXBlRGVmLCBwYXJzZWQuZmllbGRzKSksIGxhenlHZXR0ZXIocGFyc2VkLCBcInRvXCIsICgpID0+IGFycmlmeShzdWJUeXBlRGVmLnRvKS5tYXAoKHRvVHlwZSkgPT4gY3JlYXRlTWVtYmVyVHlwZSh0b1R5cGUpKSksIGxhenlHZXR0ZXIocGFyc2VkLCBcInRpdGxlXCIsICgpID0+IHN1YlR5cGVEZWYudGl0bGUgfHwgYnVpbGRUaXRsZShwYXJzZWQpKSwgbGF6eUdldHRlcihcbiAgICAgIHBhcnNlZCxcbiAgICAgIE9XTl9QUk9QU19OQU1FLFxuICAgICAgKCkgPT4gKHtcbiAgICAgICAgLi4uc3ViVHlwZURlZixcbiAgICAgICAgZmllbGRzOiBwYXJzZWQuZmllbGRzLFxuICAgICAgICBmaWVsZHNldHM6IHBhcnNlZC5maWVsZHNldHMsXG4gICAgICAgIHRvOiBwYXJzZWQudG8sXG4gICAgICAgIHRpdGxlOiBwYXJzZWQudGl0bGVcbiAgICAgIH0pLFxuICAgICAgeyBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICExIH1cbiAgICApLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBpZiAoZXh0ZW5zaW9uRGVmLm9mKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcnJpZGUgYG9mYCBvZiBzdWJ0eXBlcyBvZiBcInJlZmVyZW5jZVwiJyk7XG4gICAgICAgICAgY29uc3Qgb3duUHJvcHMgPSBwaWNrKGV4dGVuc2lvbkRlZiwgT1ZFUlJJREFCTEVfRklFTERTJDMpLCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LCBvd25Qcm9wcywge1xuICAgICAgICAgICAgdHlwZTogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhpZGRlbkdldHRlcihjdXJyZW50LCBPV05fUFJPUFNfTkFNRSwgb3duUHJvcHMpLCBzdWJ0eXBlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSwgT1ZFUlJJREFCTEVfRklFTERTJDIgPSBbLi4uREVGQVVMVF9PVkVSUklERUFCTEVfRklFTERTXSwgU1RSSU5HX0NPUkUgPSB7XG4gIG5hbWU6IFwic3RyaW5nXCIsXG4gIHRpdGxlOiBcIlN0cmluZ1wiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJzdHJpbmdcIlxufSwgU3RyaW5nVHlwZSA9IHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBTVFJJTkdfQ09SRTtcbiAgfSxcbiAgZXh0ZW5kKHN1YlR5cGVEZWYpIHtcbiAgICBjb25zdCBvd25Qcm9wcyA9IHtcbiAgICAgIC4uLnN1YlR5cGVEZWYsXG4gICAgICBwcmV2aWV3OiBwcmltaXRpdmVQcmV2aWV3XG4gICAgfSwgcGFyc2VkID0gT2JqZWN0LmFzc2lnbihwaWNrKFNUUklOR19DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkMiksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBTVFJJTkdfQ09SRVxuICAgIH0pO1xuICAgIHJldHVybiBoaWRkZW5HZXR0ZXIocGFyc2VkLCBPV05fUFJPUFNfTkFNRSwgb3duUHJvcHMpLCBzdWJ0eXBlKHBhcnNlZCk7XG4gICAgZnVuY3Rpb24gc3VidHlwZShwYXJlbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBleHRlbmQ6IChleHRlbnNpb25EZWYpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJPd25Qcm9wcyA9IHBpY2soZXh0ZW5zaW9uRGVmLCBPVkVSUklEQUJMRV9GSUVMRFMkMiksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIHN1Yk93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBzdWJPd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59LCBPVkVSUklEQUJMRV9GSUVMRFMkMSA9IFsuLi5ERUZBVUxUX09WRVJSSURFQUJMRV9GSUVMRFMsIFwicm93c1wiXSwgVEVYVF9DT1JFID0ge1xuICBuYW1lOiBcInRleHRcIixcbiAgdGl0bGU6IFwiVGV4dFwiLFxuICB0eXBlOiBudWxsLFxuICBqc29uVHlwZTogXCJzdHJpbmdcIlxufSwgVGV4dFR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gVEVYVF9DT1JFO1xuICB9LFxuICBleHRlbmQoc3ViVHlwZURlZikge1xuICAgIGNvbnN0IG93blByb3BzID0ge1xuICAgICAgLi4uc3ViVHlwZURlZixcbiAgICAgIHByZXZpZXc6IHByaW1pdGl2ZVByZXZpZXdcbiAgICB9LCBwYXJzZWQgPSBPYmplY3QuYXNzaWduKHBpY2soVEVYVF9DT1JFLCBPVkVSUklEQUJMRV9GSUVMRFMkMSksIG93blByb3BzLCB7XG4gICAgICB0eXBlOiBURVhUX0NPUkVcbiAgICB9KTtcbiAgICByZXR1cm4gaGlkZGVuR2V0dGVyKHBhcnNlZCwgT1dOX1BST1BTX05BTUUsIG93blByb3BzKSwgc3VidHlwZShwYXJzZWQpO1xuICAgIGZ1bmN0aW9uIHN1YnR5cGUocGFyZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZW5kOiAoZXh0ZW5zaW9uRGVmKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3ViT3duUHJvcHMgPSBwaWNrKGV4dGVuc2lvbkRlZiwgT1ZFUlJJREFCTEVfRklFTERTJDEpLCBjdXJyZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LCBzdWJPd25Qcm9wcywge1xuICAgICAgICAgICAgdHlwZTogcGFyZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGhpZGRlbkdldHRlcihjdXJyZW50LCBPV05fUFJPUFNfTkFNRSwgc3ViT3duUHJvcHMpLCBzdWJ0eXBlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSwgT1ZFUlJJREFCTEVfRklFTERTID0gWy4uLkRFRkFVTFRfT1ZFUlJJREVBQkxFX0ZJRUxEU10sIFVSTF9DT1JFID0ge1xuICBuYW1lOiBcInVybFwiLFxuICB0aXRsZTogXCJVcmxcIixcbiAgdHlwZTogbnVsbCxcbiAganNvblR5cGU6IFwic3RyaW5nXCJcbn0sIFVybFR5cGUgPSB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gVVJMX0NPUkU7XG4gIH0sXG4gIGV4dGVuZChzdWJUeXBlRGVmKSB7XG4gICAgY29uc3Qgb3duUHJvcHMgPSB7XG4gICAgICAuLi5zdWJUeXBlRGVmLFxuICAgICAgcHJldmlldzogcHJpbWl0aXZlUHJldmlld1xuICAgIH0sIHBhcnNlZCA9IE9iamVjdC5hc3NpZ24ocGljayhVUkxfQ09SRSwgT1ZFUlJJREFCTEVfRklFTERTKSwgb3duUHJvcHMsIHtcbiAgICAgIHR5cGU6IFVSTF9DT1JFXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZGRlbkdldHRlcihwYXJzZWQsIE9XTl9QUk9QU19OQU1FLCBvd25Qcm9wcyksIHN1YnR5cGUocGFyc2VkKTtcbiAgICBmdW5jdGlvbiBzdWJ0eXBlKHBhcmVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVuZDogKGV4dGVuc2lvbkRlZikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN1Yk93bm93blByb3BzID0gcGljayhleHRlbnNpb25EZWYsIE9WRVJSSURBQkxFX0ZJRUxEUyksIGN1cnJlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQsIHN1Yk93bm93blByb3BzLCB7XG4gICAgICAgICAgICB0eXBlOiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gaGlkZGVuR2V0dGVyKGN1cnJlbnQsIE9XTl9QUk9QU19OQU1FLCBzdWJPd25vd25Qcm9wcyksIHN1YnR5cGUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59O1xudmFyIHR5cGVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFueTogQW55VHlwZSxcbiAgYXJyYXk6IEFycmF5VHlwZSxcbiAgYmxvY2s6IEJsb2NrVHlwZSxcbiAgYm9vbGVhbjogQm9vbGVhblR5cGUsXG4gIGNyb3NzRGF0YXNldFJlZmVyZW5jZTogQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVHlwZSxcbiAgZGF0ZTogRGF0ZVR5cGUsXG4gIGRhdGV0aW1lOiBEYXRlVGltZVR5cGUsXG4gIGRvY3VtZW50OiBEb2N1bWVudFR5cGUsXG4gIGVtYWlsOiBFbWFpbFR5cGUsXG4gIGZpbGU6IEZpbGVUeXBlLFxuICBnbG9iYWxEb2N1bWVudFJlZmVyZW5jZTogR2xvYmFsRG9jdW1lbnRSZWZlcmVuY2VUeXBlLFxuICBpbWFnZTogSW1hZ2VUeXBlLFxuICBudW1iZXI6IE51bWJlclR5cGUsXG4gIG9iamVjdDogT2JqZWN0VHlwZSxcbiAgcmVmZXJlbmNlOiBSZWZlcmVuY2VUeXBlLFxuICBzcGFuOiBTcGFuVHlwZSxcbiAgc3RyaW5nOiBTdHJpbmdUeXBlLFxuICB0ZXh0OiBUZXh0VHlwZSxcbiAgdXJsOiBVcmxUeXBlXG59KTtcbmZ1bmN0aW9uIGNvbXBpbGVSZWdpc3RyeShzY2hlbWFEZWYpIHtcbiAgY29uc3QgcmVnaXN0cnkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IGxvY2FsVHlwZU5hbWVzO1xuICBzY2hlbWFEZWYucGFyZW50ID8gKE9iamVjdC5hc3NpZ24ocmVnaXN0cnksIHNjaGVtYURlZi5wYXJlbnQuX3JlZ2lzdHJ5KSwgbG9jYWxUeXBlTmFtZXMgPSBbXSkgOiAoT2JqZWN0LmFzc2lnbihyZWdpc3RyeSwgdHlwZXMpLCBsb2NhbFR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKHR5cGVzKSk7XG4gIGNvbnN0IGRlZnNCeU5hbWUgPSBzY2hlbWFEZWYudHlwZXMucmVkdWNlKChhY2MsIGRlZikgPT4ge1xuICAgIGlmIChhY2NbZGVmLm5hbWVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdHlwZSBuYW1lIGFkZGVkIHRvIHNjaGVtYTogJHtkZWYubmFtZX1gKTtcbiAgICByZXR1cm4gYWNjW2RlZi5uYW1lXSA9IGRlZiwgYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBzY2hlbWFEZWYudHlwZXMuZm9yRWFjaChhZGQpLCB7XG4gICAgcmVnaXN0cnksXG4gICAgbG9jYWxUeXBlTmFtZXNcbiAgfTtcbiAgZnVuY3Rpb24gZW5zdXJlKHR5cGVOYW1lKSB7XG4gICAgaWYgKCFyZWdpc3RyeVt0eXBlTmFtZV0pIHtcbiAgICAgIGlmICghZGVmc0J5TmFtZVt0eXBlTmFtZV0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0eXBlOiAke3R5cGVOYW1lfWApO1xuICAgICAgYWRkKGRlZnNCeU5hbWVbdHlwZU5hbWVdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXh0ZW5kTWVtYmVyKG1lbWJlckRlZikge1xuICAgIHJldHVybiBlbnN1cmUobWVtYmVyRGVmLnR5cGUpLCByZWdpc3RyeVttZW1iZXJEZWYudHlwZV0uZXh0ZW5kKG1lbWJlckRlZiwgZXh0ZW5kTWVtYmVyKS5nZXQoKTtcbiAgfVxuICBmdW5jdGlvbiBhZGQodHlwZURlZikge1xuICAgIGVuc3VyZSh0eXBlRGVmLnR5cGUpLCAhcmVnaXN0cnlbdHlwZURlZi5uYW1lXSAmJiAobG9jYWxUeXBlTmFtZXMucHVzaCh0eXBlRGVmLm5hbWUpLCByZWdpc3RyeVt0eXBlRGVmLm5hbWVdID0gcmVnaXN0cnlbdHlwZURlZi50eXBlXS5leHRlbmQodHlwZURlZiwgZXh0ZW5kTWVtYmVyKSk7XG4gIH1cbn1cbmxldCBTY2hlbWEkMSA9IGNsYXNzIFNjaGVtYSB7XG4gIF9vcmlnaW5hbDtcbiAgX3JlZ2lzdHJ5O1xuICAjbG9jYWxUeXBlTmFtZXM7XG4gIHN0YXRpYyBjb21waWxlKHNjaGVtYURlZikge1xuICAgIHJldHVybiBuZXcgU2NoZW1hKHNjaGVtYURlZik7XG4gIH1cbiAgY29uc3RydWN0b3Ioc2NoZW1hRGVmKSB7XG4gICAgdGhpcy5fb3JpZ2luYWwgPSBzY2hlbWFEZWY7XG4gICAgY29uc3QgeyByZWdpc3RyeSwgbG9jYWxUeXBlTmFtZXMgfSA9IGNvbXBpbGVSZWdpc3RyeShzY2hlbWFEZWYpO1xuICAgIHRoaXMuX3JlZ2lzdHJ5ID0gcmVnaXN0cnksIHRoaXMuI2xvY2FsVHlwZU5hbWVzID0gbG9jYWxUeXBlTmFtZXM7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsLm5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBzY2hlbWEuXG4gICAqL1xuICBnZXQgcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbC5wYXJlbnQ7XG4gIH1cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnlbbmFtZV0gJiYgdGhpcy5fcmVnaXN0cnlbbmFtZV0uZ2V0KCk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSBpbiB0aGlzLl9yZWdpc3RyeTtcbiAgfVxuICBnZXRUeXBlTmFtZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3JlZ2lzdHJ5KTtcbiAgfVxuICBnZXRMb2NhbFR5cGVOYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy4jbG9jYWxUeXBlTmFtZXM7XG4gIH1cbn07XG5jbGFzcyBEZXByZWNhdGVkRGVmYXVsdFNjaGVtYSBleHRlbmRzIFNjaGVtYSQxIHtcbiAgc3RhdGljIGNvbXBpbGUoc2NoZW1hRGVmKSB7XG4gICAgcmV0dXJuIG5ldyBEZXByZWNhdGVkRGVmYXVsdFNjaGVtYShzY2hlbWFEZWYpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHNjaGVtYURlZikge1xuICAgIHN1cGVyKHNjaGVtYURlZik7XG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoXG4gICAgICAnVGhlIGRlZmF1bHQgZXhwb3J0IG9mIGBAc2FuaXR5L3NjaGVtYWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBpbXBvcnQge1NjaGVtYX0gZnJvbSBcIkBzYW5pdHkvc2NoZW1hXCJgIGluc3RlYWQuJ1xuICAgICkuc3RhY2sucmVwbGFjZSgvXkVycm9yLywgXCJXYXJuaW5nXCIpO1xuICAgIGNvbnNvbGUud2FybihzdGFjayk7XG4gIH1cbn1cbmNvbnN0IFNjaGVtYTIgPSBTY2hlbWEkMTtcbmV4cG9ydCB7XG4gIFNjaGVtYTIgYXMgU2NoZW1hLFxuICBEZXByZWNhdGVkRGVmYXVsdFNjaGVtYSBhcyBkZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+schema@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/schema/lib/index.mjs\n");

/***/ })

};
;