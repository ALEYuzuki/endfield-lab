"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@portabletext+block-tools@1_85ea45ec7b1750c9ee9308599ea2f210";
exports.ids = ["vendor-chunks/@portabletext+block-tools@1_85ea45ec7b1750c9ee9308599ea2f210"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@portabletext+block-tools@1_85ea45ec7b1750c9ee9308599ea2f210/node_modules/@portabletext/block-tools/lib/index.js":
/*!**********************************************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@portabletext+block-tools@1_85ea45ec7b1750c9ee9308599ea2f210/node_modules/@portabletext/block-tools/lib/index.js ***!
  \**********************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getBlockContentFeatures: () => (/* binding */ getBlockContentFeatures),\n/* harmony export */   htmlToBlocks: () => (/* binding */ htmlToBlocks),\n/* harmony export */   normalizeBlock: () => (/* binding */ normalizeBlock),\n/* harmony export */   randomKey: () => (/* binding */ randomKey)\n/* harmony export */ });\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js\");\n/* harmony import */ var _sanity_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @sanity/types */ \"(ssr)/../node_modules/.pnpm/@sanity+types@3.99.0_@types+react@18.3.24_debug@4.4.3/node_modules/@sanity/types/lib/index.mjs\");\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/uniq.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js\");\n/* harmony import */ var get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! get-random-values-esm */ \"(ssr)/../node_modules/.pnpm/get-random-values-esm@1.0.2/node_modules/get-random-values-esm/index.mjs\");\n\n\n\n\n\nfunction findBlockType(type) {\n  return type.type ? findBlockType(type.type) : type.name === \"block\";\n}\nconst objectToString = Object.prototype.toString;\nfunction resolveJsType(val) {\n  switch (objectToString.call(val)) {\n    case \"[object Function]\":\n      return \"function\";\n    case \"[object Date]\":\n      return \"date\";\n    case \"[object RegExp]\":\n      return \"regexp\";\n    case \"[object Arguments]\":\n      return \"arguments\";\n    case \"[object Array]\":\n      return \"array\";\n    case \"[object String]\":\n      return \"string\";\n  }\n  return val === null ? \"null\" : val === void 0 ? \"undefined\" : val && typeof val == \"object\" && \"nodeType\" in val && val.nodeType === 1 ? \"element\" : val === Object(val) ? \"object\" : typeof val;\n}\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 };\nnew Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction _(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction O(t) {\n  return t && JSON.parse(_(JSON.stringify(t)).cleaned);\n}\nconst PRESERVE_WHITESPACE_TAGS = [\"pre\", \"textarea\", \"code\"], BLOCK_DEFAULT_STYLE = \"normal\", DEFAULT_BLOCK = Object.freeze({\n  _type: \"block\",\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE\n}), DEFAULT_SPAN = Object.freeze({\n  _type: \"span\",\n  marks: []\n}), HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: { ...DEFAULT_BLOCK, style: \"blockquote\" }\n}, HTML_SPAN_TAGS = {\n  span: { object: \"text\" }\n}, HTML_LIST_CONTAINER_TAGS = {\n  ol: { object: null },\n  ul: { object: null }\n}, HTML_HEADER_TAGS = {\n  h1: { ...DEFAULT_BLOCK, style: \"h1\" },\n  h2: { ...DEFAULT_BLOCK, style: \"h2\" },\n  h3: { ...DEFAULT_BLOCK, style: \"h3\" },\n  h4: { ...DEFAULT_BLOCK, style: \"h4\" },\n  h5: { ...DEFAULT_BLOCK, style: \"h5\" },\n  h6: { ...DEFAULT_BLOCK, style: \"h6\" }\n}, HTML_MISC_TAGS = {\n  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }\n}, HTML_DECORATOR_TAGS = {\n  b: \"strong\",\n  strong: \"strong\",\n  i: \"em\",\n  em: \"em\",\n  u: \"underline\",\n  s: \"strike-through\",\n  strike: \"strike-through\",\n  del: \"strike-through\",\n  code: \"code\",\n  sup: \"sup\",\n  sub: \"sub\",\n  ins: \"ins\",\n  mark: \"mark\",\n  small: \"small\"\n}, HTML_LIST_ITEM_TAGS = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: \"bullet\"\n  }\n}, ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS\n};\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(ELEMENT_MAP).filter((tag) => \"style\" in tag).map((tag) => tag.style)\n);\nlodash_uniq_js__WEBPACK_IMPORTED_MODULE_2__(\n  Object.values(HTML_DECORATOR_TAGS)\n);\nfunction blockContentFeatures(blockContentType) {\n  if (!blockContentType)\n    throw new Error(\"Parameter 'blockContentType' required\");\n  const blockType = blockContentType.of.find(findBlockType);\n  if (!(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockSchemaType)(blockType))\n    throw new Error(\"'block' type is not defined in this schema (required).\");\n  const ofType = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockChildrenObjectField)?.type?.of;\n  if (!ofType)\n    throw new Error(\"No `of` declaration found for blocks `children` field\");\n  const spanType = ofType.find(\n    (member) => member.name === \"span\"\n  );\n  if (!spanType)\n    throw new Error(\n      \"No `span` type found in `block` schema type `children` definition\"\n    );\n  const inlineObjectTypes = ofType.filter(\n    (inlineType) => inlineType.name !== \"span\" && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(inlineType)\n  ), blockObjectTypes = blockContentType.of.filter(\n    (memberType) => memberType.name !== blockType.name && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isObjectSchemaType)(memberType)\n  );\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    annotations: resolveEnabledAnnotationTypes(spanType),\n    lists: resolveEnabledListItems(blockType),\n    types: {\n      block: blockContentType,\n      span: spanType,\n      inlineObjects: inlineObjectTypes,\n      blockObjects: blockObjectTypes\n    }\n  };\n}\nfunction resolveEnabledStyles(blockType) {\n  const styleField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockStyleObjectField);\n  if (!styleField)\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\"\n    );\n  const textStyles = getTitledListValuesFromEnumListOptions(\n    styleField.type.options\n  );\n  if (textStyles.length === 0)\n    throw new Error(\n      \"The style fields need at least one style defined. I.e: {title: 'Normal', value: 'normal'}.\"\n    );\n  return textStyles;\n}\nfunction resolveEnabledAnnotationTypes(spanType) {\n  return spanType.annotations.map((annotation) => ({\n    title: annotation.title,\n    type: annotation,\n    value: annotation.name,\n    icon: annotation.icon\n  }));\n}\nfunction resolveEnabledDecorators(spanType) {\n  return spanType.decorators;\n}\nfunction resolveEnabledListItems(blockType) {\n  const listField = blockType.fields.find(_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isBlockListObjectField);\n  if (!listField)\n    throw new Error(\n      \"A field with name 'list' is not defined in the block type (required).\"\n    );\n  const listItems = getTitledListValuesFromEnumListOptions(\n    listField.type.options\n  );\n  if (!listItems)\n    throw new Error(\"The list field need at least to be an empty array\");\n  return listItems;\n}\nfunction getTitledListValuesFromEnumListOptions(options) {\n  const list = options ? options.list : void 0;\n  return Array.isArray(list) ? list.map(\n    (item) => (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isTitledListValue)(item) ? item : { title: item, value: item }\n  ) : [];\n}\nconst _XPathResult = {\n  BOOLEAN_TYPE: 3,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6\n};\nvar preprocessGDocs = (_html, doc, options) => {\n  const whitespaceOnPasteMode = options?.unstable_whitespaceOnPasteMode || \"preserve\";\n  let gDocsRootOrSiblingNode = doc.evaluate(\n    '//*[@id and contains(@id, \"docs-internal-guid\")]',\n    doc,\n    null,\n    _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n    null\n  ).iterateNext();\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === \"b\";\n    switch (isWrappedRootTag || (gDocsRootOrSiblingNode = doc.body), whitespaceOnPasteMode) {\n      case \"normalize\":\n        normalizeWhitespace(gDocsRootOrSiblingNode);\n        break;\n      case \"remove\":\n        removeAllWhitespace(gDocsRootOrSiblingNode);\n        break;\n    }\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i);\n      elm?.setAttribute(\"data-is-google-docs\", \"true\"), (elm?.parentElement === gDocsRootOrSiblingNode || !isWrappedRootTag && elm.parentElement === doc.body) && (elm?.setAttribute(\"data-is-root-node\", \"true\"), tagName(elm)), tagName(elm) === \"li\" && elm.firstChild && tagName(elm?.firstChild) === \"img\" && elm.removeChild(elm.firstChild);\n    }\n    return isWrappedRootTag && doc.body.firstElementChild?.replaceWith(\n      ...Array.from(gDocsRootOrSiblingNode.childNodes)\n    ), doc;\n  }\n  return doc;\n};\nconst unwantedWordDocumentPaths = [\n  \"/html/text()\",\n  \"/html/head/text()\",\n  \"/html/body/text()\",\n  \"/html/body/ul/text()\",\n  \"/html/body/ol/text()\",\n  \"//comment()\",\n  \"//style\",\n  \"//xml\",\n  \"//script\",\n  \"//meta\",\n  \"//link\"\n];\nvar preprocessHTML = (_html, doc) => {\n  const bodyTextNodes = doc.evaluate(\n    \"/html/body/text()\",\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i), text = node.textContent || \"\";\n    if (text.replace(/[^\\S\\n]+$/g, \"\")) {\n      const newNode = doc.createElement(\"span\");\n      newNode.appendChild(doc.createTextNode(text)), node.parentNode?.replaceChild(newNode, node);\n    } else\n      node.parentNode?.removeChild(node);\n  }\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted && unwanted.parentNode?.removeChild(unwanted);\n  }\n  return doc;\n}, preprocessNotion = (html, doc) => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g;\n  if (html.match(NOTION_REGEX)) {\n    const childNodes = doc.evaluate(\n      \"//*\",\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null\n    );\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--)\n      childNodes.snapshotItem(i)?.setAttribute(\"data-is-notion\", \"true\");\n    return doc;\n  }\n  return doc;\n}, preprocessWhitespace = (_2, doc) => {\n  function processNode(node) {\n    if (node.nodeType === _XPathResult.BOOLEAN_TYPE && !PRESERVE_WHITESPACE_TAGS.includes(\n      node.parentElement?.tagName.toLowerCase() || \"\"\n    ))\n      node.textContent = node.textContent?.replace(/\\s\\s+/g, \" \").replace(/[\\r\\n]+/g, \" \") || \"\";\n    else\n      for (let i = 0; i < node.childNodes.length; i++)\n        processNode(node.childNodes[i]);\n  }\n  return processNode(doc.body), doc;\n};\nconst WORD_HTML_REGEX = /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/, unwantedPaths = [\n  \"//o:p\",\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\"\n], mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\"\n], elementMap = {\n  MsoTocHeading: [\"h3\"],\n  MsoTitle: [\"h1\"],\n  MsoToaHeading: [\"h2\"],\n  MsoSubtitle: [\"h5\"],\n  MsoSubtleEmphasis: [\"span\", \"em\"],\n  MsoIntenseEmphasis: [\"span\", \"em\", \"strong\"]\n  // Remove cruft\n};\nfunction isWordHtml(html) {\n  return WORD_HTML_REGEX.test(html);\n}\nvar preprocessWord = (html, doc) => {\n  if (!isWordHtml(html))\n    return doc;\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join(\"|\"),\n    doc,\n    (prefix) => prefix === \"o\" ? \"urn:schemas-microsoft-com:office:office\" : null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i);\n    unwanted?.parentNode && unwanted.parentNode.removeChild(unwanted);\n  }\n  const mappedElements = doc.evaluate(\n    mappedPaths.join(\"|\"),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null\n  );\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i), tags = elementMap[mappedElm.className], text = doc.createTextNode(mappedElm.textContent || \"\");\n    if (!tags)\n      continue;\n    const parentElement = doc.createElement(tags[0]);\n    let parent = parentElement, child = parentElement;\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag), parent.appendChild(child), parent = child;\n    }), child.appendChild(text), mappedElm?.parentNode?.replaceChild(parentElement, mappedElm);\n  }\n  return doc;\n}, preprocessors = [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML\n];\nfunction createRuleOptions(blockContentType) {\n  const features = blockContentFeatures(blockContentType), enabledBlockStyles = features.styles.map(\n    (item) => item.value || item.title\n  ), enabledSpanDecorators = features.decorators.map(\n    (item) => item.value || item.title\n  ), enabledBlockAnnotations = features.annotations.map(\n    (item) => item.value || item.title || \"\"\n  ), enabledListTypes = features.lists.map(\n    (item) => item.value || item.title || \"\"\n  );\n  return {\n    enabledBlockStyles,\n    enabledSpanDecorators,\n    enabledBlockAnnotations,\n    enabledListTypes\n  };\n}\nfunction tagName(el) {\n  if (el && \"tagName\" in el)\n    return el.tagName.toLowerCase();\n}\nfunction preprocess(html, parseHtml, options) {\n  const cleanHTML = O(html), doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML));\n  return preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options);\n  }), doc;\n}\nfunction normalizeHtmlBeforePreprocess(html) {\n  return html.trim();\n}\nfunction defaultParseHtml() {\n  if (resolveJsType(DOMParser) === \"undefined\")\n    throw new Error(\n      \"The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.\"\n    );\n  return (html) => new DOMParser().parseFromString(html, \"text/html\");\n}\nfunction flattenNestedBlocks(blocks2) {\n  let depth = 0;\n  const flattened = [], traverse = (nodes) => {\n    const toRemove = [];\n    nodes.forEach((node) => {\n      depth === 0 && flattened.push(node), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(node) && (depth > 0 && (toRemove.push(node), flattened.push(node)), depth++, traverse(node.children)), node._type === \"__block\" && (toRemove.push(node), flattened.push(node.block));\n    }), toRemove.forEach((node) => {\n      nodes.splice(nodes.indexOf(node), 1);\n    }), depth--;\n  };\n  return traverse(blocks2), flattened;\n}\nfunction nextSpan(block, index) {\n  const next = block.children[index + 1];\n  return next && next._type === \"span\" ? next : null;\n}\nfunction prevSpan(block, index) {\n  const prev = block.children[index - 1];\n  return prev && prev._type === \"span\" ? prev : null;\n}\nfunction isWhiteSpaceChar(text) {\n  return [\"\\xA0\", \" \"].includes(text);\n}\nfunction trimWhitespace(blocks2) {\n  return blocks2.forEach((block) => {\n    (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(block) && block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child))\n        return;\n      const nextChild = nextSpan(block, index), prevChild = prevSpan(block, index);\n      index === 0 && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), index === block.children.length - 1 && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) && nextChild && isMinimalSpan(nextChild) && /\\s/.test(nextChild.text.slice(0, 1)) && (child.text = child.text.replace(/[^\\S\\n]+$/g, \"\")), /\\s/.test(child.text.slice(0, 1)) && prevChild && isMinimalSpan(prevChild) && /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1))) && (child.text = child.text.replace(/^[^\\S\\n]+/g, \"\")), child.text || block.children.splice(index, 1), prevChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(prevChild.marks, child.marks) && isWhiteSpaceChar(child.text) ? (prevChild.text += \" \", block.children.splice(index, 1)) : nextChild && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(nextChild.marks, child.marks) && isWhiteSpaceChar(child.text) && (nextChild.text = ` ${nextChild.text}`, block.children.splice(index, 1));\n    });\n  }), blocks2;\n}\nfunction ensureRootIsBlocks(blocks2) {\n  return blocks2.reduce((memo, node, i, original) => {\n    if (node._type === \"block\")\n      return memo.push(node), memo;\n    if (node._type === \"__block\")\n      return memo.push(node.block), memo;\n    const lastBlock = memo[memo.length - 1];\n    if (i > 0 && !(0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(original[i - 1]) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextTextBlock)(lastBlock))\n      return lastBlock.children.push(node), memo;\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node]\n    };\n    return memo.push(block), memo;\n  }, []);\n}\nfunction isNodeList(node) {\n  return Object.prototype.toString.call(node) === \"[object NodeList]\";\n}\nfunction isMinimalSpan(node) {\n  return node._type === \"span\";\n}\nfunction isMinimalBlock(node) {\n  return node._type === \"block\";\n}\nfunction isPlaceholderDecorator(node) {\n  return node._type === \"__decorator\";\n}\nfunction isPlaceholderAnnotation(node) {\n  return node._type === \"__annotation\";\n}\nfunction isElement(node) {\n  return node.nodeType === 1;\n}\nfunction normalizeWhitespace(rootNode) {\n  let emptyBlockCount = 0, lastParent = null;\n  const nodesToRemove = [];\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child), emptyBlockCount = 0;\n      continue;\n    }\n    const elm = child;\n    isWhitespaceBlock(elm) ? (lastParent && elm.parentElement === lastParent ? (emptyBlockCount++, emptyBlockCount > 1 && nodesToRemove.push(elm)) : emptyBlockCount = 1, lastParent = elm.parentElement) : (normalizeWhitespace(child), emptyBlockCount = 0);\n  }\n  nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction removeAllWhitespace(rootNode) {\n  const nodesToRemove = [];\n  function collectNodesToRemove(currentNode) {\n    if (isElement(currentNode)) {\n      const elm = currentNode;\n      if (tagName(elm) === \"br\" && (tagName(elm.nextElementSibling) === \"p\" || tagName(elm.previousElementSibling) === \"p\")) {\n        nodesToRemove.push(elm);\n        return;\n      }\n      if ((tagName(elm) === \"p\" || tagName(elm) === \"br\") && elm?.firstChild?.textContent?.trim() === \"\") {\n        nodesToRemove.push(elm);\n        return;\n      }\n      for (let child = elm.firstChild; child; child = child.nextSibling)\n        collectNodesToRemove(child);\n    }\n  }\n  collectNodesToRemove(rootNode), nodesToRemove.forEach((node) => node.parentElement?.removeChild(node));\n}\nfunction isWhitespaceBlock(elm) {\n  return [\"p\", \"br\"].includes(tagName(elm) || \"\") && !elm.textContent?.trim();\n}\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS);\nfunction isEmphasis$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style\\s*:\\s*italic/.test(style || \"\");\n}\nfunction isStrong$1(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight\\s*:\\s*700/.test(style || \"\");\n}\nfunction isUnderline$1(el) {\n  if (!isElement(el) || tagName(el.parentNode) === \"a\")\n    return !1;\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*underline/.test(style || \"\");\n}\nfunction isStrikethrough(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || \"\");\n}\nfunction isGoogleDocs(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-google-docs\");\n}\nfunction isRootNode(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-root-node\");\n}\nfunction getListItemStyle$1(el) {\n  const parentTag = tagName(el.parentNode);\n  if (!(parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)))\n    return tagName(el.parentNode) === \"ul\" ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel$1(el) {\n  let level = 0;\n  if (tagName(el) === \"li\") {\n    let parentNode = el.parentNode;\n    for (; parentNode; ) {\n      const parentTag = tagName(parentNode);\n      parentTag && LIST_CONTAINER_TAGS.includes(parentTag) && level++, parentNode = parentNode.parentNode;\n    }\n  } else\n    level = 1;\n  return level;\n}\nconst blocks = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS\n};\nfunction getBlockStyle(el, enabledBlockStyles) {\n  const childTag = tagName(el.firstChild), block = childTag && blocks[childTag];\n  return block && enabledBlockStyles.includes(block.style) ? block.style : BLOCK_DEFAULT_STYLE;\n}\nfunction createGDocsRules(_blockContentType, options) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isGoogleDocs(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong$1(el) && span.marks.push(\"strong\"), isUnderline$1(el) && span.marks.push(\"underline\"), isStrikethrough(el) && span.marks.push(\"strike-through\"), isEmphasis$1(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"li\" && isGoogleDocs(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle$1(el),\n            level: getListItemLevel$1(el),\n            style: getBlockStyle(el, options.enabledBlockStyles),\n            children: next(el.firstChild?.childNodes || [])\n          };\n      }\n    },\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el.classList.contains(\"apple-interchange-newline\"))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && el?.parentNode?.textContent === \"\")\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n        if (tagName(el) === \"br\" && isGoogleDocs(el) && isElement(el) && isRootNode(el))\n          return {\n            ...DEFAULT_SPAN,\n            text: \"\"\n          };\n      }\n    }\n  ];\n}\nfunction keyGenerator() {\n  return randomKey(12);\n}\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length);\n  return (0,get_random_values_esm__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(rnds8), rnds8;\n}\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i)\n  byteToHex[i] = (i + 256).toString(16).slice(1);\nfunction randomKey(length) {\n  return whatwgRNG(length).reduce((str, n) => str + byteToHex[n], \"\").slice(0, length);\n}\nconst whitespaceTextNodeRule = {\n  deserialize(node) {\n    return node.nodeName === \"#text\" && isWhitespaceTextNode(node) ? {\n      ...DEFAULT_SPAN,\n      marks: [],\n      text: (node.textContent ?? \"\").replace(/\\s\\s+/g, \" \")\n    } : void 0;\n  }\n};\nfunction isWhitespaceTextNode(node) {\n  return (node.nodeType === 3 && (node.textContent || \"\").replace(/[\\r\\n]/g, \" \").replace(/\\s\\s+/g, \" \") === \" \" && node.nextSibling && node.nextSibling.nodeType !== 3 && node.previousSibling && node.previousSibling.nodeType !== 3 || node.textContent !== \" \") && tagName(node.parentNode) !== \"body\";\n}\nfunction resolveListItem(listNodeTagName, enabledListTypes) {\n  if (listNodeTagName === \"ul\" && enabledListTypes.includes(\"bullet\"))\n    return \"bullet\";\n  if (listNodeTagName === \"ol\" && enabledListTypes.includes(\"number\"))\n    return \"number\";\n}\nfunction createHTMLRules(_blockContentType, options) {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== \"pre\")\n          return;\n        const isCodeEnabled = options.enabledBlockStyles.includes(\"code\");\n        return {\n          _type: \"block\",\n          style: \"normal\",\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? [\"code\"] : [],\n              text: el.textContent || \"\"\n            }\n          ]\n        };\n      }\n    },\n    // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"blockquote\")\n          return;\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        };\n        delete blocks2.blockquote;\n        const nonBlockquoteBlocks = Object.keys(blocks2), children = [];\n        return el.childNodes.forEach((node, index) => {\n          if (el.ownerDocument)\n            if (node.nodeType === 1 && nonBlockquoteBlocks.includes(\n              node.localName.toLowerCase()\n            )) {\n              const span = el.ownerDocument.createElement(\"span\"), previousChild = children[children.length - 1];\n              previousChild && previousChild.nodeType === 3 && previousChild.textContent?.trim() && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), node.childNodes.forEach((cn) => {\n                span.appendChild(cn.cloneNode(!0));\n              }), index !== el.childNodes.length && span.appendChild(el.ownerDocument.createTextNode(\"\\r\")), children.push(span);\n            } else\n              children.push(node);\n        }), {\n          _type: \"block\",\n          style: \"blockquote\",\n          markDefs: [],\n          children: next(children)\n        };\n      }\n    },\n    // Block elements\n    {\n      deserialize(el, next) {\n        const blocks2 = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS\n        }, tag = tagName(el);\n        let block = tag ? blocks2[tag] : void 0;\n        if (block)\n          return el.parentNode && tagName(el.parentNode) === \"li\" ? next(el.childNodes) : (options.enabledBlockStyles.includes(block.style) || (block = DEFAULT_BLOCK), {\n            ...block,\n            children: next(el.childNodes)\n          });\n      }\n    },\n    // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_SPAN_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Ignore div tags\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"div\")\n          return next(el.childNodes);\n      }\n    },\n    // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el);\n        if (!(!tag || !(tag in HTML_LIST_CONTAINER_TAGS)))\n          return next(el.childNodes);\n      }\n    },\n    // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === \"br\")\n          return {\n            ...DEFAULT_SPAN,\n            text: `\n`\n          };\n      }\n    },\n    // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el), listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : void 0, parentTag = tagName(el.parentNode) || \"\";\n        if (!listItem || !el.parentNode || !HTML_LIST_CONTAINER_TAGS[parentTag])\n          return;\n        const enabledListItem = resolveListItem(\n          parentTag,\n          options.enabledListTypes\n        );\n        return enabledListItem ? (listItem.listItem = enabledListItem, {\n          ...listItem,\n          children: next(el.childNodes)\n        }) : block({ _type: \"block\", children: next(el.childNodes) });\n      }\n    },\n    // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || \"\"];\n        if (!(!decorator || !options.enabledSpanDecorators.includes(decorator)))\n          return {\n            _type: \"__decorator\",\n            name: decorator,\n            children: next(el.childNodes)\n          };\n      }\n    },\n    // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== \"a\")\n          return;\n        const linkEnabled = options.enabledBlockAnnotations.includes(\"link\"), href = isElement(el) && el.getAttribute(\"href\");\n        if (!href)\n          return next(el.childNodes);\n        let markDef;\n        return linkEnabled ? (markDef = {\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n          _type: \"link\",\n          href\n        }, {\n          _type: \"__annotation\",\n          markDef,\n          children: next(el.childNodes)\n        }) : el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) && next(el.childNodes);\n      }\n    }\n  ];\n}\nfunction isEmphasis(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-style:italic/.test(style || \"\");\n}\nfunction isStrong(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /font-weight:700/.test(style || \"\") || /font-weight:600/.test(style || \"\");\n}\nfunction isUnderline(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  return /text-decoration:underline/.test(style || \"\");\n}\nfunction isNotion(el) {\n  return isElement(el) && !!el.getAttribute(\"data-is-notion\");\n}\nfunction createNotionRules(_blockContentType) {\n  return [\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === \"span\" && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [],\n            text: el.textContent\n          };\n          return isStrong(el) && span.marks.push(\"strong\"), isUnderline(el) && span.marks.push(\"underline\"), isEmphasis(el) && span.marks.push(\"em\"), span;\n        }\n      }\n    }\n  ];\n}\nfunction getListItemStyle(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (style && style.match(/lfo\\d+/))\n    return style.match(\"lfo1\") ? \"bullet\" : \"number\";\n}\nfunction getListItemLevel(el) {\n  const style = isElement(el) && el.getAttribute(\"style\");\n  if (!style)\n    return;\n  const levelMatch = style.match(/level\\d+/);\n  if (!levelMatch)\n    return;\n  const [level] = levelMatch[0].match(/\\d/) || [];\n  return (level ? Number.parseInt(level, 10) : 1) || 1;\n}\nfunction isWordListElement(el) {\n  return isElement(el) && el.className ? el.className === \"MsoListParagraphCxSpFirst\" || el.className === \"MsoListParagraphCxSpMiddle\" || el.className === \"MsoListParagraphCxSpLast\" : !1;\n}\nfunction createWordRules() {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === \"p\" && isWordListElement(el))\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes)\n          };\n      }\n    }\n  ];\n}\nfunction createRules(blockContentType, options) {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(blockContentType, options),\n    ...createHTMLRules(blockContentType, options)\n  ];\n}\nclass HtmlDeserializer {\n  blockContentType;\n  rules;\n  parseHtml;\n  _markDefs = [];\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(blockContentType, options = {}) {\n    const { rules = [], unstable_whitespaceOnPasteMode = \"preserve\" } = options;\n    if (!blockContentType)\n      throw new Error(\"Parameter 'blockContentType' is required\");\n    const standardRules = createRules(blockContentType, {\n      ...createRuleOptions(blockContentType),\n      keyGenerator: options.keyGenerator\n    });\n    this.rules = [...rules, ...standardRules];\n    const parseHtml = options.parseHtml || defaultParseHtml();\n    this.blockContentType = blockContentType, this.parseHtml = (html) => preprocess(html, parseHtml, { unstable_whitespaceOnPasteMode }).body;\n  }\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html) => {\n    this._markDefs = [];\n    const { parseHtml } = this, fragment = parseHtml(html), children = Array.from(fragment.childNodes), blocks2 = trimWhitespace(\n      flattenNestedBlocks(\n        ensureRootIsBlocks(this.deserializeElements(children))\n      )\n    );\n    this._markDefs.length > 0 && blocks2.filter(\n      (block) => block._type === \"block\"\n    ).forEach((block) => {\n      block.markDefs = block.markDefs || [], block.markDefs = block.markDefs.concat(\n        this._markDefs.filter((def) => lodash_flatten_js__WEBPACK_IMPORTED_MODULE_0__(\n          block.children.map((child) => child.marks || [])\n        ).includes(def._key))\n      );\n    });\n    const type = this.blockContentType.of.find(findBlockType);\n    return type ? blocks2.map((block) => (block._type === \"block\" && (block._type = type.name), block)) : blocks2;\n  };\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements = []) => {\n    let nodes = [];\n    return elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element));\n    }), nodes;\n  };\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element) => {\n    const next = (elements) => {\n      if (isNodeList(elements))\n        return this.deserializeElements(Array.from(elements));\n      if (Array.isArray(elements))\n        return this.deserializeElements(elements);\n      if (elements)\n        return this.deserializeElement(elements);\n    }, block = (props) => ({\n      _type: \"__block\",\n      block: props\n    });\n    let node;\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i];\n      if (!rule.deserialize)\n        continue;\n      const ret = rule.deserialize(element, next, block), type = resolveJsType(ret);\n      if (type !== \"array\" && type !== \"object\" && type !== \"null\" && type !== \"undefined\")\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        );\n      if (ret !== void 0) {\n        {\n          if (ret === null)\n            throw new Error(\"Deserializer rule returned `null`\");\n          Array.isArray(ret) ? node = ret : isPlaceholderDecorator(ret) ? node = this.deserializeDecorator(ret) : isPlaceholderAnnotation(ret) ? node = this.deserializeAnnotation(ret) : node = ret;\n        }\n        if (ret && !Array.isArray(ret) && isMinimalBlock(ret) && \"listItem\" in ret) {\n          let parent = element.parentNode?.parentNode;\n          for (; parent && tagName(parent) === \"li\"; )\n            parent = parent.parentNode?.parentNode, ret.level = ret.level ? ret.level + 1 : 1;\n        }\n        ret && !Array.isArray(ret) && isMinimalBlock(ret) && ret.style === \"blockquote\" && ret.children.forEach((child, index) => {\n          isMinimalSpan(child) && child.text === \"\\r\" && (child.text = `\n`, (index === 0 || index === ret.children.length - 1) && ret.children.splice(index, 1));\n        });\n        break;\n      }\n    }\n    return node || next(element.childNodes) || [];\n  };\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator) => {\n    const { name } = decorator, applyDecorator = (node) => {\n      if (isPlaceholderDecorator(node))\n        return this.deserializeDecorator(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(name);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyDecorator);\n      }\n      return node;\n    };\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (annotation) => {\n    const { markDef } = annotation;\n    this._markDefs.push(markDef);\n    const applyAnnotation = (node) => {\n      if (isPlaceholderAnnotation(node))\n        return this.deserializeAnnotation(node);\n      if (isMinimalSpan(node))\n        node.marks = node.marks || [], node.text.trim() && node.marks.unshift(markDef._key);\n      else if (\"children\" in node && Array.isArray(node.children)) {\n        const block = node;\n        block.children = block.children.map(applyAnnotation);\n      }\n      return node;\n    };\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node);\n      return Array.isArray(ret) ? children.concat(ret) : (children.push(ret), children);\n    }, []);\n  };\n}\nfunction normalizeBlock(node, options = {}) {\n  if (node._type !== (options.blockTypeName || \"block\"))\n    return \"_key\" in node ? node : {\n      ...node,\n      _key: options.keyGenerator ? options.keyGenerator() : keyGenerator()\n    };\n  const block = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node\n  }, lastChild = block.children[block.children.length - 1];\n  if (!lastChild)\n    return block.children = [\n      {\n        _type: \"span\",\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: \"\",\n        marks: []\n      }\n    ], block;\n  const usedMarkDefs = [], allowedDecorators = options.allowedDecorators && Array.isArray(options.allowedDecorators) ? options.allowedDecorators : !1;\n  return block.children = block.children.reduce(\n    (acc, child) => {\n      const previousChild = acc[acc.length - 1];\n      return previousChild && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(previousChild) && lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_1__(previousChild.marks, child.marks) ? (lastChild && lastChild === child && child.text === \"\" && block.children.length > 1 || (previousChild.text += child.text), acc) : (acc.push(child), acc);\n    },\n    []\n  ).map((child) => {\n    if (!child)\n      throw new Error(\"missing child\");\n    return child._key = options.keyGenerator ? options.keyGenerator() : keyGenerator(), (0,_sanity_types__WEBPACK_IMPORTED_MODULE_3__.isPortableTextSpan)(child) && (child.marks ? allowedDecorators && (child.marks = child.marks.filter((mark) => {\n      const isAllowed = allowedDecorators.includes(mark), isUsed = block.markDefs?.some((def) => def._key === mark);\n      return isAllowed || isUsed;\n    })) : child.marks = [], usedMarkDefs.push(...child.marks)), child;\n  }), block.markDefs = (block.markDefs || []).filter(\n    (markDef) => usedMarkDefs.includes(markDef._key)\n  ), block;\n}\nfunction htmlToBlocks(html, blockContentType, options = {}) {\n  return new HtmlDeserializer(blockContentType, options).deserialize(html).map((block) => normalizeBlock(block, { keyGenerator: options.keyGenerator }));\n}\nfunction getBlockContentFeatures(blockContentType) {\n  return blockContentFeatures(blockContentType);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bwb3J0YWJsZXRleHQrYmxvY2stdG9vbHNAMV84NWVhNDVlYzdiMTc1MGM5ZWU5MzA4NTk5ZWEyZjIxMC9ub2RlX21vZHVsZXMvQHBvcnRhYmxldGV4dC9ibG9jay10b29scy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQzJLO0FBQzNLO0FBQ047QUFDa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpS0FBaUssUUFBUTtBQUNuTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQyxFQUFFLGdCQUFnQixZQUFZLHNCQUFzQixFQUFFLEVBQUUsR0FBRztBQUN2RztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQjtBQUNoQixDQUFDO0FBQ0QsVUFBVTtBQUNWLENBQUM7QUFDRCxRQUFRLGNBQWM7QUFDdEIsUUFBUTtBQUNSLENBQUM7QUFDRCxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRLCtCQUErQjtBQUN2QyxRQUFRO0FBQ1IsQ0FBQztBQUNELFFBQVE7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQSwyQ0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0VBQWlCO0FBQ3hCO0FBQ0EsdUNBQXVDLHFFQUEwQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpRUFBa0I7QUFDcEU7QUFDQSwwREFBMEQsaUVBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrRUFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlDQUFpQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRUFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0VBQWlCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNFQUF1QjtBQUNsRSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUF1QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwwbkJBQTBuQiw4Q0FBTyx5SUFBeUksOENBQU8sd0ZBQXdGLGVBQWU7QUFDeDNCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzRUFBdUIscUJBQXFCLHNFQUF1QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpRUFBZTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZLCtDQUErQztBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3REFBd0QsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1R0FBdUcsZ0NBQWdDO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpRUFBa0IsV0FBVyxpRUFBa0IsbUJBQW1CLDhDQUFPO0FBQ3ZHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixpRUFBa0I7QUFDMUc7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELGtIQUFrSCxvQ0FBb0M7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFNRTtBQUNGIiwic291cmNlcyI6WyJEOlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHBvcnRhYmxldGV4dCtibG9jay10b29sc0AxXzg1ZWE0NWVjN2IxNzUwYzllZTkzMDg1OTllYTJmMjEwXFxub2RlX21vZHVsZXNcXEBwb3J0YWJsZXRleHRcXGJsb2NrLXRvb2xzXFxsaWJcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IHsgaXNCbG9ja1NjaGVtYVR5cGUsIGlzQmxvY2tDaGlsZHJlbk9iamVjdEZpZWxkLCBpc09iamVjdFNjaGVtYVR5cGUsIGlzQmxvY2tMaXN0T2JqZWN0RmllbGQsIGlzQmxvY2tTdHlsZU9iamVjdEZpZWxkLCBpc1RpdGxlZExpc3RWYWx1ZSwgaXNQb3J0YWJsZVRleHRUZXh0QmxvY2ssIGlzUG9ydGFibGVUZXh0U3BhbiB9IGZyb20gXCJAc2FuaXR5L3R5cGVzXCI7XG5pbXBvcnQgaXNFcXVhbCBmcm9tIFwibG9kYXNoL2lzRXF1YWwuanNcIjtcbmltcG9ydCB1bmlxIGZyb20gXCJsb2Rhc2gvdW5pcS5qc1wiO1xuaW1wb3J0IGdldFJhbmRvbVZhbHVlcyBmcm9tIFwiZ2V0LXJhbmRvbS12YWx1ZXMtZXNtXCI7XG5mdW5jdGlvbiBmaW5kQmxvY2tUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUudHlwZSA/IGZpbmRCbG9ja1R5cGUodHlwZS50eXBlKSA6IHR5cGUubmFtZSA9PT0gXCJibG9ja1wiO1xufVxuY29uc3Qgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gcmVzb2x2ZUpzVHlwZSh2YWwpIHtcbiAgc3dpdGNoIChvYmplY3RUb1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlIFwiW29iamVjdCBGdW5jdGlvbl1cIjpcbiAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgY2FzZSBcIltvYmplY3QgRGF0ZV1cIjpcbiAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICBjYXNlIFwiW29iamVjdCBSZWdFeHBdXCI6XG4gICAgICByZXR1cm4gXCJyZWdleHBcIjtcbiAgICBjYXNlIFwiW29iamVjdCBBcmd1bWVudHNdXCI6XG4gICAgICByZXR1cm4gXCJhcmd1bWVudHNcIjtcbiAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgY2FzZSBcIltvYmplY3QgU3RyaW5nXVwiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdmFsID09PSB2b2lkIDAgPyBcInVuZGVmaW5lZFwiIDogdmFsICYmIHR5cGVvZiB2YWwgPT0gXCJvYmplY3RcIiAmJiBcIm5vZGVUeXBlXCIgaW4gdmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSA/IFwiZWxlbWVudFwiIDogdmFsID09PSBPYmplY3QodmFsKSA/IFwib2JqZWN0XCIgOiB0eXBlb2YgdmFsO1xufVxudmFyIHMgPSB7IDA6IDgyMDMsIDE6IDgyMDQsIDI6IDgyMDUsIDM6IDgyOTAsIDQ6IDgyOTEsIDU6IDgyODgsIDY6IDY1Mjc5LCA3OiA4Mjg5LCA4OiAxMTkxNTUsIDk6IDExOTE1NiwgYTogMTE5MTU3LCBiOiAxMTkxNTgsIGM6IDExOTE1OSwgZDogMTE5MTYwLCBlOiAxMTkxNjEsIGY6IDExOTE2MiB9LCBjID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA2NTI3OSB9O1xubmV3IEFycmF5KDQpLmZpbGwoU3RyaW5nLmZyb21Db2RlUG9pbnQoY1swXSkpLmpvaW4oXCJcIik7XG5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYykubWFwKCh0KSA9PiB0LnJldmVyc2UoKSkpO1xuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbnZhciBTID0gYCR7T2JqZWN0LnZhbHVlcyhzKS5tYXAoKHQpID0+IGBcXFxcdXske3QudG9TdHJpbmcoMTYpfX1gKS5qb2luKFwiXCIpfWAsIGYgPSBuZXcgUmVnRXhwKGBbJHtTfV17NCx9YCwgXCJndVwiKTtcbmZ1bmN0aW9uIF8odCkge1xuICB2YXIgZTtcbiAgcmV0dXJuIHsgY2xlYW5lZDogdC5yZXBsYWNlKGYsIFwiXCIpLCBlbmNvZGVkOiAoKGUgPSB0Lm1hdGNoKGYpKSA9PSBudWxsID8gdm9pZCAwIDogZVswXSkgfHwgXCJcIiB9O1xufVxuZnVuY3Rpb24gTyh0KSB7XG4gIHJldHVybiB0ICYmIEpTT04ucGFyc2UoXyhKU09OLnN0cmluZ2lmeSh0KSkuY2xlYW5lZCk7XG59XG5jb25zdCBQUkVTRVJWRV9XSElURVNQQUNFX1RBR1MgPSBbXCJwcmVcIiwgXCJ0ZXh0YXJlYVwiLCBcImNvZGVcIl0sIEJMT0NLX0RFRkFVTFRfU1RZTEUgPSBcIm5vcm1hbFwiLCBERUZBVUxUX0JMT0NLID0gT2JqZWN0LmZyZWV6ZSh7XG4gIF90eXBlOiBcImJsb2NrXCIsXG4gIG1hcmtEZWZzOiBbXSxcbiAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEVcbn0pLCBERUZBVUxUX1NQQU4gPSBPYmplY3QuZnJlZXplKHtcbiAgX3R5cGU6IFwic3BhblwiLFxuICBtYXJrczogW11cbn0pLCBIVE1MX0JMT0NLX1RBR1MgPSB7XG4gIHA6IERFRkFVTFRfQkxPQ0ssXG4gIGJsb2NrcXVvdGU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiYmxvY2txdW90ZVwiIH1cbn0sIEhUTUxfU1BBTl9UQUdTID0ge1xuICBzcGFuOiB7IG9iamVjdDogXCJ0ZXh0XCIgfVxufSwgSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTID0ge1xuICBvbDogeyBvYmplY3Q6IG51bGwgfSxcbiAgdWw6IHsgb2JqZWN0OiBudWxsIH1cbn0sIEhUTUxfSEVBREVSX1RBR1MgPSB7XG4gIGgxOiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImgxXCIgfSxcbiAgaDI6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDJcIiB9LFxuICBoMzogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoM1wiIH0sXG4gIGg0OiB7IC4uLkRFRkFVTFRfQkxPQ0ssIHN0eWxlOiBcImg0XCIgfSxcbiAgaDU6IHsgLi4uREVGQVVMVF9CTE9DSywgc3R5bGU6IFwiaDVcIiB9LFxuICBoNjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogXCJoNlwiIH1cbn0sIEhUTUxfTUlTQ19UQUdTID0ge1xuICBicjogeyAuLi5ERUZBVUxUX0JMT0NLLCBzdHlsZTogQkxPQ0tfREVGQVVMVF9TVFlMRSB9XG59LCBIVE1MX0RFQ09SQVRPUl9UQUdTID0ge1xuICBiOiBcInN0cm9uZ1wiLFxuICBzdHJvbmc6IFwic3Ryb25nXCIsXG4gIGk6IFwiZW1cIixcbiAgZW06IFwiZW1cIixcbiAgdTogXCJ1bmRlcmxpbmVcIixcbiAgczogXCJzdHJpa2UtdGhyb3VnaFwiLFxuICBzdHJpa2U6IFwic3RyaWtlLXRocm91Z2hcIixcbiAgZGVsOiBcInN0cmlrZS10aHJvdWdoXCIsXG4gIGNvZGU6IFwiY29kZVwiLFxuICBzdXA6IFwic3VwXCIsXG4gIHN1YjogXCJzdWJcIixcbiAgaW5zOiBcImluc1wiLFxuICBtYXJrOiBcIm1hcmtcIixcbiAgc21hbGw6IFwic21hbGxcIlxufSwgSFRNTF9MSVNUX0lURU1fVEFHUyA9IHtcbiAgbGk6IHtcbiAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgIHN0eWxlOiBCTE9DS19ERUZBVUxUX1NUWUxFLFxuICAgIGxldmVsOiAxLFxuICAgIGxpc3RJdGVtOiBcImJ1bGxldFwiXG4gIH1cbn0sIEVMRU1FTlRfTUFQID0ge1xuICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gIC4uLkhUTUxfU1BBTl9UQUdTLFxuICAuLi5IVE1MX0xJU1RfQ09OVEFJTkVSX1RBR1MsXG4gIC4uLkhUTUxfTElTVF9JVEVNX1RBR1MsXG4gIC4uLkhUTUxfSEVBREVSX1RBR1MsXG4gIC4uLkhUTUxfTUlTQ19UQUdTXG59O1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhFTEVNRU5UX01BUCkuZmlsdGVyKCh0YWcpID0+IFwic3R5bGVcIiBpbiB0YWcpLm1hcCgodGFnKSA9PiB0YWcuc3R5bGUpXG4pO1xudW5pcShcbiAgT2JqZWN0LnZhbHVlcyhIVE1MX0RFQ09SQVRPUl9UQUdTKVxuKTtcbmZ1bmN0aW9uIGJsb2NrQ29udGVudEZlYXR1cmVzKGJsb2NrQ29udGVudFR5cGUpIHtcbiAgaWYgKCFibG9ja0NvbnRlbnRUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAnYmxvY2tDb250ZW50VHlwZScgcmVxdWlyZWRcIik7XG4gIGNvbnN0IGJsb2NrVHlwZSA9IGJsb2NrQ29udGVudFR5cGUub2YuZmluZChmaW5kQmxvY2tUeXBlKTtcbiAgaWYgKCFpc0Jsb2NrU2NoZW1hVHlwZShibG9ja1R5cGUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIidibG9jaycgdHlwZSBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHNjaGVtYSAocmVxdWlyZWQpLlwiKTtcbiAgY29uc3Qgb2ZUeXBlID0gYmxvY2tUeXBlLmZpZWxkcy5maW5kKGlzQmxvY2tDaGlsZHJlbk9iamVjdEZpZWxkKT8udHlwZT8ub2Y7XG4gIGlmICghb2ZUeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGBvZmAgZGVjbGFyYXRpb24gZm91bmQgZm9yIGJsb2NrcyBgY2hpbGRyZW5gIGZpZWxkXCIpO1xuICBjb25zdCBzcGFuVHlwZSA9IG9mVHlwZS5maW5kKFxuICAgIChtZW1iZXIpID0+IG1lbWJlci5uYW1lID09PSBcInNwYW5cIlxuICApO1xuICBpZiAoIXNwYW5UeXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTm8gYHNwYW5gIHR5cGUgZm91bmQgaW4gYGJsb2NrYCBzY2hlbWEgdHlwZSBgY2hpbGRyZW5gIGRlZmluaXRpb25cIlxuICAgICk7XG4gIGNvbnN0IGlubGluZU9iamVjdFR5cGVzID0gb2ZUeXBlLmZpbHRlcihcbiAgICAoaW5saW5lVHlwZSkgPT4gaW5saW5lVHlwZS5uYW1lICE9PSBcInNwYW5cIiAmJiBpc09iamVjdFNjaGVtYVR5cGUoaW5saW5lVHlwZSlcbiAgKSwgYmxvY2tPYmplY3RUeXBlcyA9IGJsb2NrQ29udGVudFR5cGUub2YuZmlsdGVyKFxuICAgIChtZW1iZXJUeXBlKSA9PiBtZW1iZXJUeXBlLm5hbWUgIT09IGJsb2NrVHlwZS5uYW1lICYmIGlzT2JqZWN0U2NoZW1hVHlwZShtZW1iZXJUeXBlKVxuICApO1xuICByZXR1cm4ge1xuICAgIHN0eWxlczogcmVzb2x2ZUVuYWJsZWRTdHlsZXMoYmxvY2tUeXBlKSxcbiAgICBkZWNvcmF0b3JzOiByZXNvbHZlRW5hYmxlZERlY29yYXRvcnMoc3BhblR5cGUpLFxuICAgIGFubm90YXRpb25zOiByZXNvbHZlRW5hYmxlZEFubm90YXRpb25UeXBlcyhzcGFuVHlwZSksXG4gICAgbGlzdHM6IHJlc29sdmVFbmFibGVkTGlzdEl0ZW1zKGJsb2NrVHlwZSksXG4gICAgdHlwZXM6IHtcbiAgICAgIGJsb2NrOiBibG9ja0NvbnRlbnRUeXBlLFxuICAgICAgc3Bhbjogc3BhblR5cGUsXG4gICAgICBpbmxpbmVPYmplY3RzOiBpbmxpbmVPYmplY3RUeXBlcyxcbiAgICAgIGJsb2NrT2JqZWN0czogYmxvY2tPYmplY3RUeXBlc1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVFbmFibGVkU3R5bGVzKGJsb2NrVHlwZSkge1xuICBjb25zdCBzdHlsZUZpZWxkID0gYmxvY2tUeXBlLmZpZWxkcy5maW5kKGlzQmxvY2tTdHlsZU9iamVjdEZpZWxkKTtcbiAgaWYgKCFzdHlsZUZpZWxkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQSBmaWVsZCB3aXRoIG5hbWUgJ3N0eWxlJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgYmxvY2sgdHlwZSAocmVxdWlyZWQpLlwiXG4gICAgKTtcbiAgY29uc3QgdGV4dFN0eWxlcyA9IGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKFxuICAgIHN0eWxlRmllbGQudHlwZS5vcHRpb25zXG4gICk7XG4gIGlmICh0ZXh0U3R5bGVzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBzdHlsZSBmaWVsZHMgbmVlZCBhdCBsZWFzdCBvbmUgc3R5bGUgZGVmaW5lZC4gSS5lOiB7dGl0bGU6ICdOb3JtYWwnLCB2YWx1ZTogJ25vcm1hbCd9LlwiXG4gICAgKTtcbiAgcmV0dXJuIHRleHRTdHlsZXM7XG59XG5mdW5jdGlvbiByZXNvbHZlRW5hYmxlZEFubm90YXRpb25UeXBlcyhzcGFuVHlwZSkge1xuICByZXR1cm4gc3BhblR5cGUuYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiAoe1xuICAgIHRpdGxlOiBhbm5vdGF0aW9uLnRpdGxlLFxuICAgIHR5cGU6IGFubm90YXRpb24sXG4gICAgdmFsdWU6IGFubm90YXRpb24ubmFtZSxcbiAgICBpY29uOiBhbm5vdGF0aW9uLmljb25cbiAgfSkpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWREZWNvcmF0b3JzKHNwYW5UeXBlKSB7XG4gIHJldHVybiBzcGFuVHlwZS5kZWNvcmF0b3JzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuYWJsZWRMaXN0SXRlbXMoYmxvY2tUeXBlKSB7XG4gIGNvbnN0IGxpc3RGaWVsZCA9IGJsb2NrVHlwZS5maWVsZHMuZmluZChpc0Jsb2NrTGlzdE9iamVjdEZpZWxkKTtcbiAgaWYgKCFsaXN0RmllbGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJBIGZpZWxkIHdpdGggbmFtZSAnbGlzdCcgaXMgbm90IGRlZmluZWQgaW4gdGhlIGJsb2NrIHR5cGUgKHJlcXVpcmVkKS5cIlxuICAgICk7XG4gIGNvbnN0IGxpc3RJdGVtcyA9IGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKFxuICAgIGxpc3RGaWVsZC50eXBlLm9wdGlvbnNcbiAgKTtcbiAgaWYgKCFsaXN0SXRlbXMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxpc3QgZmllbGQgbmVlZCBhdCBsZWFzdCB0byBiZSBhbiBlbXB0eSBhcnJheVwiKTtcbiAgcmV0dXJuIGxpc3RJdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRpdGxlZExpc3RWYWx1ZXNGcm9tRW51bUxpc3RPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgbGlzdCA9IG9wdGlvbnMgPyBvcHRpb25zLmxpc3QgOiB2b2lkIDA7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdC5tYXAoXG4gICAgKGl0ZW0pID0+IGlzVGl0bGVkTGlzdFZhbHVlKGl0ZW0pID8gaXRlbSA6IHsgdGl0bGU6IGl0ZW0sIHZhbHVlOiBpdGVtIH1cbiAgKSA6IFtdO1xufVxuY29uc3QgX1hQYXRoUmVzdWx0ID0ge1xuICBCT09MRUFOX1RZUEU6IDMsXG4gIE9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFOiA1LFxuICBVTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFOiA2XG59O1xudmFyIHByZXByb2Nlc3NHRG9jcyA9IChfaHRtbCwgZG9jLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHdoaXRlc3BhY2VPblBhc3RlTW9kZSA9IG9wdGlvbnM/LnVuc3RhYmxlX3doaXRlc3BhY2VPblBhc3RlTW9kZSB8fCBcInByZXNlcnZlXCI7XG4gIGxldCBnRG9jc1Jvb3RPclNpYmxpbmdOb2RlID0gZG9jLmV2YWx1YXRlKFxuICAgICcvLypbQGlkIGFuZCBjb250YWlucyhAaWQsIFwiZG9jcy1pbnRlcm5hbC1ndWlkXCIpXScsXG4gICAgZG9jLFxuICAgIG51bGwsXG4gICAgX1hQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFLFxuICAgIG51bGxcbiAgKS5pdGVyYXRlTmV4dCgpO1xuICBpZiAoZ0RvY3NSb290T3JTaWJsaW5nTm9kZSkge1xuICAgIGNvbnN0IGlzV3JhcHBlZFJvb3RUYWcgPSB0YWdOYW1lKGdEb2NzUm9vdE9yU2libGluZ05vZGUpID09PSBcImJcIjtcbiAgICBzd2l0Y2ggKGlzV3JhcHBlZFJvb3RUYWcgfHwgKGdEb2NzUm9vdE9yU2libGluZ05vZGUgPSBkb2MuYm9keSksIHdoaXRlc3BhY2VPblBhc3RlTW9kZSkge1xuICAgICAgY2FzZSBcIm5vcm1hbGl6ZVwiOlxuICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlKGdEb2NzUm9vdE9yU2libGluZ05vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgcmVtb3ZlQWxsV2hpdGVzcGFjZShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgICBcIi8vKlwiLFxuICAgICAgZG9jLFxuICAgICAgbnVsbCxcbiAgICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgICAgbnVsbFxuICAgICk7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkTm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgZWxtID0gY2hpbGROb2Rlcy5zbmFwc2hvdEl0ZW0oaSk7XG4gICAgICBlbG0/LnNldEF0dHJpYnV0ZShcImRhdGEtaXMtZ29vZ2xlLWRvY3NcIiwgXCJ0cnVlXCIpLCAoZWxtPy5wYXJlbnRFbGVtZW50ID09PSBnRG9jc1Jvb3RPclNpYmxpbmdOb2RlIHx8ICFpc1dyYXBwZWRSb290VGFnICYmIGVsbS5wYXJlbnRFbGVtZW50ID09PSBkb2MuYm9keSkgJiYgKGVsbT8uc2V0QXR0cmlidXRlKFwiZGF0YS1pcy1yb290LW5vZGVcIiwgXCJ0cnVlXCIpLCB0YWdOYW1lKGVsbSkpLCB0YWdOYW1lKGVsbSkgPT09IFwibGlcIiAmJiBlbG0uZmlyc3RDaGlsZCAmJiB0YWdOYW1lKGVsbT8uZmlyc3RDaGlsZCkgPT09IFwiaW1nXCIgJiYgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV3JhcHBlZFJvb3RUYWcgJiYgZG9jLmJvZHkuZmlyc3RFbGVtZW50Q2hpbGQ/LnJlcGxhY2VXaXRoKFxuICAgICAgLi4uQXJyYXkuZnJvbShnRG9jc1Jvb3RPclNpYmxpbmdOb2RlLmNoaWxkTm9kZXMpXG4gICAgKSwgZG9jO1xuICB9XG4gIHJldHVybiBkb2M7XG59O1xuY29uc3QgdW53YW50ZWRXb3JkRG9jdW1lbnRQYXRocyA9IFtcbiAgXCIvaHRtbC90ZXh0KClcIixcbiAgXCIvaHRtbC9oZWFkL3RleHQoKVwiLFxuICBcIi9odG1sL2JvZHkvdGV4dCgpXCIsXG4gIFwiL2h0bWwvYm9keS91bC90ZXh0KClcIixcbiAgXCIvaHRtbC9ib2R5L29sL3RleHQoKVwiLFxuICBcIi8vY29tbWVudCgpXCIsXG4gIFwiLy9zdHlsZVwiLFxuICBcIi8veG1sXCIsXG4gIFwiLy9zY3JpcHRcIixcbiAgXCIvL21ldGFcIixcbiAgXCIvL2xpbmtcIlxuXTtcbnZhciBwcmVwcm9jZXNzSFRNTCA9IChfaHRtbCwgZG9jKSA9PiB7XG4gIGNvbnN0IGJvZHlUZXh0Tm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgXCIvaHRtbC9ib2R5L3RleHQoKVwiLFxuICAgIGRvYyxcbiAgICBudWxsLFxuICAgIF9YUGF0aFJlc3VsdC5VTk9SREVSRURfTk9ERV9TTkFQU0hPVF9UWVBFLFxuICAgIG51bGxcbiAgKTtcbiAgZm9yIChsZXQgaSA9IGJvZHlUZXh0Tm9kZXMuc25hcHNob3RMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG5vZGUgPSBib2R5VGV4dE5vZGVzLnNuYXBzaG90SXRlbShpKSwgdGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgXCJcIjtcbiAgICBpZiAodGV4dC5yZXBsYWNlKC9bXlxcU1xcbl0rJC9nLCBcIlwiKSkge1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG5ld05vZGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKSwgbm9kZS5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgbm9kZSk7XG4gICAgfSBlbHNlXG4gICAgICBub2RlLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICB9XG4gIGNvbnN0IHVud2FudGVkTm9kZXMgPSBkb2MuZXZhbHVhdGUoXG4gICAgdW53YW50ZWRXb3JkRG9jdW1lbnRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCB1bndhbnRlZCA9IHVud2FudGVkTm9kZXMuc25hcHNob3RJdGVtKGkpO1xuICAgIHVud2FudGVkICYmIHVud2FudGVkLnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKHVud2FudGVkKTtcbiAgfVxuICByZXR1cm4gZG9jO1xufSwgcHJlcHJvY2Vzc05vdGlvbiA9IChodG1sLCBkb2MpID0+IHtcbiAgY29uc3QgTk9USU9OX1JFR0VYID0gLzwhLS0gbm90aW9udmM6Lio/LS0+L2c7XG4gIGlmIChodG1sLm1hdGNoKE5PVElPTl9SRUdFWCkpIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9jLmV2YWx1YXRlKFxuICAgICAgXCIvLypcIixcbiAgICAgIGRvYyxcbiAgICAgIG51bGwsXG4gICAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGZvciAobGV0IGkgPSBjaGlsZE5vZGVzLnNuYXBzaG90TGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBjaGlsZE5vZGVzLnNuYXBzaG90SXRlbShpKT8uc2V0QXR0cmlidXRlKFwiZGF0YS1pcy1ub3Rpb25cIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgcmV0dXJuIGRvYztcbn0sIHByZXByb2Nlc3NXaGl0ZXNwYWNlID0gKF8yLCBkb2MpID0+IHtcbiAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBfWFBhdGhSZXN1bHQuQk9PTEVBTl9UWVBFICYmICFQUkVTRVJWRV9XSElURVNQQUNFX1RBR1MuaW5jbHVkZXMoXG4gICAgICBub2RlLnBhcmVudEVsZW1lbnQ/LnRhZ05hbWUudG9Mb3dlckNhc2UoKSB8fCBcIlwiXG4gICAgKSlcbiAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50Py5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKS5yZXBsYWNlKC9bXFxyXFxuXSsvZywgXCIgXCIpIHx8IFwiXCI7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHByb2Nlc3NOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NOb2RlKGRvYy5ib2R5KSwgZG9jO1xufTtcbmNvbnN0IFdPUkRfSFRNTF9SRUdFWCA9IC8oY2xhc3M9XCI/TXNvfHN0eWxlPSg/OlwifCcpW15cIl0qP1xcYm1zby18dzpXb3JkRG9jdW1lbnR8PG86XFx3Kz58PFxcL2ZvbnQ+KS8sIHVud2FudGVkUGF0aHMgPSBbXG4gIFwiLy9vOnBcIixcbiAgXCIvL3NwYW5bQHN0eWxlPSdtc28tbGlzdDpJZ25vcmUnXVwiLFxuICBcIi8vc3BhbltAc3R5bGU9J21zby1saXN0OiBJZ25vcmUnXVwiXG5dLCBtYXBwZWRQYXRocyA9IFtcbiAgXCIvL3BbQGNsYXNzPSdNc29Ub2NIZWFkaW5nJ11cIixcbiAgXCIvL3BbQGNsYXNzPSdNc29UaXRsZSddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvVG9hSGVhZGluZyddXCIsXG4gIFwiLy9wW0BjbGFzcz0nTXNvU3VidGl0bGUnXVwiLFxuICBcIi8vc3BhbltAY2xhc3M9J01zb1N1YnRsZUVtcGhhc2lzJ11cIixcbiAgXCIvL3NwYW5bQGNsYXNzPSdNc29JbnRlbnNlRW1waGFzaXMnXVwiXG5dLCBlbGVtZW50TWFwID0ge1xuICBNc29Ub2NIZWFkaW5nOiBbXCJoM1wiXSxcbiAgTXNvVGl0bGU6IFtcImgxXCJdLFxuICBNc29Ub2FIZWFkaW5nOiBbXCJoMlwiXSxcbiAgTXNvU3VidGl0bGU6IFtcImg1XCJdLFxuICBNc29TdWJ0bGVFbXBoYXNpczogW1wic3BhblwiLCBcImVtXCJdLFxuICBNc29JbnRlbnNlRW1waGFzaXM6IFtcInNwYW5cIiwgXCJlbVwiLCBcInN0cm9uZ1wiXVxuICAvLyBSZW1vdmUgY3J1ZnRcbn07XG5mdW5jdGlvbiBpc1dvcmRIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIFdPUkRfSFRNTF9SRUdFWC50ZXN0KGh0bWwpO1xufVxudmFyIHByZXByb2Nlc3NXb3JkID0gKGh0bWwsIGRvYykgPT4ge1xuICBpZiAoIWlzV29yZEh0bWwoaHRtbCkpXG4gICAgcmV0dXJuIGRvYztcbiAgY29uc3QgdW53YW50ZWROb2RlcyA9IGRvYy5ldmFsdWF0ZShcbiAgICB1bndhbnRlZFBhdGhzLmpvaW4oXCJ8XCIpLFxuICAgIGRvYyxcbiAgICAocHJlZml4KSA9PiBwcmVmaXggPT09IFwib1wiID8gXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOm9mZmljZTpvZmZpY2VcIiA6IG51bGwsXG4gICAgX1hQYXRoUmVzdWx0LlVOT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEUsXG4gICAgbnVsbFxuICApO1xuICBmb3IgKGxldCBpID0gdW53YW50ZWROb2Rlcy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdW53YW50ZWQgPSB1bndhbnRlZE5vZGVzLnNuYXBzaG90SXRlbShpKTtcbiAgICB1bndhbnRlZD8ucGFyZW50Tm9kZSAmJiB1bndhbnRlZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVud2FudGVkKTtcbiAgfVxuICBjb25zdCBtYXBwZWRFbGVtZW50cyA9IGRvYy5ldmFsdWF0ZShcbiAgICBtYXBwZWRQYXRocy5qb2luKFwifFwiKSxcbiAgICBkb2MsXG4gICAgbnVsbCxcbiAgICBfWFBhdGhSZXN1bHQuVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRSxcbiAgICBudWxsXG4gICk7XG4gIGZvciAobGV0IGkgPSBtYXBwZWRFbGVtZW50cy5zbmFwc2hvdExlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbWFwcGVkRWxtID0gbWFwcGVkRWxlbWVudHMuc25hcHNob3RJdGVtKGkpLCB0YWdzID0gZWxlbWVudE1hcFttYXBwZWRFbG0uY2xhc3NOYW1lXSwgdGV4dCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShtYXBwZWRFbG0udGV4dENvbnRlbnQgfHwgXCJcIik7XG4gICAgaWYgKCF0YWdzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZ3NbMF0pO1xuICAgIGxldCBwYXJlbnQgPSBwYXJlbnRFbGVtZW50LCBjaGlsZCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgdGFncy5zbGljZSgxKS5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGNoaWxkID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKSwgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKSwgcGFyZW50ID0gY2hpbGQ7XG4gICAgfSksIGNoaWxkLmFwcGVuZENoaWxkKHRleHQpLCBtYXBwZWRFbG0/LnBhcmVudE5vZGU/LnJlcGxhY2VDaGlsZChwYXJlbnRFbGVtZW50LCBtYXBwZWRFbG0pO1xuICB9XG4gIHJldHVybiBkb2M7XG59LCBwcmVwcm9jZXNzb3JzID0gW1xuICBwcmVwcm9jZXNzV2hpdGVzcGFjZSxcbiAgcHJlcHJvY2Vzc05vdGlvbixcbiAgcHJlcHJvY2Vzc1dvcmQsXG4gIHByZXByb2Nlc3NHRG9jcyxcbiAgcHJlcHJvY2Vzc0hUTUxcbl07XG5mdW5jdGlvbiBjcmVhdGVSdWxlT3B0aW9ucyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IGZlYXR1cmVzID0gYmxvY2tDb250ZW50RmVhdHVyZXMoYmxvY2tDb250ZW50VHlwZSksIGVuYWJsZWRCbG9ja1N0eWxlcyA9IGZlYXR1cmVzLnN0eWxlcy5tYXAoXG4gICAgKGl0ZW0pID0+IGl0ZW0udmFsdWUgfHwgaXRlbS50aXRsZVxuICApLCBlbmFibGVkU3BhbkRlY29yYXRvcnMgPSBmZWF0dXJlcy5kZWNvcmF0b3JzLm1hcChcbiAgICAoaXRlbSkgPT4gaXRlbS52YWx1ZSB8fCBpdGVtLnRpdGxlXG4gICksIGVuYWJsZWRCbG9ja0Fubm90YXRpb25zID0gZmVhdHVyZXMuYW5ub3RhdGlvbnMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGUgfHwgXCJcIlxuICApLCBlbmFibGVkTGlzdFR5cGVzID0gZmVhdHVyZXMubGlzdHMubWFwKFxuICAgIChpdGVtKSA9PiBpdGVtLnZhbHVlIHx8IGl0ZW0udGl0bGUgfHwgXCJcIlxuICApO1xuICByZXR1cm4ge1xuICAgIGVuYWJsZWRCbG9ja1N0eWxlcyxcbiAgICBlbmFibGVkU3BhbkRlY29yYXRvcnMsXG4gICAgZW5hYmxlZEJsb2NrQW5ub3RhdGlvbnMsXG4gICAgZW5hYmxlZExpc3RUeXBlc1xuICB9O1xufVxuZnVuY3Rpb24gdGFnTmFtZShlbCkge1xuICBpZiAoZWwgJiYgXCJ0YWdOYW1lXCIgaW4gZWwpXG4gICAgcmV0dXJuIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHByZXByb2Nlc3MoaHRtbCwgcGFyc2VIdG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNsZWFuSFRNTCA9IE8oaHRtbCksIGRvYyA9IHBhcnNlSHRtbChub3JtYWxpemVIdG1sQmVmb3JlUHJlcHJvY2VzcyhjbGVhbkhUTUwpKTtcbiAgcmV0dXJuIHByZXByb2Nlc3NvcnMuZm9yRWFjaCgocHJvY2Vzc29yKSA9PiB7XG4gICAgcHJvY2Vzc29yKGNsZWFuSFRNTCwgZG9jLCBvcHRpb25zKTtcbiAgfSksIGRvYztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUh0bWxCZWZvcmVQcmVwcm9jZXNzKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwudHJpbSgpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFBhcnNlSHRtbCgpIHtcbiAgaWYgKHJlc29sdmVKc1R5cGUoRE9NUGFyc2VyKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIlRoZSBuYXRpdmUgYERPTVBhcnNlcmAgZ2xvYmFsIHdoaWNoIHRoZSBgSHRtbGAgZGVzZXJpYWxpemVyIHVzZXMgYnkgZGVmYXVsdCBpcyBub3QgcHJlc2VudCBpbiB0aGlzIGVudmlyb25tZW50LiBZb3UgbXVzdCBzdXBwbHkgdGhlIGBvcHRpb25zLnBhcnNlSHRtbGAgZnVuY3Rpb24gaW5zdGVhZC5cIlxuICAgICk7XG4gIHJldHVybiAoaHRtbCkgPT4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhodG1sLCBcInRleHQvaHRtbFwiKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5OZXN0ZWRCbG9ja3MoYmxvY2tzMikge1xuICBsZXQgZGVwdGggPSAwO1xuICBjb25zdCBmbGF0dGVuZWQgPSBbXSwgdHJhdmVyc2UgPSAobm9kZXMpID0+IHtcbiAgICBjb25zdCB0b1JlbW92ZSA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGRlcHRoID09PSAwICYmIGZsYXR0ZW5lZC5wdXNoKG5vZGUpLCBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhub2RlKSAmJiAoZGVwdGggPiAwICYmICh0b1JlbW92ZS5wdXNoKG5vZGUpLCBmbGF0dGVuZWQucHVzaChub2RlKSksIGRlcHRoKyssIHRyYXZlcnNlKG5vZGUuY2hpbGRyZW4pKSwgbm9kZS5fdHlwZSA9PT0gXCJfX2Jsb2NrXCIgJiYgKHRvUmVtb3ZlLnB1c2gobm9kZSksIGZsYXR0ZW5lZC5wdXNoKG5vZGUuYmxvY2spKTtcbiAgICB9KSwgdG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZXMuc3BsaWNlKG5vZGVzLmluZGV4T2Yobm9kZSksIDEpO1xuICAgIH0pLCBkZXB0aC0tO1xuICB9O1xuICByZXR1cm4gdHJhdmVyc2UoYmxvY2tzMiksIGZsYXR0ZW5lZDtcbn1cbmZ1bmN0aW9uIG5leHRTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBuZXh0ID0gYmxvY2suY2hpbGRyZW5baW5kZXggKyAxXTtcbiAgcmV0dXJuIG5leHQgJiYgbmV4dC5fdHlwZSA9PT0gXCJzcGFuXCIgPyBuZXh0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHByZXZTcGFuKGJsb2NrLCBpbmRleCkge1xuICBjb25zdCBwcmV2ID0gYmxvY2suY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgcmV0dXJuIHByZXYgJiYgcHJldi5fdHlwZSA9PT0gXCJzcGFuXCIgPyBwcmV2IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZUNoYXIodGV4dCkge1xuICByZXR1cm4gW1wiXFx4QTBcIiwgXCIgXCJdLmluY2x1ZGVzKHRleHQpO1xufVxuZnVuY3Rpb24gdHJpbVdoaXRlc3BhY2UoYmxvY2tzMikge1xuICByZXR1cm4gYmxvY2tzMi5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgIGlzUG9ydGFibGVUZXh0VGV4dEJsb2NrKGJsb2NrKSAmJiBibG9jay5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNNaW5pbWFsU3BhbihjaGlsZCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRTcGFuKGJsb2NrLCBpbmRleCksIHByZXZDaGlsZCA9IHByZXZTcGFuKGJsb2NrLCBpbmRleCk7XG4gICAgICBpbmRleCA9PT0gMCAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBpbmRleCA9PT0gYmxvY2suY2hpbGRyZW4ubGVuZ3RoIC0gMSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvW15cXFNcXG5dKyQvZywgXCJcIikpLCAvXFxzLy50ZXN0KGNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgY2hpbGQudGV4dC5sZW5ndGggLSAxKSkpICYmIG5leHRDaGlsZCAmJiBpc01pbmltYWxTcGFuKG5leHRDaGlsZCkgJiYgL1xccy8udGVzdChuZXh0Q2hpbGQudGV4dC5zbGljZSgwLCAxKSkgJiYgKGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1teXFxTXFxuXSskL2csIFwiXCIpKSwgL1xccy8udGVzdChjaGlsZC50ZXh0LnNsaWNlKDAsIDEpKSAmJiBwcmV2Q2hpbGQgJiYgaXNNaW5pbWFsU3BhbihwcmV2Q2hpbGQpICYmIC9cXHMvLnRlc3QocHJldkNoaWxkLnRleHQuc2xpY2UoTWF0aC5tYXgoMCwgcHJldkNoaWxkLnRleHQubGVuZ3RoIC0gMSkpKSAmJiAoY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXlteXFxTXFxuXSsvZywgXCJcIikpLCBjaGlsZC50ZXh0IHx8IGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSksIHByZXZDaGlsZCAmJiBpc0VxdWFsKHByZXZDaGlsZC5tYXJrcywgY2hpbGQubWFya3MpICYmIGlzV2hpdGVTcGFjZUNoYXIoY2hpbGQudGV4dCkgPyAocHJldkNoaWxkLnRleHQgKz0gXCIgXCIsIGJsb2NrLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpIDogbmV4dENoaWxkICYmIGlzRXF1YWwobmV4dENoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgJiYgaXNXaGl0ZVNwYWNlQ2hhcihjaGlsZC50ZXh0KSAmJiAobmV4dENoaWxkLnRleHQgPSBgICR7bmV4dENoaWxkLnRleHR9YCwgYmxvY2suY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKSk7XG4gICAgfSk7XG4gIH0pLCBibG9ja3MyO1xufVxuZnVuY3Rpb24gZW5zdXJlUm9vdElzQmxvY2tzKGJsb2NrczIpIHtcbiAgcmV0dXJuIGJsb2NrczIucmVkdWNlKChtZW1vLCBub2RlLCBpLCBvcmlnaW5hbCkgPT4ge1xuICAgIGlmIChub2RlLl90eXBlID09PSBcImJsb2NrXCIpXG4gICAgICByZXR1cm4gbWVtby5wdXNoKG5vZGUpLCBtZW1vO1xuICAgIGlmIChub2RlLl90eXBlID09PSBcIl9fYmxvY2tcIilcbiAgICAgIHJldHVybiBtZW1vLnB1c2gobm9kZS5ibG9jayksIG1lbW87XG4gICAgY29uc3QgbGFzdEJsb2NrID0gbWVtb1ttZW1vLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpID4gMCAmJiAhaXNQb3J0YWJsZVRleHRUZXh0QmxvY2sob3JpZ2luYWxbaSAtIDFdKSAmJiBpc1BvcnRhYmxlVGV4dFRleHRCbG9jayhsYXN0QmxvY2spKVxuICAgICAgcmV0dXJuIGxhc3RCbG9jay5jaGlsZHJlbi5wdXNoKG5vZGUpLCBtZW1vO1xuICAgIGNvbnN0IGJsb2NrID0ge1xuICAgICAgLi4uREVGQVVMVF9CTE9DSyxcbiAgICAgIGNoaWxkcmVuOiBbbm9kZV1cbiAgICB9O1xuICAgIHJldHVybiBtZW1vLnB1c2goYmxvY2spLCBtZW1vO1xuICB9LCBbXSk7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KG5vZGUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChub2RlKSA9PT0gXCJbb2JqZWN0IE5vZGVMaXN0XVwiO1xufVxuZnVuY3Rpb24gaXNNaW5pbWFsU3Bhbihub2RlKSB7XG4gIHJldHVybiBub2RlLl90eXBlID09PSBcInNwYW5cIjtcbn1cbmZ1bmN0aW9uIGlzTWluaW1hbEJsb2NrKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3R5cGUgPT09IFwiYmxvY2tcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2RlY29yYXRvclwiO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlckFubm90YXRpb24obm9kZSkge1xuICByZXR1cm4gbm9kZS5fdHlwZSA9PT0gXCJfX2Fubm90YXRpb25cIjtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplV2hpdGVzcGFjZShyb290Tm9kZSkge1xuICBsZXQgZW1wdHlCbG9ja0NvdW50ID0gMCwgbGFzdFBhcmVudCA9IG51bGw7XG4gIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgZm9yIChsZXQgY2hpbGQgPSByb290Tm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmICghaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZWxtID0gY2hpbGQ7XG4gICAgaXNXaGl0ZXNwYWNlQmxvY2soZWxtKSA/IChsYXN0UGFyZW50ICYmIGVsbS5wYXJlbnRFbGVtZW50ID09PSBsYXN0UGFyZW50ID8gKGVtcHR5QmxvY2tDb3VudCsrLCBlbXB0eUJsb2NrQ291bnQgPiAxICYmIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pKSA6IGVtcHR5QmxvY2tDb3VudCA9IDEsIGxhc3RQYXJlbnQgPSBlbG0ucGFyZW50RWxlbWVudCkgOiAobm9ybWFsaXplV2hpdGVzcGFjZShjaGlsZCksIGVtcHR5QmxvY2tDb3VudCA9IDApO1xuICB9XG4gIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChub2RlKSk7XG59XG5mdW5jdGlvbiByZW1vdmVBbGxXaGl0ZXNwYWNlKHJvb3ROb2RlKSB7XG4gIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgZnVuY3Rpb24gY29sbGVjdE5vZGVzVG9SZW1vdmUoY3VycmVudE5vZGUpIHtcbiAgICBpZiAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgZWxtID0gY3VycmVudE5vZGU7XG4gICAgICBpZiAodGFnTmFtZShlbG0pID09PSBcImJyXCIgJiYgKHRhZ05hbWUoZWxtLm5leHRFbGVtZW50U2libGluZykgPT09IFwicFwiIHx8IHRhZ05hbWUoZWxtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpID09PSBcInBcIikpIHtcbiAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKGVsbSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgodGFnTmFtZShlbG0pID09PSBcInBcIiB8fCB0YWdOYW1lKGVsbSkgPT09IFwiYnJcIikgJiYgZWxtPy5maXJzdENoaWxkPy50ZXh0Q29udGVudD8udHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChlbG0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBjaGlsZCA9IGVsbS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZylcbiAgICAgICAgY29sbGVjdE5vZGVzVG9SZW1vdmUoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBjb2xsZWN0Tm9kZXNUb1JlbW92ZShyb290Tm9kZSksIG5vZGVzVG9SZW1vdmUuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5wYXJlbnRFbGVtZW50Py5yZW1vdmVDaGlsZChub2RlKSk7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VCbG9jayhlbG0pIHtcbiAgcmV0dXJuIFtcInBcIiwgXCJiclwiXS5pbmNsdWRlcyh0YWdOYW1lKGVsbSkgfHwgXCJcIikgJiYgIWVsbS50ZXh0Q29udGVudD8udHJpbSgpO1xufVxuY29uc3QgTElTVF9DT05UQUlORVJfVEFHUyA9IE9iamVjdC5rZXlzKEhUTUxfTElTVF9DT05UQUlORVJfVEFHUyk7XG5mdW5jdGlvbiBpc0VtcGhhc2lzJDEoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtc3R5bGVcXHMqOlxccyppdGFsaWMvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc1N0cm9uZyQxKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgcmV0dXJuIC9mb250LXdlaWdodFxccyo6XFxzKjcwMC8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lJDEoZWwpIHtcbiAgaWYgKCFpc0VsZW1lbnQoZWwpIHx8IHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgPT09IFwiYVwiKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvblxccyo6XFxzKnVuZGVybGluZS8udGVzdChzdHlsZSB8fCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWtldGhyb3VnaChlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIHJldHVybiAvdGV4dC1kZWNvcmF0aW9uXFxzKjpcXHMqKD86LipsaW5lLXRocm91Z2guKjspLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNHb29nbGVEb2NzKGVsKSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWwpICYmICEhZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1pcy1nb29nbGUtZG9jc1wiKTtcbn1cbmZ1bmN0aW9uIGlzUm9vdE5vZGUoZWwpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbCkgJiYgISFlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlzLXJvb3Qtbm9kZVwiKTtcbn1cbmZ1bmN0aW9uIGdldExpc3RJdGVtU3R5bGUkMShlbCkge1xuICBjb25zdCBwYXJlbnRUYWcgPSB0YWdOYW1lKGVsLnBhcmVudE5vZGUpO1xuICBpZiAoIShwYXJlbnRUYWcgJiYgIUxJU1RfQ09OVEFJTkVSX1RBR1MuaW5jbHVkZXMocGFyZW50VGFnKSkpXG4gICAgcmV0dXJuIHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgPT09IFwidWxcIiA/IFwiYnVsbGV0XCIgOiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1MZXZlbCQxKGVsKSB7XG4gIGxldCBsZXZlbCA9IDA7XG4gIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJsaVwiKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICAgIGZvciAoOyBwYXJlbnROb2RlOyApIHtcbiAgICAgIGNvbnN0IHBhcmVudFRhZyA9IHRhZ05hbWUocGFyZW50Tm9kZSk7XG4gICAgICBwYXJlbnRUYWcgJiYgTElTVF9DT05UQUlORVJfVEFHUy5pbmNsdWRlcyhwYXJlbnRUYWcpICYmIGxldmVsKyssIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9IGVsc2VcbiAgICBsZXZlbCA9IDE7XG4gIHJldHVybiBsZXZlbDtcbn1cbmNvbnN0IGJsb2NrcyA9IHtcbiAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAuLi5IVE1MX0hFQURFUl9UQUdTXG59O1xuZnVuY3Rpb24gZ2V0QmxvY2tTdHlsZShlbCwgZW5hYmxlZEJsb2NrU3R5bGVzKSB7XG4gIGNvbnN0IGNoaWxkVGFnID0gdGFnTmFtZShlbC5maXJzdENoaWxkKSwgYmxvY2sgPSBjaGlsZFRhZyAmJiBibG9ja3NbY2hpbGRUYWddO1xuICByZXR1cm4gYmxvY2sgJiYgZW5hYmxlZEJsb2NrU3R5bGVzLmluY2x1ZGVzKGJsb2NrLnN0eWxlKSA/IGJsb2NrLnN0eWxlIDogQkxPQ0tfREVGQVVMVF9TVFlMRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUdEb2NzUnVsZXMoX2Jsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KGVsKSAmJiB0YWdOYW1lKGVsKSA9PT0gXCJzcGFuXCIgJiYgaXNHb29nbGVEb2NzKGVsKSkge1xuICAgICAgICAgIGNvbnN0IHNwYW4gPSB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICBtYXJrczogW10sXG4gICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGlzU3Ryb25nJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cm9uZ1wiKSwgaXNVbmRlcmxpbmUkMShlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwidW5kZXJsaW5lXCIpLCBpc1N0cmlrZXRocm91Z2goZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cmlrZS10aHJvdWdoXCIpLCBpc0VtcGhhc2lzJDEoZWwpICYmIHNwYW4ubWFya3MucHVzaChcImVtXCIpLCBzcGFuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwibGlcIiAmJiBpc0dvb2dsZURvY3MoZWwpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgICAgICAgbGlzdEl0ZW06IGdldExpc3RJdGVtU3R5bGUkMShlbCksXG4gICAgICAgICAgICBsZXZlbDogZ2V0TGlzdEl0ZW1MZXZlbCQxKGVsKSxcbiAgICAgICAgICAgIHN0eWxlOiBnZXRCbG9ja1N0eWxlKGVsLCBvcHRpb25zLmVuYWJsZWRCbG9ja1N0eWxlcyksXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5maXJzdENoaWxkPy5jaGlsZE5vZGVzIHx8IFtdKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIiAmJiBpc0dvb2dsZURvY3MoZWwpICYmIGlzRWxlbWVudChlbCkgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXBwbGUtaW50ZXJjaGFuZ2UtbmV3bGluZVwiKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogXCJcIlxuICAgICAgICAgIH07XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJiclwiICYmIGlzR29vZ2xlRG9jcyhlbCkgJiYgaXNFbGVtZW50KGVsKSAmJiBlbD8ucGFyZW50Tm9kZT8udGV4dENvbnRlbnQgPT09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIiAmJiBpc0dvb2dsZURvY3MoZWwpICYmIGlzRWxlbWVudChlbCkgJiYgaXNSb290Tm9kZShlbCkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIHRleHQ6IFwiXCJcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGtleUdlbmVyYXRvcigpIHtcbiAgcmV0dXJuIHJhbmRvbUtleSgxMik7XG59XG5mdW5jdGlvbiB3aGF0d2dSTkcobGVuZ3RoID0gMTYpIHtcbiAgY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KSwgcm5kczg7XG59XG5jb25zdCBieXRlVG9IZXggPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpXG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMjU2KS50b1N0cmluZygxNikuc2xpY2UoMSk7XG5mdW5jdGlvbiByYW5kb21LZXkobGVuZ3RoKSB7XG4gIHJldHVybiB3aGF0d2dSTkcobGVuZ3RoKS5yZWR1Y2UoKHN0ciwgbikgPT4gc3RyICsgYnl0ZVRvSGV4W25dLCBcIlwiKS5zbGljZSgwLCBsZW5ndGgpO1xufVxuY29uc3Qgd2hpdGVzcGFjZVRleHROb2RlUnVsZSA9IHtcbiAgZGVzZXJpYWxpemUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIiN0ZXh0XCIgJiYgaXNXaGl0ZXNwYWNlVGV4dE5vZGUobm9kZSkgPyB7XG4gICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICBtYXJrczogW10sXG4gICAgICB0ZXh0OiAobm9kZS50ZXh0Q29udGVudCA/PyBcIlwiKS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKVxuICAgIH0gOiB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAobm9kZS50ZXh0Q29udGVudCB8fCBcIlwiKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCBcIiBcIikucmVwbGFjZSgvXFxzXFxzKy9nLCBcIiBcIikgPT09IFwiIFwiICYmIG5vZGUubmV4dFNpYmxpbmcgJiYgbm9kZS5uZXh0U2libGluZy5ub2RlVHlwZSAhPT0gMyAmJiBub2RlLnByZXZpb3VzU2libGluZyAmJiBub2RlLnByZXZpb3VzU2libGluZy5ub2RlVHlwZSAhPT0gMyB8fCBub2RlLnRleHRDb250ZW50ICE9PSBcIiBcIikgJiYgdGFnTmFtZShub2RlLnBhcmVudE5vZGUpICE9PSBcImJvZHlcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMaXN0SXRlbShsaXN0Tm9kZVRhZ05hbWUsIGVuYWJsZWRMaXN0VHlwZXMpIHtcbiAgaWYgKGxpc3ROb2RlVGFnTmFtZSA9PT0gXCJ1bFwiICYmIGVuYWJsZWRMaXN0VHlwZXMuaW5jbHVkZXMoXCJidWxsZXRcIikpXG4gICAgcmV0dXJuIFwiYnVsbGV0XCI7XG4gIGlmIChsaXN0Tm9kZVRhZ05hbWUgPT09IFwib2xcIiAmJiBlbmFibGVkTGlzdFR5cGVzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxuICAgIHJldHVybiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gY3JlYXRlSFRNTFJ1bGVzKF9ibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBbXG4gICAgd2hpdGVzcGFjZVRleHROb2RlUnVsZSxcbiAgICB7XG4gICAgICAvLyBQcmUgZWxlbWVudFxuICAgICAgZGVzZXJpYWxpemUoZWwpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcInByZVwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaXNDb2RlRW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZEJsb2NrU3R5bGVzLmluY2x1ZGVzKFwiY29kZVwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBfdHlwZTogXCJibG9ja1wiLFxuICAgICAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5ERUZBVUxUX1NQQU4sXG4gICAgICAgICAgICAgIG1hcmtzOiBpc0NvZGVFbmFibGVkID8gW1wiY29kZVwiXSA6IFtdLFxuICAgICAgICAgICAgICB0ZXh0OiBlbC50ZXh0Q29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmxvY2txdW90ZSBlbGVtZW50XG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcImJsb2NrcXVvdGVcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGJsb2NrczIgPSB7XG4gICAgICAgICAgLi4uSFRNTF9CTE9DS19UQUdTLFxuICAgICAgICAgIC4uLkhUTUxfSEVBREVSX1RBR1NcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIGJsb2NrczIuYmxvY2txdW90ZTtcbiAgICAgICAgY29uc3Qgbm9uQmxvY2txdW90ZUJsb2NrcyA9IE9iamVjdC5rZXlzKGJsb2NrczIpLCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICByZXR1cm4gZWwuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChlbC5vd25lckRvY3VtZW50KVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgJiYgbm9uQmxvY2txdW90ZUJsb2Nrcy5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgbm9kZS5sb2NhbE5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICBjb25zdCBzcGFuID0gZWwub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSwgcHJldmlvdXNDaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBwcmV2aW91c0NoaWxkICYmIHByZXZpb3VzQ2hpbGQubm9kZVR5cGUgPT09IDMgJiYgcHJldmlvdXNDaGlsZC50ZXh0Q29udGVudD8udHJpbSgpICYmIHNwYW4uYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcclwiKSksIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjbikgPT4ge1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoY24uY2xvbmVOb2RlKCEwKSk7XG4gICAgICAgICAgICAgIH0pLCBpbmRleCAhPT0gZWwuY2hpbGROb2Rlcy5sZW5ndGggJiYgc3Bhbi5hcHBlbmRDaGlsZChlbC5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxyXCIpKSwgY2hpbGRyZW4ucHVzaChzcGFuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9KSwge1xuICAgICAgICAgIF90eXBlOiBcImJsb2NrXCIsXG4gICAgICAgICAgc3R5bGU6IFwiYmxvY2txdW90ZVwiLFxuICAgICAgICAgIG1hcmtEZWZzOiBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dChjaGlsZHJlbilcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJsb2NrIGVsZW1lbnRzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgYmxvY2tzMiA9IHtcbiAgICAgICAgICAuLi5IVE1MX0JMT0NLX1RBR1MsXG4gICAgICAgICAgLi4uSFRNTF9IRUFERVJfVEFHU1xuICAgICAgICB9LCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgbGV0IGJsb2NrID0gdGFnID8gYmxvY2tzMlt0YWddIDogdm9pZCAwO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgcmV0dXJuIGVsLnBhcmVudE5vZGUgJiYgdGFnTmFtZShlbC5wYXJlbnROb2RlKSA9PT0gXCJsaVwiID8gbmV4dChlbC5jaGlsZE5vZGVzKSA6IChvcHRpb25zLmVuYWJsZWRCbG9ja1N0eWxlcy5pbmNsdWRlcyhibG9jay5zdHlsZSkgfHwgKGJsb2NrID0gREVGQVVMVF9CTE9DSyksIHtcbiAgICAgICAgICAgIC4uLmJsb2NrLFxuICAgICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIElnbm9yZSBzcGFuIHRhZ3NcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCwgbmV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKTtcbiAgICAgICAgaWYgKCEoIXRhZyB8fCAhKHRhZyBpbiBIVE1MX1NQQU5fVEFHUykpKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSWdub3JlIGRpdiB0YWdzXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpID09PSBcImRpdlwiKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gSWdub3JlIGxpc3QgY29udGFpbmVyc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ05hbWUoZWwpO1xuICAgICAgICBpZiAoISghdGFnIHx8ICEodGFnIGluIEhUTUxfTElTVF9DT05UQUlORVJfVEFHUykpKVxuICAgICAgICAgIHJldHVybiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGJyJ3NcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAodGFnTmFtZShlbCkgPT09IFwiYnJcIilcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uREVGQVVMVF9TUEFOLFxuICAgICAgICAgICAgdGV4dDogYFxuYFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBEZWFsIHdpdGggbGlzdCBpdGVtc1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0LCBibG9jaykge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdOYW1lKGVsKSwgbGlzdEl0ZW0gPSB0YWcgPyBIVE1MX0xJU1RfSVRFTV9UQUdTW3RhZ10gOiB2b2lkIDAsIHBhcmVudFRhZyA9IHRhZ05hbWUoZWwucGFyZW50Tm9kZSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKCFsaXN0SXRlbSB8fCAhZWwucGFyZW50Tm9kZSB8fCAhSFRNTF9MSVNUX0NPTlRBSU5FUl9UQUdTW3BhcmVudFRhZ10pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbmFibGVkTGlzdEl0ZW0gPSByZXNvbHZlTGlzdEl0ZW0oXG4gICAgICAgICAgcGFyZW50VGFnLFxuICAgICAgICAgIG9wdGlvbnMuZW5hYmxlZExpc3RUeXBlc1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW5hYmxlZExpc3RJdGVtID8gKGxpc3RJdGVtLmxpc3RJdGVtID0gZW5hYmxlZExpc3RJdGVtLCB7XG4gICAgICAgICAgLi4ubGlzdEl0ZW0sXG4gICAgICAgICAgY2hpbGRyZW46IG5leHQoZWwuY2hpbGROb2RlcylcbiAgICAgICAgfSkgOiBibG9jayh7IF90eXBlOiBcImJsb2NrXCIsIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gRGVhbCB3aXRoIGRlY29yYXRvcnMgLSB0aGlzIGlzIGEgbGltaXRlZCBzZXQgb2Yga25vd24gaHRtbCBlbGVtZW50cyB0aGF0IHdlIGtub3cgaG93IHRvIGRlc2VyaWFsaXplXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9yID0gSFRNTF9ERUNPUkFUT1JfVEFHU1t0YWdOYW1lKGVsKSB8fCBcIlwiXTtcbiAgICAgICAgaWYgKCEoIWRlY29yYXRvciB8fCAhb3B0aW9ucy5lbmFibGVkU3BhbkRlY29yYXRvcnMuaW5jbHVkZXMoZGVjb3JhdG9yKSkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF90eXBlOiBcIl9fZGVjb3JhdG9yXCIsXG4gICAgICAgICAgICBuYW1lOiBkZWNvcmF0b3IsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGh5cGVybGlua3MsIGFkZCBhbm5vdGF0aW9uIChpZiBhbGxvd2VkIGJ5IHNjaGVtYSksXG4gICAgLy8gSWYgbm90IHN1cHBvcnRlZCBqdXN0IHdyaXRlIG91dCB0aGUgbGluayB0ZXh0IGFuZCBocmVmIGluIHBsYWluIHRleHQuXG4gICAge1xuICAgICAgZGVzZXJpYWxpemUoZWwsIG5leHQpIHtcbiAgICAgICAgaWYgKHRhZ05hbWUoZWwpICE9PSBcImFcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxpbmtFbmFibGVkID0gb3B0aW9ucy5lbmFibGVkQmxvY2tBbm5vdGF0aW9ucy5pbmNsdWRlcyhcImxpbmtcIiksIGhyZWYgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICAgIGlmICghaHJlZilcbiAgICAgICAgICByZXR1cm4gbmV4dChlbC5jaGlsZE5vZGVzKTtcbiAgICAgICAgbGV0IG1hcmtEZWY7XG4gICAgICAgIHJldHVybiBsaW5rRW5hYmxlZCA/IChtYXJrRGVmID0ge1xuICAgICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICAgIF90eXBlOiBcImxpbmtcIixcbiAgICAgICAgICBocmVmXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBfdHlwZTogXCJfX2Fubm90YXRpb25cIixcbiAgICAgICAgICBtYXJrRGVmLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0KGVsLmNoaWxkTm9kZXMpXG4gICAgICAgIH0pIDogZWwuYXBwZW5kQ2hpbGQoZWwub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgICgke2hyZWZ9KWApKSAmJiBuZXh0KGVsLmNoaWxkTm9kZXMpO1xuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cbmZ1bmN0aW9uIGlzRW1waGFzaXMoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtc3R5bGU6aXRhbGljLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNTdHJvbmcoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL2ZvbnQtd2VpZ2h0OjcwMC8udGVzdChzdHlsZSB8fCBcIlwiKSB8fCAvZm9udC13ZWlnaHQ6NjAwLy50ZXN0KHN0eWxlIHx8IFwiXCIpO1xufVxuZnVuY3Rpb24gaXNVbmRlcmxpbmUoZWwpIHtcbiAgY29uc3Qgc3R5bGUgPSBpc0VsZW1lbnQoZWwpICYmIGVsLmdldEF0dHJpYnV0ZShcInN0eWxlXCIpO1xuICByZXR1cm4gL3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmUvLnRlc3Qoc3R5bGUgfHwgXCJcIik7XG59XG5mdW5jdGlvbiBpc05vdGlvbihlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiAhIWVsLmdldEF0dHJpYnV0ZShcImRhdGEtaXMtbm90aW9uXCIpO1xufVxuZnVuY3Rpb24gY3JlYXRlTm90aW9uUnVsZXMoX2Jsb2NrQ29udGVudFR5cGUpIHtcbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICBkZXNlcmlhbGl6ZShlbCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50KGVsKSAmJiB0YWdOYW1lKGVsKSA9PT0gXCJzcGFuXCIgJiYgaXNOb3Rpb24oZWwpKSB7XG4gICAgICAgICAgY29uc3Qgc3BhbiA9IHtcbiAgICAgICAgICAgIC4uLkRFRkFVTFRfU1BBTixcbiAgICAgICAgICAgIG1hcmtzOiBbXSxcbiAgICAgICAgICAgIHRleHQ6IGVsLnRleHRDb250ZW50XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaXNTdHJvbmcoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInN0cm9uZ1wiKSwgaXNVbmRlcmxpbmUoZWwpICYmIHNwYW4ubWFya3MucHVzaChcInVuZGVybGluZVwiKSwgaXNFbXBoYXNpcyhlbCkgJiYgc3Bhbi5tYXJrcy5wdXNoKFwiZW1cIiksIHNwYW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5mdW5jdGlvbiBnZXRMaXN0SXRlbVN0eWxlKGVsKSB7XG4gIGNvbnN0IHN0eWxlID0gaXNFbGVtZW50KGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgaWYgKHN0eWxlICYmIHN0eWxlLm1hdGNoKC9sZm9cXGQrLykpXG4gICAgcmV0dXJuIHN0eWxlLm1hdGNoKFwibGZvMVwiKSA/IFwiYnVsbGV0XCIgOiBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1MZXZlbChlbCkge1xuICBjb25zdCBzdHlsZSA9IGlzRWxlbWVudChlbCkgJiYgZWwuZ2V0QXR0cmlidXRlKFwic3R5bGVcIik7XG4gIGlmICghc3R5bGUpXG4gICAgcmV0dXJuO1xuICBjb25zdCBsZXZlbE1hdGNoID0gc3R5bGUubWF0Y2goL2xldmVsXFxkKy8pO1xuICBpZiAoIWxldmVsTWF0Y2gpXG4gICAgcmV0dXJuO1xuICBjb25zdCBbbGV2ZWxdID0gbGV2ZWxNYXRjaFswXS5tYXRjaCgvXFxkLykgfHwgW107XG4gIHJldHVybiAobGV2ZWwgPyBOdW1iZXIucGFyc2VJbnQobGV2ZWwsIDEwKSA6IDEpIHx8IDE7XG59XG5mdW5jdGlvbiBpc1dvcmRMaXN0RWxlbWVudChlbCkge1xuICByZXR1cm4gaXNFbGVtZW50KGVsKSAmJiBlbC5jbGFzc05hbWUgPyBlbC5jbGFzc05hbWUgPT09IFwiTXNvTGlzdFBhcmFncmFwaEN4U3BGaXJzdFwiIHx8IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcE1pZGRsZVwiIHx8IGVsLmNsYXNzTmFtZSA9PT0gXCJNc29MaXN0UGFyYWdyYXBoQ3hTcExhc3RcIiA6ICExO1xufVxuZnVuY3Rpb24gY3JlYXRlV29yZFJ1bGVzKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIGRlc2VyaWFsaXplKGVsLCBuZXh0KSB7XG4gICAgICAgIGlmICh0YWdOYW1lKGVsKSA9PT0gXCJwXCIgJiYgaXNXb3JkTGlzdEVsZW1lbnQoZWwpKVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ERUZBVUxUX0JMT0NLLFxuICAgICAgICAgICAgbGlzdEl0ZW06IGdldExpc3RJdGVtU3R5bGUoZWwpLFxuICAgICAgICAgICAgbGV2ZWw6IGdldExpc3RJdGVtTGV2ZWwoZWwpLFxuICAgICAgICAgICAgc3R5bGU6IEJMT0NLX0RFRkFVTFRfU1RZTEUsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dChlbC5jaGlsZE5vZGVzKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlUnVsZXMoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIC4uLmNyZWF0ZVdvcmRSdWxlcygpLFxuICAgIC4uLmNyZWF0ZU5vdGlvblJ1bGVzKCksXG4gICAgLi4uY3JlYXRlR0RvY3NSdWxlcyhibG9ja0NvbnRlbnRUeXBlLCBvcHRpb25zKSxcbiAgICAuLi5jcmVhdGVIVE1MUnVsZXMoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucylcbiAgXTtcbn1cbmNsYXNzIEh0bWxEZXNlcmlhbGl6ZXIge1xuICBibG9ja0NvbnRlbnRUeXBlO1xuICBydWxlcztcbiAgcGFyc2VIdG1sO1xuICBfbWFya0RlZnMgPSBbXTtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzZXJpYWxpemVyIHJlc3BlY3RpbmcgYSBTYW5pdHkgYmxvY2sgY29udGVudCB0eXBlJ3Mgc2NoZW1hXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja0NvbnRlbnRUeXBlIC0gU2NoZW1hIHR5cGUgZm9yIGFycmF5IGNvbnRhaW5pbmcgX2F0IGxlYXN0XyBhIGJsb2NrIGNoaWxkIHR5cGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGVzZXJpYWxpemF0aW9uIHByb2Nlc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcnVsZXMgPSBbXSwgdW5zdGFibGVfd2hpdGVzcGFjZU9uUGFzdGVNb2RlID0gXCJwcmVzZXJ2ZVwiIH0gPSBvcHRpb25zO1xuICAgIGlmICghYmxvY2tDb250ZW50VHlwZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAnYmxvY2tDb250ZW50VHlwZScgaXMgcmVxdWlyZWRcIik7XG4gICAgY29uc3Qgc3RhbmRhcmRSdWxlcyA9IGNyZWF0ZVJ1bGVzKGJsb2NrQ29udGVudFR5cGUsIHtcbiAgICAgIC4uLmNyZWF0ZVJ1bGVPcHRpb25zKGJsb2NrQ29udGVudFR5cGUpLFxuICAgICAga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvclxuICAgIH0pO1xuICAgIHRoaXMucnVsZXMgPSBbLi4ucnVsZXMsIC4uLnN0YW5kYXJkUnVsZXNdO1xuICAgIGNvbnN0IHBhcnNlSHRtbCA9IG9wdGlvbnMucGFyc2VIdG1sIHx8IGRlZmF1bHRQYXJzZUh0bWwoKTtcbiAgICB0aGlzLmJsb2NrQ29udGVudFR5cGUgPSBibG9ja0NvbnRlbnRUeXBlLCB0aGlzLnBhcnNlSHRtbCA9IChodG1sKSA9PiBwcmVwcm9jZXNzKGh0bWwsIHBhcnNlSHRtbCwgeyB1bnN0YWJsZV93aGl0ZXNwYWNlT25QYXN0ZU1vZGUgfSkuYm9keTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgSFRNTC5cbiAgICpcbiAgICogQHBhcmFtIGh0bWwgLSBUaGUgSFRNTCB0byBkZXNlcmlhbGl6ZSwgYXMgYSBzdHJpbmdcbiAgICogQHJldHVybnMgQXJyYXkgb2YgYmxvY2tzIC0gZWl0aGVyIHBvcnRhYmxlIHRleHQgYmxvY2tzIG9yIG90aGVyIGFsbG93ZWQgYmxvY2tzXG4gICAqL1xuICBkZXNlcmlhbGl6ZSA9IChodG1sKSA9PiB7XG4gICAgdGhpcy5fbWFya0RlZnMgPSBbXTtcbiAgICBjb25zdCB7IHBhcnNlSHRtbCB9ID0gdGhpcywgZnJhZ21lbnQgPSBwYXJzZUh0bWwoaHRtbCksIGNoaWxkcmVuID0gQXJyYXkuZnJvbShmcmFnbWVudC5jaGlsZE5vZGVzKSwgYmxvY2tzMiA9IHRyaW1XaGl0ZXNwYWNlKFxuICAgICAgZmxhdHRlbk5lc3RlZEJsb2NrcyhcbiAgICAgICAgZW5zdXJlUm9vdElzQmxvY2tzKHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhjaGlsZHJlbikpXG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLl9tYXJrRGVmcy5sZW5ndGggPiAwICYmIGJsb2NrczIuZmlsdGVyKFxuICAgICAgKGJsb2NrKSA9PiBibG9jay5fdHlwZSA9PT0gXCJibG9ja1wiXG4gICAgKS5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgICAgYmxvY2subWFya0RlZnMgPSBibG9jay5tYXJrRGVmcyB8fCBbXSwgYmxvY2subWFya0RlZnMgPSBibG9jay5tYXJrRGVmcy5jb25jYXQoXG4gICAgICAgIHRoaXMuX21hcmtEZWZzLmZpbHRlcigoZGVmKSA9PiBmbGF0dGVuKFxuICAgICAgICAgIGJsb2NrLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLm1hcmtzIHx8IFtdKVxuICAgICAgICApLmluY2x1ZGVzKGRlZi5fa2V5KSlcbiAgICAgICk7XG4gICAgfSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuYmxvY2tDb250ZW50VHlwZS5vZi5maW5kKGZpbmRCbG9ja1R5cGUpO1xuICAgIHJldHVybiB0eXBlID8gYmxvY2tzMi5tYXAoKGJsb2NrKSA9PiAoYmxvY2suX3R5cGUgPT09IFwiYmxvY2tcIiAmJiAoYmxvY2suX3R5cGUgPSB0eXBlLm5hbWUpLCBibG9jaykpIDogYmxvY2tzMjtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGFuIGFycmF5IG9mIERPTSBlbGVtZW50cy5cbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnRzIC0gQXJyYXkgb2YgRE9NIGVsZW1lbnRzIHRvIGRlc2VyaWFsaXplXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnRzID0gKGVsZW1lbnRzID0gW10pID0+IHtcbiAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICByZXR1cm4gZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQodGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH0pLCBub2RlcztcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgRE9NIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGVsZW1lbnQgLSBEZXNlcmlhbGl6ZSBhIERPTSBlbGVtZW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBkZXNlcmlhbGl6ZUVsZW1lbnQgPSAoZWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IG5leHQgPSAoZWxlbWVudHMpID0+IHtcbiAgICAgIGlmIChpc05vZGVMaXN0KGVsZW1lbnRzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVFbGVtZW50cyhBcnJheS5mcm9tKGVsZW1lbnRzKSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50cykpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRWxlbWVudHMoZWxlbWVudHMpO1xuICAgICAgaWYgKGVsZW1lbnRzKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVsZW1lbnQoZWxlbWVudHMpO1xuICAgIH0sIGJsb2NrID0gKHByb3BzKSA9PiAoe1xuICAgICAgX3R5cGU6IFwiX19ibG9ja1wiLFxuICAgICAgYmxvY2s6IHByb3BzXG4gICAgfSk7XG4gICAgbGV0IG5vZGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlc1tpXTtcbiAgICAgIGlmICghcnVsZS5kZXNlcmlhbGl6ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZXQgPSBydWxlLmRlc2VyaWFsaXplKGVsZW1lbnQsIG5leHQsIGJsb2NrKSwgdHlwZSA9IHJlc29sdmVKc1R5cGUocmV0KTtcbiAgICAgIGlmICh0eXBlICE9PSBcImFycmF5XCIgJiYgdHlwZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBcIm51bGxcIiAmJiB0eXBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEEgcnVsZSByZXR1cm5lZCBhbiBpbnZhbGlkIGRlc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbjogXCIke25vZGV9XCIuYFxuICAgICAgICApO1xuICAgICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocmV0ID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVzZXJpYWxpemVyIHJ1bGUgcmV0dXJuZWQgYG51bGxgXCIpO1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkocmV0KSA/IG5vZGUgPSByZXQgOiBpc1BsYWNlaG9sZGVyRGVjb3JhdG9yKHJldCkgPyBub2RlID0gdGhpcy5kZXNlcmlhbGl6ZURlY29yYXRvcihyZXQpIDogaXNQbGFjZWhvbGRlckFubm90YXRpb24ocmV0KSA/IG5vZGUgPSB0aGlzLmRlc2VyaWFsaXplQW5ub3RhdGlvbihyZXQpIDogbm9kZSA9IHJldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiBcImxpc3RJdGVtXCIgaW4gcmV0KSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZTtcbiAgICAgICAgICBmb3IgKDsgcGFyZW50ICYmIHRhZ05hbWUocGFyZW50KSA9PT0gXCJsaVwiOyApXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZT8ucGFyZW50Tm9kZSwgcmV0LmxldmVsID0gcmV0LmxldmVsID8gcmV0LmxldmVsICsgMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ICYmICFBcnJheS5pc0FycmF5KHJldCkgJiYgaXNNaW5pbWFsQmxvY2socmV0KSAmJiByZXQuc3R5bGUgPT09IFwiYmxvY2txdW90ZVwiICYmIHJldC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpc01pbmltYWxTcGFuKGNoaWxkKSAmJiBjaGlsZC50ZXh0ID09PSBcIlxcclwiICYmIChjaGlsZC50ZXh0ID0gYFxuYCwgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSByZXQuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgJiYgcmV0LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlIHx8IG5leHQoZWxlbWVudC5jaGlsZE5vZGVzKSB8fCBbXTtcbiAgfTtcbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGEgYF9fZGVjb3JhdG9yYCB0eXBlXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBkZWNvcmF0b3JzIGV4Y2x1c2l2ZWx5KVxuICAgKlxuICAgKiBAcGFyYW0gZGVjb3JhdG9yIC1cbiAgICogQHJldHVybnMgYXJyYXkgb2YgLi4uXG4gICAqL1xuICBkZXNlcmlhbGl6ZURlY29yYXRvciA9IChkZWNvcmF0b3IpID0+IHtcbiAgICBjb25zdCB7IG5hbWUgfSA9IGRlY29yYXRvciwgYXBwbHlEZWNvcmF0b3IgPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJEZWNvcmF0b3Iobm9kZSkpXG4gICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGVjb3JhdG9yKG5vZGUpO1xuICAgICAgaWYgKGlzTWluaW1hbFNwYW4obm9kZSkpXG4gICAgICAgIG5vZGUubWFya3MgPSBub2RlLm1hcmtzIHx8IFtdLCBub2RlLnRleHQudHJpbSgpICYmIG5vZGUubWFya3MudW5zaGlmdChuYW1lKTtcbiAgICAgIGVsc2UgaWYgKFwiY2hpbGRyZW5cIiBpbiBub2RlICYmIEFycmF5LmlzQXJyYXkobm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlO1xuICAgICAgICBibG9jay5jaGlsZHJlbiA9IGJsb2NrLmNoaWxkcmVuLm1hcChhcHBseURlY29yYXRvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBkZWNvcmF0b3IuY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlEZWNvcmF0b3Iobm9kZSk7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXQpID8gY2hpbGRyZW4uY29uY2F0KHJldCkgOiAoY2hpbGRyZW4ucHVzaChyZXQpLCBjaGlsZHJlbik7XG4gICAgfSwgW10pO1xuICB9O1xuICAvKipcbiAgICogRGVzZXJpYWxpemUgYSBgX19hbm5vdGF0aW9uYCBvYmplY3QuXG4gICAqIChhbiBpbnRlcm5hbCBtYWRlIHVwIHR5cGUgdG8gcHJvY2VzcyBhbm5vdGF0aW9ucyBleGNsdXNpdmVseSlcbiAgICpcbiAgICogQHBhcmFtIGFubm90YXRpb24gLVxuICAgKiBAcmV0dXJucyBBcnJheSBvZi4uLlxuICAgKi9cbiAgZGVzZXJpYWxpemVBbm5vdGF0aW9uID0gKGFubm90YXRpb24pID0+IHtcbiAgICBjb25zdCB7IG1hcmtEZWYgfSA9IGFubm90YXRpb247XG4gICAgdGhpcy5fbWFya0RlZnMucHVzaChtYXJrRGVmKTtcbiAgICBjb25zdCBhcHBseUFubm90YXRpb24gPSAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzUGxhY2Vob2xkZXJBbm5vdGF0aW9uKG5vZGUpKVxuICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUFubm90YXRpb24obm9kZSk7XG4gICAgICBpZiAoaXNNaW5pbWFsU3Bhbihub2RlKSlcbiAgICAgICAgbm9kZS5tYXJrcyA9IG5vZGUubWFya3MgfHwgW10sIG5vZGUudGV4dC50cmltKCkgJiYgbm9kZS5tYXJrcy51bnNoaWZ0KG1hcmtEZWYuX2tleSk7XG4gICAgICBlbHNlIGlmIChcImNoaWxkcmVuXCIgaW4gbm9kZSAmJiBBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZTtcbiAgICAgICAgYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5tYXAoYXBwbHlBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgcmV0dXJuIGFubm90YXRpb24uY2hpbGRyZW4ucmVkdWNlKChjaGlsZHJlbiwgbm9kZSkgPT4ge1xuICAgICAgY29uc3QgcmV0ID0gYXBwbHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmV0KSA/IGNoaWxkcmVuLmNvbmNhdChyZXQpIDogKGNoaWxkcmVuLnB1c2gocmV0KSwgY2hpbGRyZW4pO1xuICAgIH0sIFtdKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJsb2NrKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAobm9kZS5fdHlwZSAhPT0gKG9wdGlvbnMuYmxvY2tUeXBlTmFtZSB8fCBcImJsb2NrXCIpKVxuICAgIHJldHVybiBcIl9rZXlcIiBpbiBub2RlID8gbm9kZSA6IHtcbiAgICAgIC4uLm5vZGUsXG4gICAgICBfa2V5OiBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKVxuICAgIH07XG4gIGNvbnN0IGJsb2NrID0ge1xuICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBtYXJrRGVmczogW10sXG4gICAgLi4ubm9kZVxuICB9LCBsYXN0Q2hpbGQgPSBibG9jay5jaGlsZHJlbltibG9jay5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKCFsYXN0Q2hpbGQpXG4gICAgcmV0dXJuIGJsb2NrLmNoaWxkcmVuID0gW1xuICAgICAge1xuICAgICAgICBfdHlwZTogXCJzcGFuXCIsXG4gICAgICAgIF9rZXk6IG9wdGlvbnMua2V5R2VuZXJhdG9yID8gb3B0aW9ucy5rZXlHZW5lcmF0b3IoKSA6IGtleUdlbmVyYXRvcigpLFxuICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICBtYXJrczogW11cbiAgICAgIH1cbiAgICBdLCBibG9jaztcbiAgY29uc3QgdXNlZE1hcmtEZWZzID0gW10sIGFsbG93ZWREZWNvcmF0b3JzID0gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxsb3dlZERlY29yYXRvcnMpID8gb3B0aW9ucy5hbGxvd2VkRGVjb3JhdG9ycyA6ICExO1xuICByZXR1cm4gYmxvY2suY2hpbGRyZW4gPSBibG9jay5jaGlsZHJlbi5yZWR1Y2UoXG4gICAgKGFjYywgY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hpbGQgPSBhY2NbYWNjLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHByZXZpb3VzQ2hpbGQgJiYgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiBpc1BvcnRhYmxlVGV4dFNwYW4ocHJldmlvdXNDaGlsZCkgJiYgaXNFcXVhbChwcmV2aW91c0NoaWxkLm1hcmtzLCBjaGlsZC5tYXJrcykgPyAobGFzdENoaWxkICYmIGxhc3RDaGlsZCA9PT0gY2hpbGQgJiYgY2hpbGQudGV4dCA9PT0gXCJcIiAmJiBibG9jay5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IChwcmV2aW91c0NoaWxkLnRleHQgKz0gY2hpbGQudGV4dCksIGFjYykgOiAoYWNjLnB1c2goY2hpbGQpLCBhY2MpO1xuICAgIH0sXG4gICAgW11cbiAgKS5tYXAoKGNoaWxkKSA9PiB7XG4gICAgaWYgKCFjaGlsZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgY2hpbGRcIik7XG4gICAgcmV0dXJuIGNoaWxkLl9rZXkgPSBvcHRpb25zLmtleUdlbmVyYXRvciA/IG9wdGlvbnMua2V5R2VuZXJhdG9yKCkgOiBrZXlHZW5lcmF0b3IoKSwgaXNQb3J0YWJsZVRleHRTcGFuKGNoaWxkKSAmJiAoY2hpbGQubWFya3MgPyBhbGxvd2VkRGVjb3JhdG9ycyAmJiAoY2hpbGQubWFya3MgPSBjaGlsZC5tYXJrcy5maWx0ZXIoKG1hcmspID0+IHtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWREZWNvcmF0b3JzLmluY2x1ZGVzKG1hcmspLCBpc1VzZWQgPSBibG9jay5tYXJrRGVmcz8uc29tZSgoZGVmKSA9PiBkZWYuX2tleSA9PT0gbWFyayk7XG4gICAgICByZXR1cm4gaXNBbGxvd2VkIHx8IGlzVXNlZDtcbiAgICB9KSkgOiBjaGlsZC5tYXJrcyA9IFtdLCB1c2VkTWFya0RlZnMucHVzaCguLi5jaGlsZC5tYXJrcykpLCBjaGlsZDtcbiAgfSksIGJsb2NrLm1hcmtEZWZzID0gKGJsb2NrLm1hcmtEZWZzIHx8IFtdKS5maWx0ZXIoXG4gICAgKG1hcmtEZWYpID0+IHVzZWRNYXJrRGVmcy5pbmNsdWRlcyhtYXJrRGVmLl9rZXkpXG4gICksIGJsb2NrO1xufVxuZnVuY3Rpb24gaHRtbFRvQmxvY2tzKGh0bWwsIGJsb2NrQ29udGVudFR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gbmV3IEh0bWxEZXNlcmlhbGl6ZXIoYmxvY2tDb250ZW50VHlwZSwgb3B0aW9ucykuZGVzZXJpYWxpemUoaHRtbCkubWFwKChibG9jaykgPT4gbm9ybWFsaXplQmxvY2soYmxvY2ssIHsga2V5R2VuZXJhdG9yOiBvcHRpb25zLmtleUdlbmVyYXRvciB9KSk7XG59XG5mdW5jdGlvbiBnZXRCbG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKSB7XG4gIHJldHVybiBibG9ja0NvbnRlbnRGZWF0dXJlcyhibG9ja0NvbnRlbnRUeXBlKTtcbn1cbmV4cG9ydCB7XG4gIGdldEJsb2NrQ29udGVudEZlYXR1cmVzLFxuICBodG1sVG9CbG9ja3MsXG4gIG5vcm1hbGl6ZUJsb2NrLFxuICByYW5kb21LZXlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@portabletext+block-tools@1_85ea45ec7b1750c9ee9308599ea2f210/node_modules/@portabletext/block-tools/lib/index.js\n");

/***/ })

};
;