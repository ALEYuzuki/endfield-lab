"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity+mutator@3.99.0_@types+react@18.3.24";
exports.ids = ["vendor-chunks/@sanity+mutator@3.99.0_@types+react@18.3.24"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@sanity+mutator@3.99.0_@types+react@18.3.24/node_modules/@sanity/mutator/lib/index.mjs":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+mutator@3.99.0_@types+react@18.3.24/node_modules/@sanity/mutator/lib/index.mjs ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferedDocument: () => (/* binding */ BufferedDocument),\n/* harmony export */   Mutation: () => (/* binding */ Mutation),\n/* harmony export */   arrayToJSONMatchPath: () => (/* binding */ arrayToJSONMatchPath),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   extractWithPath: () => (/* binding */ extractWithPath)\n/* harmony export */ });\n/* harmony import */ var lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/isEqual.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEqual.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/../node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js\");\n/* harmony import */ var lodash_flatten_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/flatten.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js\");\n/* harmony import */ var _sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/../node_modules/.pnpm/@sanity+diff-match-patch@3.2.0/node_modules/@sanity/diff-match-patch/dist/index.js\");\n/* harmony import */ var lodash_max_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/max.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/max.js\");\n/* harmony import */ var lodash_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/min.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/min.js\");\n/* harmony import */ var _sanity_uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @sanity/uuid */ \"(ssr)/../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var lodash_compact_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/compact.js */ \"(ssr)/../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js\");\n\n\n\n\n\n\n\n\nconst debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"mutator-document\");\nclass ImmutableAccessor {\n  _value;\n  path;\n  constructor(value, path) {\n    this._value = value, this.path = path || [];\n  }\n  containerType() {\n    return Array.isArray(this._value) ? \"array\" : this._value !== null && typeof this._value == \"object\" ? \"object\" : \"primitive\";\n  }\n  // Common reader, supported by all containers\n  get() {\n    return this._value;\n  }\n  // Array reader\n  length() {\n    if (!Array.isArray(this._value))\n      throw new Error(\"Won't return length of non-indexable _value\");\n    return this._value.length;\n  }\n  getIndex(i) {\n    return Array.isArray(this._value) ? i >= this.length() ? null : new ImmutableAccessor(this._value[i], this.path.concat(i)) : !1;\n  }\n  // Object reader\n  hasAttribute(key) {\n    return isRecord$1(this._value) ? this._value.hasOwnProperty(key) : !1;\n  }\n  attributeKeys() {\n    return isRecord$1(this._value) ? Object.keys(this._value) : [];\n  }\n  getAttribute(key) {\n    if (!isRecord$1(this._value))\n      throw new Error(\"getAttribute only applies to plain objects\");\n    return this.hasAttribute(key) ? new ImmutableAccessor(this._value[key], this.path.concat(key)) : null;\n  }\n  // Common writer, supported by all containers\n  set(value) {\n    return value === this._value ? this : new ImmutableAccessor(value, this.path);\n  }\n  // array writer interface\n  setIndex(i, value) {\n    if (!Array.isArray(this._value))\n      throw new Error(\"setIndex only applies to arrays\");\n    if (Object.is(value, this._value[i]))\n      return this;\n    const nextValue = this._value.slice();\n    return nextValue[i] = value, new ImmutableAccessor(nextValue, this.path);\n  }\n  setIndexAccessor(i, accessor) {\n    return this.setIndex(i, accessor.get());\n  }\n  unsetIndices(indices) {\n    if (!Array.isArray(this._value))\n      throw new Error(\"unsetIndices only applies to arrays\");\n    const length = this._value.length, nextValue = [];\n    for (let i = 0; i < length; i++)\n      indices.indexOf(i) === -1 && nextValue.push(this._value[i]);\n    return new ImmutableAccessor(nextValue, this.path);\n  }\n  insertItemsAt(pos, items) {\n    if (!Array.isArray(this._value))\n      throw new Error(\"insertItemsAt only applies to arrays\");\n    let nextValue;\n    return this._value.length === 0 && pos === 0 ? nextValue = items : nextValue = this._value.slice(0, pos).concat(items).concat(this._value.slice(pos)), new ImmutableAccessor(nextValue, this.path);\n  }\n  // Object writer interface\n  setAttribute(key, value) {\n    if (!isRecord$1(this._value))\n      throw new Error(\"Unable to set attribute of non-object container\");\n    if (Object.is(value, this._value[key]))\n      return this;\n    const nextValue = Object.assign({}, this._value, { [key]: value });\n    return new ImmutableAccessor(nextValue, this.path);\n  }\n  setAttributeAccessor(key, accessor) {\n    return this.setAttribute(key, accessor.get());\n  }\n  unsetAttribute(key) {\n    if (!isRecord$1(this._value))\n      throw new Error(\"Unable to unset attribute of non-object container\");\n    const nextValue = Object.assign({}, this._value);\n    return delete nextValue[key], new ImmutableAccessor(nextValue, this.path);\n  }\n}\nfunction isRecord$1(value) {\n  return value !== null && typeof value == \"object\";\n}\nfunction isRecord(value) {\n  return value !== null && typeof value == \"object\";\n}\nconst IS_DOTTABLE = /^[a-z_$]+/;\nfunction arrayToJSONMatchPath(pathArray) {\n  let path = \"\";\n  return pathArray.forEach((segment, index) => {\n    path += stringifySegment(segment, index === 0);\n  }), path;\n}\nfunction stringifySegment(segment, hasLeading) {\n  if (typeof segment == \"number\")\n    return `[${segment}]`;\n  if (isRecord(segment)) {\n    const seg = segment;\n    return Object.keys(segment).map((key) => isPrimitiveValue(seg[key]) ? `[${key}==\"${seg[key]}\"]` : \"\").join(\"\");\n  }\n  return typeof segment == \"string\" && IS_DOTTABLE.test(segment) ? hasLeading ? segment : `.${segment}` : `['${segment}']`;\n}\nfunction isPrimitiveValue(val) {\n  switch (typeof val) {\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction descend$1(tail) {\n  const [head, newTail] = splitIfPath(tail);\n  if (!head)\n    throw new Error(\"Head cannot be null\");\n  return spreadIfUnionHead(head, newTail);\n}\nfunction splitIfPath(tail) {\n  if (tail.type !== \"path\")\n    return [tail, null];\n  const nodes = tail.nodes;\n  return nodes.length === 0 ? [null, null] : nodes.length === 1 ? [nodes[0], null] : [nodes[0], { type: \"path\", nodes: nodes.slice(1) }];\n}\nfunction concatPaths(path1, path2) {\n  if (!path1 && !path2)\n    return null;\n  const nodes1 = path1 ? path1.nodes : [], nodes2 = path2 ? path2.nodes : [];\n  return {\n    type: \"path\",\n    nodes: nodes1.concat(nodes2)\n  };\n}\nfunction spreadIfUnionHead(head, tail) {\n  return head.type !== \"union\" ? [[head, tail]] : head.nodes.map((node) => {\n    if (node.type === \"path\") {\n      const [subHead, subTail] = splitIfPath(node);\n      return [subHead, concatPaths(subTail, tail)];\n    }\n    return [node, tail];\n  });\n}\nconst digitChar = /[0-9]/, attributeCharMatcher = /^[a-zA-Z0-9_]$/, attributeFirstCharMatcher = /^[a-zA-Z_]$/, symbols = {\n  // NOTE: These are compared against in order of definition,\n  // thus '==' must come before '=', '>=' before '>', etc.\n  operator: [\"..\", \".\", \",\", \":\", \"?\"],\n  comparator: [\">=\", \"<=\", \"<\", \">\", \"==\", \"!=\"],\n  keyword: [\"$\", \"@\"],\n  boolean: [\"true\", \"false\"],\n  paren: [\"[\", \"]\"]\n}, symbolClasses = Object.keys(symbols);\nclass Tokenizer {\n  source;\n  i;\n  length;\n  tokenizers;\n  constructor(path) {\n    this.source = path, this.length = path.length, this.i = 0, this.tokenizers = [\n      this.tokenizeSymbol,\n      this.tokenizeIdentifier,\n      this.tokenizeNumber,\n      this.tokenizeQuoted\n    ].map((fn) => fn.bind(this));\n  }\n  tokenize() {\n    const result = [];\n    for (; !this.EOF(); ) {\n      this.chompWhitespace();\n      let token = null;\n      if (!this.tokenizers.some((tokenizer) => (token = tokenizer(), !!token)) || !token)\n        throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`);\n      result.push(token);\n    }\n    return result;\n  }\n  takeWhile(fn) {\n    const start = this.i;\n    let result = \"\";\n    for (; !this.EOF(); ) {\n      const nextChar = fn(this.source[this.i]);\n      if (nextChar === null)\n        break;\n      result += nextChar, this.i++;\n    }\n    return this.i === start ? null : result;\n  }\n  EOF() {\n    return this.i >= this.length;\n  }\n  peek() {\n    return this.EOF() ? null : this.source[this.i];\n  }\n  consume(str) {\n    if (this.i + str.length > this.length)\n      throw new Error(`Expected ${str} at end of jsonpath`);\n    if (str === this.source.slice(this.i, this.i + str.length))\n      this.i += str.length;\n    else\n      throw new Error(`Expected \"${str}\", but source contained \"${this.source.slice()}`);\n  }\n  // Tries to match the upcoming bit of string with the provided string. If it matches, returns\n  // the string, then advances the read pointer to the next bit. If not, returns null and nothing\n  // happens.\n  tryConsume(str) {\n    if (this.i + str.length > this.length)\n      return null;\n    if (str === this.source.slice(this.i, this.i + str.length)) {\n      if (str[0].match(attributeCharMatcher) && this.length > this.i + str.length) {\n        const nextChar = this.source[this.i + str.length];\n        if (nextChar && nextChar.match(attributeCharMatcher))\n          return null;\n      }\n      return this.i += str.length, str;\n    }\n    return null;\n  }\n  chompWhitespace() {\n    this.takeWhile((char) => char === \" \" ? \"\" : null);\n  }\n  tokenizeQuoted() {\n    const quote = this.peek();\n    if (quote === \"'\" || quote === '\"') {\n      this.consume(quote);\n      let escape = !1;\n      const inner = this.takeWhile((char) => escape ? (escape = !1, char) : char === \"\\\\\" ? (escape = !0, \"\") : char != quote ? char : null);\n      return this.consume(quote), {\n        type: \"quoted\",\n        value: inner,\n        quote: quote === '\"' ? \"double\" : \"single\"\n      };\n    }\n    return null;\n  }\n  tokenizeIdentifier() {\n    let first = !0;\n    const identifier = this.takeWhile((char) => first ? (first = !1, char.match(attributeFirstCharMatcher) ? char : null) : char.match(attributeCharMatcher) ? char : null);\n    return identifier !== null ? {\n      type: \"identifier\",\n      name: identifier\n    } : null;\n  }\n  tokenizeNumber() {\n    const start = this.i;\n    let dotSeen = !1, digitSeen = !1, negative = !1;\n    this.peek() === \"-\" && (negative = !0, this.consume(\"-\"));\n    const number = this.takeWhile((char) => char === \".\" && !dotSeen && digitSeen ? (dotSeen = !0, char) : (digitSeen = !0, char.match(digitChar) ? char : null));\n    return number !== null ? {\n      type: \"number\",\n      value: negative ? -number : +number,\n      raw: negative ? `-${number}` : number\n    } : (this.i = start, null);\n  }\n  tokenizeSymbol() {\n    for (const symbolClass of symbolClasses) {\n      const symbol = symbols[symbolClass].find((pattern) => this.tryConsume(pattern));\n      if (symbol)\n        return {\n          type: symbolClass,\n          symbol\n        };\n    }\n    return null;\n  }\n}\nfunction tokenize(jsonpath) {\n  return new Tokenizer(jsonpath).tokenize();\n}\nclass Parser {\n  tokens;\n  length;\n  i;\n  constructor(path) {\n    this.tokens = tokenize(path), this.length = this.tokens.length, this.i = 0;\n  }\n  parse() {\n    return this.parsePath();\n  }\n  EOF() {\n    return this.i >= this.length;\n  }\n  // Look at upcoming token\n  peek() {\n    return this.EOF() ? null : this.tokens[this.i];\n  }\n  consume() {\n    const result = this.peek();\n    return this.i += 1, result;\n  }\n  // Return next token if it matches the pattern\n  probe(pattern) {\n    const token = this.peek();\n    if (!token)\n      return null;\n    const record = token;\n    return Object.keys(pattern).every((key) => key in token && pattern[key] === record[key]) ? token : null;\n  }\n  // Return and consume next token if it matches the pattern\n  match(pattern) {\n    return this.probe(pattern) ? this.consume() : null;\n  }\n  parseAttribute() {\n    const token = this.match({ type: \"identifier\" });\n    if (token && token.type === \"identifier\")\n      return {\n        type: \"attribute\",\n        name: token.name\n      };\n    const quoted = this.match({ type: \"quoted\", quote: \"single\" });\n    return quoted && quoted.type === \"quoted\" ? {\n      type: \"attribute\",\n      name: quoted.value || \"\"\n    } : null;\n  }\n  parseAlias() {\n    return this.match({ type: \"keyword\", symbol: \"@\" }) || this.match({ type: \"keyword\", symbol: \"$\" }) ? {\n      type: \"alias\",\n      target: \"self\"\n    } : null;\n  }\n  parseNumber() {\n    const token = this.match({ type: \"number\" });\n    return token && token.type === \"number\" ? {\n      type: \"number\",\n      value: token.value\n    } : null;\n  }\n  parseNumberValue() {\n    const expr = this.parseNumber();\n    return expr ? expr.value : null;\n  }\n  parseSliceSelector() {\n    const start = this.i, rangeStart = this.parseNumberValue();\n    if (!this.match({ type: \"operator\", symbol: \":\" }))\n      return rangeStart === null ? (this.i = start, null) : { type: \"index\", value: rangeStart };\n    const result = {\n      type: \"range\",\n      start: rangeStart,\n      end: this.parseNumberValue()\n    };\n    return this.match({ type: \"operator\", symbol: \":\" }) && (result.step = this.parseNumberValue()), result.start === null && result.end === null ? (this.i = start, null) : result;\n  }\n  parseValueReference() {\n    return this.parseAttribute() || this.parseSliceSelector();\n  }\n  parseLiteralValue() {\n    const literalString = this.match({ type: \"quoted\", quote: \"double\" });\n    if (literalString && literalString.type === \"quoted\")\n      return {\n        type: \"string\",\n        value: literalString.value || \"\"\n      };\n    const literalBoolean = this.match({ type: \"boolean\" });\n    return literalBoolean && literalBoolean.type === \"boolean\" ? {\n      type: \"boolean\",\n      value: literalBoolean.symbol === \"true\"\n    } : this.parseNumber();\n  }\n  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always\n  // on lhs.\n  parseFilterExpression() {\n    const start = this.i, expr = this.parseAttribute() || this.parseAlias();\n    if (!expr)\n      return null;\n    if (this.match({ type: \"operator\", symbol: \"?\" }))\n      return {\n        type: \"constraint\",\n        operator: \"?\",\n        lhs: expr\n      };\n    const binOp = this.match({ type: \"comparator\" });\n    if (!binOp || binOp.type !== \"comparator\")\n      return this.i = start, null;\n    const lhs = expr, rhs = this.parseLiteralValue();\n    if (!rhs)\n      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`);\n    return {\n      type: \"constraint\",\n      operator: binOp.symbol,\n      lhs,\n      rhs\n    };\n  }\n  parseExpression() {\n    return this.parseFilterExpression() || this.parseValueReference();\n  }\n  parseUnion() {\n    if (!this.match({ type: \"paren\", symbol: \"[\" }))\n      return null;\n    const terms = [];\n    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();\n    for (; expr && (terms.push(expr), !this.match({ type: \"paren\", symbol: \"]\" })); ) {\n      if (!this.match({ type: \"operator\", symbol: \",\" }))\n        throw new Error(\"Expected ]\");\n      if (expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference(), !expr)\n        throw new Error(\"Expected expression following ','\");\n    }\n    return {\n      type: \"union\",\n      nodes: terms\n    };\n  }\n  parseRecursive() {\n    if (!this.match({ type: \"operator\", symbol: \"..\" }))\n      return null;\n    const subpath = this.parsePath();\n    if (!subpath)\n      throw new Error(\"Expected path following '..' operator\");\n    return {\n      type: \"recursive\",\n      term: subpath\n    };\n  }\n  parsePath() {\n    const nodes = [], expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();\n    if (!expr)\n      return null;\n    for (nodes.push(expr); !this.EOF(); )\n      if (this.match({ type: \"operator\", symbol: \".\" })) {\n        const attr = this.parseAttribute();\n        if (!attr)\n          throw new Error(\"Expected attribute name following '.\");\n        nodes.push(attr);\n        continue;\n      } else if (this.probe({ type: \"paren\", symbol: \"[\" })) {\n        const union = this.parseUnion();\n        if (!union)\n          throw new Error(\"Expected union following '['\");\n        nodes.push(union);\n      } else {\n        const recursive = this.parseRecursive();\n        recursive && nodes.push(recursive);\n        break;\n      }\n    return nodes.length === 1 ? nodes[0] : {\n      type: \"path\",\n      nodes\n    };\n  }\n}\nfunction parseJsonPath(path) {\n  const parsed = new Parser(path).parse();\n  if (!parsed)\n    throw new Error(`Failed to parse JSON path \"${path}\"`);\n  return parsed;\n}\nfunction toPath(expr) {\n  return toPathInner(expr, !1);\n}\nfunction toPathInner(expr, inUnion) {\n  switch (expr.type) {\n    case \"attribute\":\n      return expr.name;\n    case \"alias\":\n      return expr.target === \"self\" ? \"@\" : \"$\";\n    case \"number\":\n      return `${expr.value}`;\n    case \"range\": {\n      const result = [];\n      return inUnion || result.push(\"[\"), expr.start && result.push(`${expr.start}`), result.push(\":\"), expr.end && result.push(`${expr.end}`), expr.step && result.push(`:${expr.step}`), inUnion || result.push(\"]\"), result.join(\"\");\n    }\n    case \"index\":\n      return inUnion ? `${expr.value}` : `[${expr.value}]`;\n    case \"constraint\": {\n      const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, !1)}` : \"\", inner = `${toPathInner(expr.lhs, !1)} ${expr.operator}${rhs}`;\n      return inUnion ? inner : `[${inner}]`;\n    }\n    case \"string\":\n      return JSON.stringify(expr.value);\n    case \"path\": {\n      const result = [], nodes = expr.nodes.slice();\n      for (; nodes.length > 0; ) {\n        const node = nodes.shift();\n        node && result.push(toPath(node));\n        const upcoming = nodes[0];\n        upcoming && toPathInner(upcoming, !1)[0] !== \"[\" && result.push(\".\");\n      }\n      return result.join(\"\");\n    }\n    case \"union\":\n      return `[${expr.nodes.map((e) => toPathInner(e, !0)).join(\",\")}]`;\n    default:\n      throw new Error(`Unknown node type ${expr.type}`);\n    case \"recursive\":\n      return `..${toPathInner(expr.term, !1)}`;\n  }\n}\nclass Expression {\n  expr;\n  constructor(expr) {\n    if (!expr)\n      throw new Error(\"Attempted to create Expression from null-value\");\n    if (\"expr\" in expr ? this.expr = expr.expr : this.expr = expr, !(\"type\" in this.expr))\n      throw new Error(\"Attempt to create Expression for expression with no type\");\n  }\n  isPath() {\n    return this.expr.type === \"path\";\n  }\n  isUnion() {\n    return this.expr.type === \"union\";\n  }\n  isCollection() {\n    return this.isPath() || this.isUnion();\n  }\n  isConstraint() {\n    return this.expr.type === \"constraint\";\n  }\n  isRecursive() {\n    return this.expr.type === \"recursive\";\n  }\n  isExistenceConstraint() {\n    return this.expr.type === \"constraint\" && this.expr.operator === \"?\";\n  }\n  isIndex() {\n    return this.expr.type === \"index\";\n  }\n  isRange() {\n    return this.expr.type === \"range\";\n  }\n  expandRange(probe) {\n    const probeLength = () => {\n      if (!probe)\n        throw new Error(\"expandRange() required a probe that was not passed\");\n      return probe.length();\n    };\n    let start = \"start\" in this.expr && this.expr.start || 0;\n    start = interpretNegativeIndex(start, probe);\n    let end = \"end\" in this.expr && this.expr.end || probeLength();\n    end = interpretNegativeIndex(end, probe);\n    const step = \"step\" in this.expr && this.expr.step || 1;\n    return { start, end, step };\n  }\n  isAttributeReference() {\n    return this.expr.type === \"attribute\";\n  }\n  // Is a range or index -> something referencing indexes\n  isIndexReference() {\n    return this.isIndex() || this.isRange();\n  }\n  name() {\n    return \"name\" in this.expr ? this.expr.name : \"\";\n  }\n  isSelfReference() {\n    return this.expr.type === \"alias\" && this.expr.target === \"self\";\n  }\n  constraintTargetIsSelf() {\n    return this.expr.type === \"constraint\" && this.expr.lhs.type === \"alias\" && this.expr.lhs.target === \"self\";\n  }\n  constraintTargetIsAttribute() {\n    return this.expr.type === \"constraint\" && this.expr.lhs.type === \"attribute\";\n  }\n  testConstraint(probe) {\n    const expr = this.expr;\n    if (expr.type === \"constraint\" && expr.lhs.type === \"alias\" && expr.lhs.target === \"self\") {\n      if (probe.containerType() !== \"primitive\")\n        return !1;\n      if (expr.type === \"constraint\" && expr.operator === \"?\")\n        return !0;\n      const lhs2 = probe.get(), rhs2 = expr.rhs && \"value\" in expr.rhs ? expr.rhs.value : void 0;\n      return testBinaryOperator(lhs2, expr.operator, rhs2);\n    }\n    if (expr.type !== \"constraint\")\n      return !1;\n    const lhs = expr.lhs;\n    if (!lhs)\n      throw new Error(\"No LHS of expression\");\n    if (lhs.type !== \"attribute\")\n      throw new Error(`Constraint target ${lhs.type} not supported`);\n    if (probe.containerType() !== \"object\")\n      return !1;\n    const lhsValue = probe.getAttribute(lhs.name);\n    if (lhsValue == null || lhsValue.containerType() !== \"primitive\")\n      return !1;\n    if (this.isExistenceConstraint())\n      return !0;\n    const rhs = expr.rhs && \"value\" in expr.rhs ? expr.rhs.value : void 0;\n    return testBinaryOperator(lhsValue.get(), expr.operator, rhs);\n  }\n  pathNodes() {\n    return this.expr.type === \"path\" ? this.expr.nodes : [this.expr];\n  }\n  prepend(node) {\n    return node ? new Expression({\n      type: \"path\",\n      nodes: node.pathNodes().concat(this.pathNodes())\n    }) : this;\n  }\n  concat(other) {\n    return other ? other.prepend(this) : this;\n  }\n  descend() {\n    return descend$1(this.expr).map((headTail) => {\n      const [head, tail] = headTail;\n      return {\n        head: head ? new Expression(head) : null,\n        tail: tail ? new Expression(tail) : null\n      };\n    });\n  }\n  unwrapRecursive() {\n    if (this.expr.type !== \"recursive\")\n      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`);\n    return new Expression(this.expr.term);\n  }\n  toIndicies(probe) {\n    if (this.expr.type !== \"index\" && this.expr.type !== \"range\")\n      throw new Error(\"Node cannot be converted to indexes\");\n    if (this.expr.type === \"index\")\n      return [interpretNegativeIndex(this.expr.value, probe)];\n    const result = [], range = this.expandRange(probe);\n    let { start, end } = range;\n    range.step < 0 && ([start, end] = [end, start]);\n    for (let i = start; i < end; i++)\n      result.push(i);\n    return result;\n  }\n  toFieldReferences() {\n    if (this.isIndexReference())\n      return this.toIndicies();\n    if (this.expr.type === \"attribute\")\n      return [this.expr.name];\n    throw new Error(`Can't convert ${this.expr.type} to field references`);\n  }\n  toString() {\n    return toPath(this.expr);\n  }\n  static fromPath(path) {\n    const parsed = parseJsonPath(path);\n    if (!parsed)\n      throw new Error(`Failed to parse path \"${path}\"`);\n    return new Expression(parsed);\n  }\n  static attributeReference(name) {\n    return new Expression({\n      type: \"attribute\",\n      name\n    });\n  }\n  static indexReference(i) {\n    return new Expression({\n      type: \"index\",\n      value: i\n    });\n  }\n}\nfunction testBinaryOperator(lhsValue, operator, rhsValue) {\n  switch (operator) {\n    case \">\":\n      return lhsValue > rhsValue;\n    case \">=\":\n      return lhsValue >= rhsValue;\n    case \"<\":\n      return lhsValue < rhsValue;\n    case \"<=\":\n      return lhsValue <= rhsValue;\n    case \"==\":\n      return lhsValue === rhsValue;\n    case \"!=\":\n      return lhsValue !== rhsValue;\n    default:\n      throw new Error(`Unsupported binary operator ${operator}`);\n  }\n}\nfunction interpretNegativeIndex(index, probe) {\n  if (index >= 0)\n    return index;\n  if (!probe)\n    throw new Error(\"interpretNegativeIndex() must have a probe when < 0\");\n  return index + probe.length();\n}\nclass Descender {\n  head;\n  tail;\n  constructor(head, tail) {\n    this.head = head, this.tail = tail;\n  }\n  // Iterate this descender once processing any constraints that are\n  // resolvable on the current value. Returns an array of new descenders\n  // that are guaranteed to be without constraints in the head\n  iterate(probe) {\n    let result = [this];\n    if (this.head && this.head.isConstraint()) {\n      let anyConstraints = !0;\n      for (; anyConstraints; )\n        result = lodash_flatten_js__WEBPACK_IMPORTED_MODULE_2__(\n          result.map((descender) => descender.iterateConstraints(probe))\n        ), anyConstraints = result.some((descender) => descender.head && descender.head.isConstraint());\n    }\n    return result;\n  }\n  isRecursive() {\n    return !!(this.head && this.head.isRecursive());\n  }\n  hasArrived() {\n    return this.head === null && this.tail === null;\n  }\n  extractRecursives() {\n    if (this.head && this.head.isRecursive()) {\n      const term = this.head.unwrapRecursive();\n      return new Descender(null, term.concat(this.tail)).descend();\n    }\n    return [];\n  }\n  iterateConstraints(probe) {\n    const head = this.head;\n    if (head === null || !head.isConstraint())\n      return [this];\n    const result = [];\n    if (probe.containerType() === \"primitive\" && head.constraintTargetIsSelf())\n      return head.testConstraint(probe) && result.push(...this.descend()), result;\n    if (probe.containerType() === \"array\") {\n      const length = probe.length();\n      for (let i = 0; i < length; i++) {\n        const constraint = probe.getIndex(i);\n        constraint && head.testConstraint(constraint) && result.push(new Descender(new Expression({ type: \"index\", value: i }), this.tail));\n      }\n      return result;\n    }\n    return probe.containerType() === \"object\" ? head.constraintTargetIsSelf() ? [] : head.testConstraint(probe) ? this.descend() : result : result;\n  }\n  descend() {\n    return this.tail ? this.tail.descend().map((ht) => new Descender(ht.head, ht.tail)) : [new Descender(null, null)];\n  }\n  toString() {\n    const result = [\"<\"];\n    return this.head && result.push(this.head.toString()), result.push(\"|\"), this.tail && result.push(this.tail.toString()), result.push(\">\"), result.join(\"\");\n  }\n}\nclass Matcher {\n  active;\n  recursives;\n  payload;\n  constructor(active, parent) {\n    this.active = active || [], parent ? (this.recursives = parent.recursives, this.payload = parent.payload) : this.recursives = [], this.extractRecursives();\n  }\n  setPayload(payload) {\n    return this.payload = payload, this;\n  }\n  // Moves any recursive descenders onto the recursive track, removing them from\n  // the active set\n  extractRecursives() {\n    this.active = this.active.filter((descender) => descender.isRecursive() ? (this.recursives.push(...descender.extractRecursives()), !1) : !0);\n  }\n  // Find recursives that are relevant now and should be considered part of the active set\n  activeRecursives(probe) {\n    return this.recursives.filter((descender) => {\n      const head = descender.head;\n      return head ? head.isConstraint() || probe.containerType() === \"array\" && head.isIndexReference() ? !0 : probe.containerType() === \"object\" ? head.isAttributeReference() && probe.hasAttribute(head.name()) : !1 : !1;\n    });\n  }\n  match(probe) {\n    return this.iterate(probe).extractMatches(probe);\n  }\n  iterate(probe) {\n    const newActiveSet = [];\n    return this.active.concat(this.activeRecursives(probe)).forEach((descender) => {\n      newActiveSet.push(...descender.iterate(probe));\n    }), new Matcher(newActiveSet, this);\n  }\n  // Returns true if any of the descenders in the active or recursive set\n  // consider the current state a final destination\n  isDestination() {\n    return this.active.some((descender) => descender.hasArrived());\n  }\n  hasRecursives() {\n    return this.recursives.length > 0;\n  }\n  // Returns any payload delivieries and leads that needs to be followed to complete\n  // the process.\n  extractMatches(probe) {\n    const leads = [], targets = [];\n    if (this.active.forEach((descender) => {\n      if (descender.hasArrived()) {\n        targets.push(\n          new Expression({\n            type: \"alias\",\n            target: \"self\"\n          })\n        );\n        return;\n      }\n      const descenderHead = descender.head;\n      if (descenderHead && !(probe.containerType() === \"array\" && !descenderHead.isIndexReference()) && !(probe.containerType() === \"object\" && !descenderHead.isAttributeReference()))\n        if (descender.tail) {\n          const matcher = new Matcher(descender.descend(), this);\n          descenderHead.toFieldReferences().forEach(() => {\n            leads.push({\n              target: descenderHead,\n              matcher\n            });\n          });\n        } else\n          targets.push(descenderHead);\n    }), this.hasRecursives()) {\n      const recursivesMatcher = new Matcher([], this);\n      if (probe.containerType() === \"array\") {\n        const length = probe.length();\n        for (let i = 0; i < length; i++)\n          leads.push({\n            target: Expression.indexReference(i),\n            matcher: recursivesMatcher\n          });\n      } else probe.containerType() === \"object\" && probe.attributeKeys().forEach((name) => {\n        leads.push({\n          target: Expression.attributeReference(name),\n          matcher: recursivesMatcher\n        });\n      });\n    }\n    return targets.length > 0 ? { leads, delivery: { targets, payload: this.payload } } : { leads };\n  }\n  static fromPath(jsonpath) {\n    const path = parseJsonPath(jsonpath);\n    if (!path)\n      throw new Error(`Failed to parse path from \"${jsonpath}\"`);\n    const descender = new Descender(null, new Expression(path));\n    return new Matcher(descender.descend());\n  }\n}\nclass PlainProbe {\n  _value;\n  path;\n  constructor(value, path) {\n    this._value = value, this.path = path || [];\n  }\n  containerType() {\n    return Array.isArray(this._value) ? \"array\" : this._value !== null && typeof this._value == \"object\" ? \"object\" : \"primitive\";\n  }\n  length() {\n    if (!Array.isArray(this._value))\n      throw new Error(\"Won't return length of non-indexable _value\");\n    return this._value.length;\n  }\n  getIndex(i) {\n    return Array.isArray(this._value) ? i >= this.length() ? null : new PlainProbe(this._value[i], this.path.concat(i)) : !1;\n  }\n  hasAttribute(key) {\n    return isRecord(this._value) ? this._value.hasOwnProperty(key) : !1;\n  }\n  attributeKeys() {\n    return isRecord(this._value) ? Object.keys(this._value) : [];\n  }\n  getAttribute(key) {\n    if (!isRecord(this._value))\n      throw new Error(\"getAttribute only applies to plain objects\");\n    return this.hasAttribute(key) ? new PlainProbe(this._value[key], this.path.concat(key)) : null;\n  }\n  get() {\n    return this._value;\n  }\n}\nfunction extractAccessors(path, value) {\n  const result = [], matcher = Matcher.fromPath(path).setPayload(function(values) {\n    result.push(...values);\n  }), accessor = new PlainProbe(value);\n  return descend(matcher, accessor), result;\n}\nfunction descend(matcher, accessor) {\n  const { leads, delivery } = matcher.match(accessor);\n  leads.forEach((lead) => {\n    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {\n      descend(lead.matcher, childAccessor);\n    });\n  }), delivery && delivery.targets.forEach((target) => {\n    typeof delivery.payload == \"function\" && delivery.payload(accessorsFromTarget(target, accessor));\n  });\n}\nfunction accessorsFromTarget(target, accessor) {\n  const result = [];\n  if (target.isIndexReference())\n    target.toIndicies(accessor).forEach((i) => {\n      result.push(accessor.getIndex(i));\n    });\n  else if (target.isAttributeReference())\n    result.push(accessor.getAttribute(target.name()));\n  else if (target.isSelfReference())\n    result.push(accessor);\n  else\n    throw new Error(`Unable to derive accessor for target ${target.toString()}`);\n  return lodash_compact_js__WEBPACK_IMPORTED_MODULE_5__(result);\n}\nfunction extract(path, value) {\n  return extractAccessors(path, value).map((acc) => acc.get());\n}\nfunction extractWithPath(path, value) {\n  return extractAccessors(path, value).map((acc) => ({ path: acc.path, value: acc.get() }));\n}\nfunction applyPatch(patch, oldValue) {\n  if (typeof oldValue != \"string\") return oldValue;\n  const [result] = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_6__.applyPatches)(patch, oldValue, { allowExceedingIndices: !0 });\n  return result;\n}\nclass DiffMatchPatch {\n  path;\n  dmpPatch;\n  id;\n  constructor(id, path, dmpPatchSrc) {\n    this.id = id, this.path = path, this.dmpPatch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_6__.parsePatch)(dmpPatchSrc);\n  }\n  apply(targets, accessor) {\n    let result = accessor;\n    if (result.containerType() === \"primitive\")\n      return result;\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          const item = result.getIndex(index);\n          if (!item)\n            continue;\n          const oldValue = item.get(), nextValue = applyPatch(this.dmpPatch, oldValue);\n          result = result.setIndex(index, nextValue);\n        }\n        continue;\n      }\n      if (target.isAttributeReference() && result.hasAttribute(target.name())) {\n        const attribute = result.getAttribute(target.name());\n        if (!attribute)\n          continue;\n        const oldValue = attribute.get(), nextValue = applyPatch(this.dmpPatch, oldValue);\n        result = result.setAttribute(target.name(), nextValue);\n        continue;\n      }\n      throw new Error(`Unable to apply diffMatchPatch to target ${target.toString()}`);\n    }\n    return result;\n  }\n}\nfunction performIncrement(previousValue, delta) {\n  return typeof previousValue != \"number\" || !Number.isFinite(previousValue) ? previousValue : previousValue + delta;\n}\nclass IncPatch {\n  path;\n  value;\n  id;\n  constructor(id, path, value) {\n    this.path = path, this.value = value, this.id = id;\n  }\n  apply(targets, accessor) {\n    let result = accessor;\n    if (result.containerType() === \"primitive\")\n      return result;\n    for (const target of targets) {\n      if (target.isIndexReference()) {\n        for (const index of target.toIndicies(accessor)) {\n          const item = result.getIndex(index);\n          if (!item)\n            continue;\n          const previousValue = item.get();\n          result = result.setIndex(index, performIncrement(previousValue, this.value));\n        }\n        continue;\n      }\n      if (target.isAttributeReference()) {\n        const attribute = result.getAttribute(target.name());\n        if (!attribute)\n          continue;\n        const previousValue = attribute.get();\n        result = result.setAttribute(target.name(), performIncrement(previousValue, this.value));\n        continue;\n      }\n      throw new Error(`Unable to apply to target ${target.toString()}`);\n    }\n    return result;\n  }\n}\nfunction targetsToIndicies(targets, accessor) {\n  const result = [];\n  return targets.forEach((target) => {\n    target.isIndexReference() && result.push(...target.toIndicies(accessor));\n  }), result.sort();\n}\nclass InsertPatch {\n  location;\n  path;\n  items;\n  id;\n  constructor(id, location, path, items) {\n    this.id = id, this.location = location, this.path = path, this.items = items;\n  }\n  apply(targets, accessor) {\n    let result = accessor;\n    if (accessor.containerType() !== \"array\")\n      throw new Error(\"Attempt to apply insert patch to non-array value\");\n    switch (this.location) {\n      case \"before\": {\n        const pos = minIndex(targets, accessor);\n        result = result.insertItemsAt(pos, this.items);\n        break;\n      }\n      case \"after\": {\n        const pos = maxIndex(targets, accessor);\n        result = result.insertItemsAt(pos + 1, this.items);\n        break;\n      }\n      case \"replace\": {\n        const indicies = targetsToIndicies(targets, accessor);\n        result = result.unsetIndices(indicies), result = result.insertItemsAt(indicies[0], this.items);\n        break;\n      }\n      default:\n        throw new Error(`Unsupported location atm: ${this.location}`);\n    }\n    return result;\n  }\n}\nfunction minIndex(targets, accessor) {\n  let result = lodash_min_js__WEBPACK_IMPORTED_MODULE_4__(targetsToIndicies(targets, accessor)) || 0;\n  return targets.forEach((target) => {\n    if (target.isRange()) {\n      const { start } = target.expandRange();\n      start < result && (result = start);\n    }\n  }), result;\n}\nfunction maxIndex(targets, accessor) {\n  let result = lodash_max_js__WEBPACK_IMPORTED_MODULE_3__(targetsToIndicies(targets, accessor)) || 0;\n  return targets.forEach((target) => {\n    if (target.isRange()) {\n      const { end } = target.expandRange();\n      end > result && (result = end);\n    }\n  }), result;\n}\nclass SetIfMissingPatch {\n  id;\n  path;\n  value;\n  constructor(id, path, value) {\n    this.id = id, this.path = path, this.value = value;\n  }\n  apply(targets, accessor) {\n    let result = accessor;\n    return targets.forEach((target) => {\n      if (!target.isIndexReference())\n        if (target.isAttributeReference())\n          result.containerType() === \"primitive\" ? result = result.set({ [target.name()]: this.value }) : result.hasAttribute(target.name()) || (result = accessor.setAttribute(target.name(), this.value));\n        else\n          throw new Error(`Unable to apply to target ${target.toString()}`);\n    }), result;\n  }\n}\nclass SetPatch {\n  id;\n  path;\n  value;\n  constructor(id, path, value) {\n    this.id = id, this.path = path, this.value = value;\n  }\n  apply(targets, accessor) {\n    let result = accessor;\n    return targets.forEach((target) => {\n      if (target.isSelfReference())\n        result = result.set(this.value);\n      else if (target.isIndexReference())\n        target.toIndicies(accessor).forEach((i) => {\n          result = result.setIndex(i, this.value);\n        });\n      else if (target.isAttributeReference())\n        result.containerType() === \"primitive\" ? result = result.set({ [target.name()]: this.value }) : result = result.setAttribute(target.name(), this.value);\n      else\n        throw new Error(`Unable to apply to target ${target.toString()}`);\n    }), result;\n  }\n}\nclass UnsetPatch {\n  id;\n  path;\n  value;\n  constructor(id, path) {\n    this.id = id, this.path = path;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  apply(targets, accessor) {\n    let result = accessor;\n    switch (accessor.containerType()) {\n      case \"array\":\n        result = result.unsetIndices(targetsToIndicies(targets, accessor));\n        break;\n      case \"object\":\n        targets.forEach((target) => {\n          result = result.unsetAttribute(target.name());\n        });\n        break;\n      default:\n        throw new Error(\n          \"Target value is neither indexable or an object. This error should potentially just be silently ignored?\"\n        );\n    }\n    return result;\n  }\n}\nfunction parsePatch(patch) {\n  const result = [];\n  if (Array.isArray(patch))\n    return patch.reduce((r, p) => r.concat(parsePatch(p)), result);\n  const { set, setIfMissing, unset, diffMatchPatch, inc, dec, insert } = patch;\n  if (setIfMissing && Object.keys(setIfMissing).forEach((path) => {\n    result.push(new SetIfMissingPatch(patch.id, path, setIfMissing[path]));\n  }), set && Object.keys(set).forEach((path) => {\n    result.push(new SetPatch(patch.id, path, set[path]));\n  }), unset && unset.forEach((path) => {\n    result.push(new UnsetPatch(patch.id, path));\n  }), diffMatchPatch && Object.keys(diffMatchPatch).forEach((path) => {\n    result.push(new DiffMatchPatch(patch.id, path, diffMatchPatch[path]));\n  }), inc && Object.keys(inc).forEach((path) => {\n    result.push(new IncPatch(patch.id, path, inc[path]));\n  }), dec && Object.keys(dec).forEach((path) => {\n    result.push(new IncPatch(patch.id, path, -dec[path]));\n  }), insert) {\n    let location, path;\n    const spec = insert;\n    if (\"before\" in spec)\n      location = \"before\", path = spec.before;\n    else if (\"after\" in spec)\n      location = \"after\", path = spec.after;\n    else if (\"replace\" in spec)\n      location = \"replace\", path = spec.replace;\n    else\n      throw new Error(\"Invalid insert patch\");\n    result.push(new InsertPatch(patch.id, location, path, spec.items));\n  }\n  return result;\n}\nclass Patcher {\n  patches;\n  constructor(patch) {\n    this.patches = parsePatch(patch);\n  }\n  apply(value) {\n    const accessor = new ImmutableAccessor(value);\n    return this.applyViaAccessor(accessor).get();\n  }\n  // If you want to use your own accessor implementation, you can use this method\n  // to invoke the patcher. Since all subsequent accessors for children of this accessor\n  // are obtained through the methods in the accessors, you retain full control of the\n  // implementation throguhgout the application. Have a look in ImmutableAccessor\n  // to see an example of how accessors are implemented.\n  applyViaAccessor(accessor) {\n    let result = accessor;\n    const idAccessor = accessor.getAttribute(\"_id\");\n    if (!idAccessor)\n      throw new Error(\"Cannot apply patch to document with no _id\");\n    const id = idAccessor.get();\n    for (const patch of this.patches) {\n      if (patch.id !== id)\n        continue;\n      const matcher = Matcher.fromPath(patch.path).setPayload(patch);\n      result = process(matcher, result);\n    }\n    return result;\n  }\n}\nfunction process(matcher, accessor) {\n  const isSetPatch = matcher.payload instanceof SetPatch || matcher.payload instanceof SetIfMissingPatch;\n  let result = accessor;\n  const { leads, delivery } = matcher.match(accessor);\n  return leads.forEach((lead) => {\n    if (lead.target.isIndexReference())\n      lead.target.toIndicies().forEach((i) => {\n        const item = result.getIndex(i);\n        if (!item)\n          throw new Error(\"Index out of bounds\");\n        result = result.setIndexAccessor(i, process(lead.matcher, item));\n      });\n    else if (lead.target.isAttributeReference()) {\n      isSetPatch && result.containerType() === \"primitive\" && (result = result.set({}));\n      let oldValueAccessor = result.getAttribute(lead.target.name());\n      if (!oldValueAccessor && isSetPatch && (result = result.setAttribute(lead.target.name(), {}), oldValueAccessor = result.getAttribute(lead.target.name())), !oldValueAccessor)\n        return;\n      const newValueAccessor = process(lead.matcher, oldValueAccessor);\n      oldValueAccessor !== newValueAccessor && (result = result.setAttributeAccessor(lead.target.name(), newValueAccessor));\n    } else\n      throw new Error(`Unable to handle target ${lead.target.toString()}`);\n  }), delivery && isPatcher(delivery.payload) && (result = delivery.payload.apply(delivery.targets, result)), result;\n}\nfunction isPatcher(payload) {\n  return !!(payload && typeof payload == \"object\" && payload !== null && \"apply\" in payload && typeof payload.apply == \"function\");\n}\nconst luid = _sanity_uuid__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\nclass Mutation {\n  params;\n  compiled;\n  _appliesToMissingDocument;\n  constructor(options) {\n    this.params = options;\n  }\n  get transactionId() {\n    return this.params.transactionId;\n  }\n  get transition() {\n    return this.params.transition;\n  }\n  get identity() {\n    return this.params.identity;\n  }\n  get previousRev() {\n    return this.params.previousRev;\n  }\n  get resultRev() {\n    return this.params.resultRev;\n  }\n  get mutations() {\n    return this.params.mutations;\n  }\n  get timestamp() {\n    if (typeof this.params.timestamp == \"string\")\n      return new Date(this.params.timestamp);\n  }\n  get effects() {\n    return this.params.effects;\n  }\n  assignRandomTransactionId() {\n    this.params.transactionId = luid(), this.params.resultRev = this.params.transactionId;\n  }\n  appliesToMissingDocument() {\n    if (typeof this._appliesToMissingDocument < \"u\")\n      return this._appliesToMissingDocument;\n    const firstMut = this.mutations[0];\n    return firstMut ? this._appliesToMissingDocument = !!(firstMut.create || firstMut.createIfNotExists || firstMut.createOrReplace) : this._appliesToMissingDocument = !0, this._appliesToMissingDocument;\n  }\n  // Compiles all mutations into a handy function\n  compile() {\n    const operations = [], getGuaranteedCreatedAt = (doc) => doc?._createdAt || this.params.timestamp || (/* @__PURE__ */ new Date()).toISOString();\n    this.mutations.forEach((mutation) => {\n      if (mutation.create) {\n        const create = mutation.create || {};\n        operations.push((doc) => doc || Object.assign(create, {\n          _createdAt: getGuaranteedCreatedAt(create)\n        }));\n        return;\n      }\n      if (mutation.createIfNotExists) {\n        const createIfNotExists = mutation.createIfNotExists || {};\n        operations.push(\n          (doc) => doc === null ? Object.assign(createIfNotExists, {\n            _createdAt: getGuaranteedCreatedAt(createIfNotExists)\n          }) : doc\n        );\n        return;\n      }\n      if (mutation.createOrReplace) {\n        const createOrReplace = mutation.createOrReplace || {};\n        operations.push(\n          () => Object.assign(createOrReplace, {\n            _createdAt: getGuaranteedCreatedAt(createOrReplace)\n          })\n        );\n        return;\n      }\n      if (mutation.delete) {\n        operations.push(() => null);\n        return;\n      }\n      if (mutation.patch) {\n        if (\"query\" in mutation.patch)\n          return;\n        const patch = new Patcher(mutation.patch);\n        operations.push((doc) => patch.apply(doc));\n        return;\n      }\n      throw new Error(`Unsupported mutation ${JSON.stringify(mutation, null, 2)}`);\n    }), typeof this.params.timestamp == \"string\" && operations.push((doc) => doc ? Object.assign(doc, { _updatedAt: this.params.timestamp }) : null);\n    const prevRev = this.previousRev, rev = this.resultRev || this.transactionId;\n    this.compiled = (doc) => {\n      if (prevRev && doc && prevRev !== doc._rev)\n        throw new Error(\n          `Previous revision for this mutation was ${prevRev}, but the document revision is ${doc._rev}`\n        );\n      let result = doc;\n      for (const operation of operations)\n        result = operation(result);\n      return result && rev && (result === doc && (result = Object.assign({}, doc)), result._rev = rev), result;\n    };\n  }\n  apply(document) {\n    debug(\"Applying mutation %O to document %O\", this.mutations, document), this.compiled || this.compile();\n    const result = this.compiled(document);\n    return debug(\"  => %O\", result), result;\n  }\n  static applyAll(document, mutations) {\n    return mutations.reduce((doc, mutation) => mutation.apply(doc), document);\n  }\n  // Given a number of yet-to-be-committed mutation objects, collects them into one big mutation\n  // any metadata like transactionId is ignored and must be submitted by the client. It is assumed\n  // that all mutations are on the same document.\n  // TOOO: Optimize mutations, eliminating mutations that overwrite themselves!\n  static squash(document, mutations) {\n    const squashed = mutations.reduce(\n      (result, mutation) => result.concat(...mutation.mutations),\n      []\n    );\n    return new Mutation({ mutations: squashed });\n  }\n}\nclass Document {\n  /**\n   * Incoming patches from the server waiting to be applied to HEAD\n   */\n  incoming = [];\n  /**\n   * Patches we know has been subitted to the server, but has not been seen yet in the return channel\n   * so we can't be sure about the ordering yet (someone else might have slipped something between them)\n   */\n  submitted = [];\n  /**\n   * Pending mutations\n   */\n  pending = [];\n  /**\n   * Our model of the document according to the incoming patches from the server\n   */\n  HEAD;\n  /**\n   * Our optimistic model of what the document will probably look like as soon as all our patches\n   * have been processed. Updated every time we stage a new mutation, but also might revert back\n   * to previous states if our mutations fail, or could change if unexpected mutations arrive\n   * between our own. The `onRebase` callback will be called when EDGE changes in this manner.\n   */\n  EDGE;\n  /**\n   * Called with the EDGE document when that document changes for a reason other than us staging\n   * a new patch or receiving a mutation from the server while our EDGE is in sync with HEAD:\n   * I.e. when EDGE changes because the order of mutations has changed in relation to our\n   * optimistic predictions.\n   */\n  onRebase;\n  /**\n   * Called when we receive a patch in the normal order of things, but the mutation is not ours\n   */\n  onMutation;\n  /**\n   * Called when consistency state changes with the boolean value of the current consistency state\n   */\n  onConsistencyChanged;\n  /**\n   * Called whenever a new incoming mutation comes in. These are always ordered correctly.\n   */\n  onRemoteMutation;\n  /**\n   * We are consistent when there are no unresolved mutations of our own, and no un-applicable\n   * incoming mutations. When this has been going on for too long, and there has been a while\n   * since we staged a new mutation, it is time to reset your state.\n   */\n  inconsistentAt = null;\n  /**\n   * The last time we staged a patch of our own. If we have been inconsistent for a while, but it\n   * hasn't been long since we staged a new mutation, the reason is probably just because the user\n   * is typing or something.\n   *\n   * Should be used as a guard against resetting state for inconsistency reasons.\n   */\n  lastStagedAt = null;\n  constructor(doc) {\n    this.reset(doc), this.HEAD = doc, this.EDGE = doc;\n  }\n  // Reset the state of the Document, used to recover from unsavory states by reloading the document\n  reset(doc) {\n    this.incoming = [], this.submitted = [], this.pending = [], this.inconsistentAt = null, this.HEAD = doc, this.EDGE = doc, this.considerIncoming(), this.updateConsistencyFlag();\n  }\n  // Call when a mutation arrives from Sanity\n  arrive(mutation) {\n    this.incoming.push(mutation), this.considerIncoming(), this.updateConsistencyFlag();\n  }\n  // Call to signal that we are submitting a mutation. Returns a callback object with a\n  // success and failure handler that must be called according to the outcome of our\n  // submission.\n  stage(mutation, silent) {\n    if (!mutation.transactionId)\n      throw new Error(\"Mutations _must_ have transactionId when submitted\");\n    this.lastStagedAt = /* @__PURE__ */ new Date(), debug(\"Staging mutation %s (pushed to pending)\", mutation.transactionId), this.pending.push(mutation), this.EDGE = mutation.apply(this.EDGE), this.onMutation && !silent && this.onMutation({\n      mutation,\n      document: this.EDGE,\n      remote: !1\n    });\n    const txnId = mutation.transactionId;\n    return this.updateConsistencyFlag(), {\n      success: () => {\n        this.pendingSuccessfullySubmitted(txnId), this.updateConsistencyFlag();\n      },\n      failure: () => {\n        this.pendingFailed(txnId), this.updateConsistencyFlag();\n      }\n    };\n  }\n  // Call to check if everything is nice and quiet and there are no unresolved mutations.\n  // Means this model thinks both HEAD and EDGE is up to date with what the server sees.\n  isConsistent() {\n    return !this.inconsistentAt;\n  }\n  // Private\n  // Attempts to apply any resolvable incoming patches to HEAD. Will keep patching as long as there\n  // are applicable patches to be applied\n  considerIncoming() {\n    let mustRebase = !1, nextMut;\n    const rebaseMutations = [];\n    if (this.HEAD && this.HEAD._updatedAt) {\n      const updatedAt = new Date(this.HEAD._updatedAt);\n      this.incoming.find((mut) => mut.timestamp && mut.timestamp < updatedAt) && (this.incoming = this.incoming.filter((mut) => mut.timestamp && mut.timestamp < updatedAt));\n    }\n    let protect = 0;\n    do {\n      if (this.HEAD) {\n        const HEAD = this.HEAD;\n        nextMut = HEAD._rev ? this.incoming.find((mut) => mut.previousRev === HEAD._rev) : void 0;\n      } else\n        nextMut = this.incoming.find((mut) => mut.appliesToMissingDocument());\n      if (nextMut) {\n        const applied = this.applyIncoming(nextMut);\n        if (mustRebase = mustRebase || applied, mustRebase && rebaseMutations.push(nextMut), protect++ > 10)\n          throw new Error(\n            `Mutator stuck flushing incoming mutations. Probably stuck here: ${JSON.stringify(\n              nextMut\n            )}`\n          );\n      }\n    } while (nextMut);\n    this.incoming.length > 0 && debug.enabled && debug(\n      \"Unable to apply mutations %s\",\n      this.incoming.map((mut) => mut.transactionId).join(\", \")\n    ), mustRebase && this.rebase(rebaseMutations);\n  }\n  // check current consistency state, update flag and invoke callback if needed\n  updateConsistencyFlag() {\n    const wasConsistent = this.isConsistent(), isConsistent = this.pending.length === 0 && this.submitted.length === 0 && this.incoming.length === 0;\n    isConsistent ? this.inconsistentAt = null : this.inconsistentAt || (this.inconsistentAt = /* @__PURE__ */ new Date()), wasConsistent != isConsistent && this.onConsistencyChanged && (debug(isConsistent ? \"Buffered document is inconsistent\" : \"Buffered document is consistent\"), this.onConsistencyChanged(isConsistent));\n  }\n  // apply an incoming patch that has been prequalified as the next in line for this document\n  applyIncoming(mut) {\n    if (!mut)\n      return !1;\n    if (!mut.transactionId)\n      throw new Error(\"Received incoming mutation without a transaction ID\");\n    if (debug(\n      \"Applying mutation %s -> %s to rev %s\",\n      mut.previousRev,\n      mut.resultRev,\n      this.HEAD && this.HEAD._rev\n    ), this.HEAD = mut.apply(this.HEAD), this.onRemoteMutation && this.onRemoteMutation(mut), this.incoming = this.incoming.filter((m) => m.transactionId !== mut.transactionId), this.hasUnresolvedMutations()) {\n      const needRebase = this.consumeUnresolved(mut.transactionId);\n      return debug.enabled && (debug(\n        `Incoming mutation ${mut.transactionId} appeared while there were pending or submitted local mutations`\n      ), debug(`Submitted txnIds: ${this.submitted.map((m) => m.transactionId).join(\", \")}`), debug(`Pending txnIds: ${this.pending.map((m) => m.transactionId).join(\", \")}`), debug(\"needRebase === %s\", needRebase)), needRebase;\n    }\n    return debug(\n      \"Remote mutation %s arrived w/o any pending or submitted local mutations\",\n      mut.transactionId\n    ), this.EDGE = this.HEAD, this.onMutation && this.onMutation({\n      mutation: mut,\n      document: this.EDGE,\n      remote: !0\n    }), !1;\n  }\n  /**\n   * Returns true if there are unresolved mutations between HEAD and EDGE, meaning we have\n   * mutations that are still waiting to be either submitted, or to be confirmed by the server.\n   *\n   * @returns true if there are unresolved mutations between HEAD and EDGE, false otherwise\n   */\n  hasUnresolvedMutations() {\n    return this.submitted.length > 0 || this.pending.length > 0;\n  }\n  /**\n   * When an incoming mutation is applied to HEAD, this is called to remove the mutation from\n   * the unresolved state. If the newly applied patch is the next upcoming unresolved mutation,\n   * no rebase is needed, but we might have the wrong idea about the ordering of mutations, so in\n   * that case we are given the flag `needRebase` to tell us that this mutation arrived out of\n   * order in terms of our optimistic version, so a rebase is needed.\n   *\n   * @param txnId - Transaction ID of the remote mutation\n   * @returns true if rebase is needed, false otherwise\n   */\n  consumeUnresolved(txnId) {\n    if (this.submitted.length === 0 && this.pending.length === 0)\n      return !1;\n    if (this.submitted.length !== 0) {\n      if (this.submitted[0].transactionId === txnId)\n        return debug(\n          \"Remote mutation %s matches upcoming submitted mutation, consumed from 'submitted' buffer\",\n          txnId\n        ), this.submitted.shift(), !1;\n    } else if (this.pending.length > 0 && this.pending[0].transactionId === txnId)\n      return debug(\n        \"Remote mutation %s matches upcoming pending mutation, consumed from 'pending' buffer\",\n        txnId\n      ), this.pending.shift(), !1;\n    return debug(\n      \"The mutation was not the upcoming mutation, scrubbing. Pending: %d, Submitted: %d\",\n      this.pending.length,\n      this.submitted.length\n    ), this.submitted = this.submitted.filter((mut) => mut.transactionId !== txnId), this.pending = this.pending.filter((mut) => mut.transactionId !== txnId), debug(\"After scrubbing: Pending: %d, Submitted: %d\", this.pending.length, this.submitted.length), !0;\n  }\n  pendingSuccessfullySubmitted(pendingTxnId) {\n    if (this.pending.length === 0)\n      return;\n    const first = this.pending[0];\n    if (first.transactionId === pendingTxnId) {\n      this.pending.shift(), this.submitted.push(first);\n      return;\n    }\n    let justSubmitted;\n    const stillPending = [];\n    this.pending.forEach((mutation) => {\n      if (mutation.transactionId === pendingTxnId) {\n        justSubmitted = mutation;\n        return;\n      }\n      stillPending.push(mutation);\n    }), justSubmitted && this.submitted.push(justSubmitted), this.pending = stillPending, this.rebase([]);\n  }\n  pendingFailed(pendingTxnId) {\n    this.pending = this.pending.filter((mutation) => mutation.transactionId !== pendingTxnId), this.rebase([]);\n  }\n  rebase(incomingMutations) {\n    const oldEdge = this.EDGE;\n    this.EDGE = Mutation.applyAll(this.HEAD, this.submitted.concat(this.pending)), oldEdge !== null && this.EDGE !== null && (oldEdge._rev = this.EDGE._rev), !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__(this.EDGE, oldEdge) && this.onRebase && this.onRebase(this.EDGE, incomingMutations, this.pending);\n  }\n}\nclass SquashingBuffer {\n  /**\n   * The document forming the basis of this squash\n   */\n  BASIS;\n  /**\n   * The document after the out-Mutation has been applied, but before the staged\n   * operations are committed.\n   */\n  PRESTAGE;\n  /**\n   * setOperations contain the latest set operation by path. If the set-operations are\n   * updating strings to new strings, they are rewritten as diffMatchPatch operations,\n   * any new set operations on the same paths overwrites any older set operations.\n   * Only set-operations assigning plain values to plain values gets optimized like this.\n   */\n  setOperations;\n  /**\n   * `documentPresent` is true whenever we know that the document must be present due\n   * to preceeding mutations. `false` implies that it may or may not already exist.\n   */\n  documentPresent;\n  /**\n   * The operations in the out-Mutation are not able to be optimized any further\n   */\n  out = [];\n  /**\n   * Staged mutation operations\n   */\n  staged;\n  constructor(doc) {\n    doc ? debug(\"Reset mutation buffer to rev %s\", doc._rev) : debug(\"Reset mutation buffer state to document being deleted\"), this.staged = [], this.setOperations = {}, this.documentPresent = !1, this.BASIS = doc, this.PRESTAGE = doc;\n  }\n  add(mut) {\n    mut.mutations.forEach((op) => this.addOperation(op));\n  }\n  hasChanges() {\n    return this.out.length > 0 || Object.keys(this.setOperations).length > 0;\n  }\n  /**\n   * Extracts the mutations in this buffer.\n   * After this is done, the buffer lifecycle is over and the client should\n   * create an new one with the new, updated BASIS.\n   *\n   * @param txnId - Transaction ID\n   * @returns A `Mutation` instance if we had outgoing mutations pending, null otherwise\n   */\n  purge(txnId) {\n    this.stashStagedOperations();\n    let result = null;\n    return this.out.length > 0 && (debug(\"Purged mutation buffer\"), result = new Mutation({\n      mutations: this.out,\n      resultRev: txnId,\n      transactionId: txnId\n    })), this.out = [], this.documentPresent = !1, result;\n  }\n  addOperation(op) {\n    if (op.patch && op.patch.set && \"id\" in op.patch && op.patch.id === this.PRESTAGE?._id && Object.keys(op.patch).length === 2) {\n      const setPatch = op.patch.set, unoptimizable = {};\n      for (const path of Object.keys(setPatch))\n        setPatch.hasOwnProperty(path) && (this.optimiseSetOperation(path, setPatch[path]) || (unoptimizable[path] = setPatch[path]));\n      Object.keys(unoptimizable).length > 0 && (debug(\"Unoptimizable set-operation detected, purging optimization buffer\"), this.staged.push({ patch: { id: this.PRESTAGE._id, set: unoptimizable } }), this.stashStagedOperations());\n      return;\n    }\n    if (op.createIfNotExists && this.PRESTAGE && op.createIfNotExists._id === this.PRESTAGE._id) {\n      this.documentPresent || (this.staged.push(op), this.documentPresent = !0, this.stashStagedOperations());\n      return;\n    }\n    debug(\"Unoptimizable mutation detected, purging optimization buffer\"), this.staged.push(op), this.stashStagedOperations();\n  }\n  /**\n     * Attempt to perform one single set operation in an optimised manner, return value\n     * reflects whether or not the operation could be performed.\n  \n     * @param path - The JSONPath to the set operation in question\n     * @param nextValue - The value to be set\n     * @returns True of optimized, false otherwise\n     */\n  optimiseSetOperation(path, nextValue) {\n    if (typeof nextValue == \"object\")\n      return !1;\n    const matches = extractWithPath(path, this.PRESTAGE);\n    if (matches.length !== 1)\n      return !1;\n    const match = matches[0];\n    if (typeof match.value == \"object\" || !this.PRESTAGE)\n      return !1;\n    let op = null;\n    if (match.value === nextValue)\n      op = null;\n    else if (typeof match.value == \"string\" && typeof nextValue == \"string\")\n      try {\n        const patch = (0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_6__.stringifyPatches)((0,_sanity_diff_match_patch__WEBPACK_IMPORTED_MODULE_6__.makePatches)(match.value, nextValue));\n        op = { patch: { id: this.PRESTAGE._id, diffMatchPatch: { [path]: patch } } };\n      } catch {\n        return !1;\n      }\n    else\n      op = { patch: { id: this.PRESTAGE._id, set: { [path]: nextValue } } };\n    const canonicalPath = arrayToJSONMatchPath(match.path);\n    return op ? this.setOperations[canonicalPath] = op : delete this.setOperations[canonicalPath], !0;\n  }\n  stashStagedOperations() {\n    const nextOps = [];\n    Object.keys(this.setOperations).forEach((key) => {\n      const op = this.setOperations[key];\n      op && nextOps.push(op);\n    }), nextOps.push(...this.staged), nextOps.length > 0 && (this.PRESTAGE = new Mutation({ mutations: nextOps }).apply(this.PRESTAGE), this.staged = [], this.setOperations = {}), this.out.push(...nextOps);\n  }\n  /**\n   * Rebases given the new base-document\n   *\n   * @param newBasis - New base document to rebase on\n   * @returns New \"edge\" document with buffered changes integrated\n   */\n  rebase(newBasis) {\n    return this.stashStagedOperations(), newBasis === null ? (this.out = [], this.BASIS = newBasis, this.PRESTAGE = newBasis, this.documentPresent = !1) : (this.BASIS = newBasis, this.out ? this.PRESTAGE = new Mutation({ mutations: this.out }).apply(this.BASIS) : this.PRESTAGE = this.BASIS), this.PRESTAGE;\n  }\n}\nconst ONE_MINUTE = 1e3 * 60;\nclass Commit {\n  mutations;\n  tries;\n  resolve;\n  reject;\n  constructor(mutations, { resolve, reject }) {\n    this.mutations = mutations, this.tries = 0, this.resolve = resolve, this.reject = reject;\n  }\n  apply(doc) {\n    return Mutation.applyAll(doc, this.mutations);\n  }\n  squash(doc) {\n    const result = Mutation.squash(doc, this.mutations);\n    return result.assignRandomTransactionId(), result;\n  }\n}\nconst mutReducerFn = (acc, mut) => acc.concat(mut.mutations);\nclass BufferedDocument {\n  mutations;\n  /**\n   * The Document we are wrapping\n   */\n  document;\n  /**\n   * The Document with local changes applied\n   */\n  LOCAL;\n  /**\n   * Commits that are waiting to be delivered to the server\n   */\n  commits;\n  /**\n   * Local mutations that are not scheduled to be committed yet\n   */\n  buffer;\n  /**\n   * Assignable event handler for when the buffered document applies a mutation\n   */\n  onMutation;\n  /**\n   * Assignable event handler for when a remote mutation happened\n   */\n  onRemoteMutation;\n  /**\n   * Assignable event handler for when the buffered document rebased\n   */\n  onRebase;\n  /**\n   * Assignable event handler for when the document is deleted\n   */\n  onDelete;\n  /**\n   * Assignable event handler for when the state of consistency changed\n   */\n  onConsistencyChanged;\n  /**\n   * Assignable event handler for when the buffered document should commit changes\n   */\n  commitHandler;\n  /**\n   * Whether or not we are currently commiting\n   */\n  committerRunning = !1;\n  constructor(doc) {\n    this.buffer = new SquashingBuffer(doc), this.document = new Document(doc), this.document.onMutation = (msg) => this.handleDocMutation(msg), this.document.onRemoteMutation = (mut) => this.onRemoteMutation && this.onRemoteMutation(mut), this.document.onRebase = (edge, remoteMutations, localMutations) => this.handleDocRebase(edge, remoteMutations, localMutations), this.document.onConsistencyChanged = (msg) => this.handleDocConsistencyChanged(msg), this.LOCAL = doc, this.mutations = [], this.commits = [];\n  }\n  // Used to reset the state of the local document model. If the model has been inconsistent\n  // for too long, it has probably missed a notification, and should reload the document from the server\n  reset(doc) {\n    doc ? debug(\"Document state reset to revision %s\", doc._rev) : debug(\"Document state reset to being deleted\"), this.document.reset(doc), this.rebase([], []), this.handleDocConsistencyChanged(this.document.isConsistent());\n  }\n  // Add a change to the buffer\n  add(mutation) {\n    this.onConsistencyChanged && this.onConsistencyChanged(!1), debug(\"Staged local mutation\"), this.buffer.add(mutation);\n    const oldLocal = this.LOCAL;\n    this.LOCAL = mutation.apply(this.LOCAL), this.onMutation && oldLocal !== this.LOCAL && (debug(\"onMutation fired\"), this.onMutation({\n      mutation,\n      document: this.LOCAL,\n      remote: !1\n    }), this.LOCAL === null && this.onDelete && this.onDelete(this.LOCAL));\n  }\n  // Call when a mutation arrives from Sanity\n  arrive(mutation) {\n    if (debug(\"Remote mutation arrived %s -> %s\", mutation.previousRev, mutation.resultRev), mutation.previousRev === mutation.resultRev)\n      throw new Error(\n        `Mutation ${mutation.transactionId} has previousRev === resultRev (${mutation.previousRev})`\n      );\n    return this.document.arrive(mutation);\n  }\n  // Submit all mutations in the buffer to be committed\n  commit() {\n    return new Promise((resolve, reject) => {\n      if (!this.buffer.hasChanges()) {\n        resolve();\n        return;\n      }\n      debug(\"Committing local changes\");\n      const pendingMutations = this.buffer.purge();\n      this.commits.push(new Commit(pendingMutations ? [pendingMutations] : [], { resolve, reject })), this.buffer = new SquashingBuffer(this.LOCAL), this.performCommits();\n    });\n  }\n  // Starts the committer that will try to committ all staged commits to the database\n  // by calling the commitHandler. Will keep running until all commits are successfully\n  // committed.\n  performCommits() {\n    if (!this.commitHandler)\n      throw new Error(\"No commitHandler configured for this BufferedDocument\");\n    this.committerRunning || this._cycleCommitter();\n  }\n  // TODO: Error handling, right now retries after every error\n  _cycleCommitter() {\n    const commit = this.commits.shift();\n    if (!commit) {\n      this.committerRunning = !1;\n      return;\n    }\n    this.committerRunning = !0;\n    const squashed = commit.squash(this.LOCAL), docResponder = this.document.stage(squashed, !0), responder = {\n      success: () => {\n        debug(\"Commit succeeded\"), docResponder.success(), commit.resolve(), this._cycleCommitter();\n      },\n      failure: () => {\n        debug(\"Commit failed\"), commit.tries += 1, this.LOCAL !== null && this.commits.unshift(commit), docResponder.failure(), commit.tries < 200 && setTimeout(() => this._cycleCommitter(), Math.min(commit.tries * 1e3, ONE_MINUTE));\n      },\n      cancel: (error) => {\n        this.commits.forEach((comm) => comm.reject(error)), this.commits = [], this.reset(this.document.HEAD), this.buffer = new SquashingBuffer(this.LOCAL), this.committerRunning = !1;\n      }\n    };\n    debug(\"Posting commit\"), this.commitHandler && this.commitHandler({\n      mutation: squashed,\n      success: responder.success,\n      failure: responder.failure,\n      cancel: responder.cancel\n    });\n  }\n  handleDocRebase(edge, remoteMutations, localMutations) {\n    this.rebase(remoteMutations, localMutations);\n  }\n  handleDocumentDeleted() {\n    debug(\"Document deleted\"), this.LOCAL !== null && this.onDelete && this.onDelete(this.LOCAL), this.commits = [], this.mutations = [];\n  }\n  handleDocMutation(msg) {\n    if (this.commits.length === 0 && !this.buffer.hasChanges()) {\n      debug(\"Document mutated from remote with no local changes\"), this.LOCAL = this.document.EDGE, this.buffer = new SquashingBuffer(this.LOCAL), this.onMutation && this.onMutation(msg);\n      return;\n    }\n    debug(\"Document mutated from remote with local changes\"), this.document.EDGE === null && this.handleDocumentDeleted(), this.rebase([msg.mutation], []);\n  }\n  rebase(remoteMutations, localMutations) {\n    debug(\"Rebasing document\"), this.document.EDGE === null && this.handleDocumentDeleted();\n    const oldLocal = this.LOCAL;\n    this.LOCAL = this.commits.reduce((doc, commit) => commit.apply(doc), this.document.EDGE), this.LOCAL = this.buffer.rebase(this.LOCAL), oldLocal !== null && this.LOCAL !== null && (oldLocal._rev = this.LOCAL._rev), !lodash_isEqual_js__WEBPACK_IMPORTED_MODULE_0__(this.LOCAL, oldLocal) && this.onRebase && this.onRebase(\n      this.LOCAL,\n      remoteMutations.reduce(mutReducerFn, []),\n      localMutations.reduce(mutReducerFn, [])\n    );\n  }\n  handleDocConsistencyChanged(isConsistent) {\n    if (!this.onConsistencyChanged)\n      return;\n    const hasLocalChanges = this.commits.length > 0 || this.buffer.hasChanges();\n    isConsistent && !hasLocalChanges && this.onConsistencyChanged(!0), isConsistent || this.onConsistencyChanged(!1);\n  }\n}\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrbXV0YXRvckAzLjk5LjBfQHR5cGVzK3JlYWN0QDE4LjMuMjQvbm9kZV9tb2R1bGVzL0BzYW5pdHkvbXV0YXRvci9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDWjtBQUNZO0FBQzJFO0FBQ25GO0FBQ0E7QUFDSTtBQUNJO0FBQ3hDLGNBQWMsa0NBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQixjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLDhFQUE4RSxJQUFJLEtBQUssU0FBUztBQUNoRztBQUNBLDhGQUE4RixRQUFRLFNBQVMsUUFBUTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0cscUNBQXFDO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWSxNQUFNLE9BQU87QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUksMkJBQTJCLG9CQUFvQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCLGtCQUFrQiw4QkFBOEI7QUFDdEc7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JELDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUMsNEJBQTRCLElBQUk7QUFDcEYsd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4Qyx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0EsdUVBQXVFLFdBQVcsaURBQWlELFNBQVMsaUNBQWlDLFVBQVU7QUFDdkw7QUFDQTtBQUNBLDBCQUEwQixXQUFXLFFBQVEsV0FBVztBQUN4RDtBQUNBLGlDQUFpQywwQkFBMEIsbUJBQW1CLDJCQUEyQixFQUFFLGNBQWMsRUFBRSxJQUFJO0FBQy9ILG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9EQUFvRDtBQUNyRTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGlCQUFpQiw4Q0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLG9HQUFvRyx5QkFBeUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLGtDQUFrQyxtQkFBbUIsbUNBQW1DLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQkFBa0I7QUFDOUUsU0FBUyw4Q0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGtDQUFrQztBQUN6RjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0VBQVksb0JBQW9CLDJCQUEyQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvRUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFHO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZSwwQ0FBRztBQUNsQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHO0FBQ0EsdURBQXVELGtCQUFrQjtBQUN6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVFQUF1RSw2QkFBNkI7QUFDcEc7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkRBQTZEO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLGlHQUFpRztBQUNqRztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saURBQWlELHVCQUF1QjtBQUN4RSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEYsS0FBSyxtR0FBbUcsbUNBQW1DO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFFBQVEsaUNBQWlDLFNBQVM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyTkFBMk4sOENBQU87QUFDbE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0U7QUFDRiIsInNvdXJjZXMiOlsiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBzYW5pdHkrbXV0YXRvckAzLjk5LjBfQHR5cGVzK3JlYWN0QDE4LjMuMjRcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcbXV0YXRvclxcbGliXFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzRXF1YWwgZnJvbSBcImxvZGFzaC9pc0VxdWFsLmpzXCI7XG5pbXBvcnQgZGVidWdJdCBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VQYXRjaCBhcyBwYXJzZVBhdGNoJDEsIGFwcGx5UGF0Y2hlcywgc3RyaW5naWZ5UGF0Y2hlcywgbWFrZVBhdGNoZXMgfSBmcm9tIFwiQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoXCI7XG5pbXBvcnQgbWF4IGZyb20gXCJsb2Rhc2gvbWF4LmpzXCI7XG5pbXBvcnQgbWluIGZyb20gXCJsb2Rhc2gvbWluLmpzXCI7XG5pbXBvcnQgeyB1dWlkIH0gZnJvbSBcIkBzYW5pdHkvdXVpZFwiO1xuaW1wb3J0IGNvbXBhY3QgZnJvbSBcImxvZGFzaC9jb21wYWN0LmpzXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnSXQoXCJtdXRhdG9yLWRvY3VtZW50XCIpO1xuY2xhc3MgSW1tdXRhYmxlQWNjZXNzb3Ige1xuICBfdmFsdWU7XG4gIHBhdGg7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXRoKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZSwgdGhpcy5wYXRoID0gcGF0aCB8fCBbXTtcbiAgfVxuICBjb250YWluZXJUeXBlKCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX3ZhbHVlKSA/IFwiYXJyYXlcIiA6IHRoaXMuX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aGlzLl92YWx1ZSA9PSBcIm9iamVjdFwiID8gXCJvYmplY3RcIiA6IFwicHJpbWl0aXZlXCI7XG4gIH1cbiAgLy8gQ29tbW9uIHJlYWRlciwgc3VwcG9ydGVkIGJ5IGFsbCBjb250YWluZXJzXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgLy8gQXJyYXkgcmVhZGVyXG4gIGxlbmd0aCgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29uJ3QgcmV0dXJuIGxlbmd0aCBvZiBub24taW5kZXhhYmxlIF92YWx1ZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUubGVuZ3RoO1xuICB9XG4gIGdldEluZGV4KGkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLl92YWx1ZSkgPyBpID49IHRoaXMubGVuZ3RoKCkgPyBudWxsIDogbmV3IEltbXV0YWJsZUFjY2Vzc29yKHRoaXMuX3ZhbHVlW2ldLCB0aGlzLnBhdGguY29uY2F0KGkpKSA6ICExO1xuICB9XG4gIC8vIE9iamVjdCByZWFkZXJcbiAgaGFzQXR0cmlidXRlKGtleSkge1xuICAgIHJldHVybiBpc1JlY29yZCQxKHRoaXMuX3ZhbHVlKSA/IHRoaXMuX3ZhbHVlLmhhc093blByb3BlcnR5KGtleSkgOiAhMTtcbiAgfVxuICBhdHRyaWJ1dGVLZXlzKCkge1xuICAgIHJldHVybiBpc1JlY29yZCQxKHRoaXMuX3ZhbHVlKSA/IE9iamVjdC5rZXlzKHRoaXMuX3ZhbHVlKSA6IFtdO1xuICB9XG4gIGdldEF0dHJpYnV0ZShrZXkpIHtcbiAgICBpZiAoIWlzUmVjb3JkJDEodGhpcy5fdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QXR0cmlidXRlIG9ubHkgYXBwbGllcyB0byBwbGFpbiBvYmplY3RzXCIpO1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShrZXkpID8gbmV3IEltbXV0YWJsZUFjY2Vzc29yKHRoaXMuX3ZhbHVlW2tleV0sIHRoaXMucGF0aC5jb25jYXQoa2V5KSkgOiBudWxsO1xuICB9XG4gIC8vIENvbW1vbiB3cml0ZXIsIHN1cHBvcnRlZCBieSBhbGwgY29udGFpbmVyc1xuICBzZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRoaXMuX3ZhbHVlID8gdGhpcyA6IG5ldyBJbW11dGFibGVBY2Nlc3Nvcih2YWx1ZSwgdGhpcy5wYXRoKTtcbiAgfVxuICAvLyBhcnJheSB3cml0ZXIgaW50ZXJmYWNlXG4gIHNldEluZGV4KGksIHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3ZhbHVlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNldEluZGV4IG9ubHkgYXBwbGllcyB0byBhcnJheXNcIik7XG4gICAgaWYgKE9iamVjdC5pcyh2YWx1ZSwgdGhpcy5fdmFsdWVbaV0pKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gdGhpcy5fdmFsdWUuc2xpY2UoKTtcbiAgICByZXR1cm4gbmV4dFZhbHVlW2ldID0gdmFsdWUsIG5ldyBJbW11dGFibGVBY2Nlc3NvcihuZXh0VmFsdWUsIHRoaXMucGF0aCk7XG4gIH1cbiAgc2V0SW5kZXhBY2Nlc3NvcihpLCBhY2Nlc3Nvcikge1xuICAgIHJldHVybiB0aGlzLnNldEluZGV4KGksIGFjY2Vzc29yLmdldCgpKTtcbiAgfVxuICB1bnNldEluZGljZXMoaW5kaWNlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl92YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnNldEluZGljZXMgb25seSBhcHBsaWVzIHRvIGFycmF5c1wiKTtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLl92YWx1ZS5sZW5ndGgsIG5leHRWYWx1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICBpbmRpY2VzLmluZGV4T2YoaSkgPT09IC0xICYmIG5leHRWYWx1ZS5wdXNoKHRoaXMuX3ZhbHVlW2ldKTtcbiAgICByZXR1cm4gbmV3IEltbXV0YWJsZUFjY2Vzc29yKG5leHRWYWx1ZSwgdGhpcy5wYXRoKTtcbiAgfVxuICBpbnNlcnRJdGVtc0F0KHBvcywgaXRlbXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5zZXJ0SXRlbXNBdCBvbmx5IGFwcGxpZXMgdG8gYXJyYXlzXCIpO1xuICAgIGxldCBuZXh0VmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCA9PT0gMCAmJiBwb3MgPT09IDAgPyBuZXh0VmFsdWUgPSBpdGVtcyA6IG5leHRWYWx1ZSA9IHRoaXMuX3ZhbHVlLnNsaWNlKDAsIHBvcykuY29uY2F0KGl0ZW1zKS5jb25jYXQodGhpcy5fdmFsdWUuc2xpY2UocG9zKSksIG5ldyBJbW11dGFibGVBY2Nlc3NvcihuZXh0VmFsdWUsIHRoaXMucGF0aCk7XG4gIH1cbiAgLy8gT2JqZWN0IHdyaXRlciBpbnRlcmZhY2VcbiAgc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzUmVjb3JkJDEodGhpcy5fdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNldCBhdHRyaWJ1dGUgb2Ygbm9uLW9iamVjdCBjb250YWluZXJcIik7XG4gICAgaWYgKE9iamVjdC5pcyh2YWx1ZSwgdGhpcy5fdmFsdWVba2V5XSkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92YWx1ZSwgeyBba2V5XTogdmFsdWUgfSk7XG4gICAgcmV0dXJuIG5ldyBJbW11dGFibGVBY2Nlc3NvcihuZXh0VmFsdWUsIHRoaXMucGF0aCk7XG4gIH1cbiAgc2V0QXR0cmlidXRlQWNjZXNzb3Ioa2V5LCBhY2Nlc3Nvcikge1xuICAgIHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZShrZXksIGFjY2Vzc29yLmdldCgpKTtcbiAgfVxuICB1bnNldEF0dHJpYnV0ZShrZXkpIHtcbiAgICBpZiAoIWlzUmVjb3JkJDEodGhpcy5fdmFsdWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHVuc2V0IGF0dHJpYnV0ZSBvZiBub24tb2JqZWN0IGNvbnRhaW5lclwiKTtcbiAgICBjb25zdCBuZXh0VmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl92YWx1ZSk7XG4gICAgcmV0dXJuIGRlbGV0ZSBuZXh0VmFsdWVba2V5XSwgbmV3IEltbXV0YWJsZUFjY2Vzc29yKG5leHRWYWx1ZSwgdGhpcy5wYXRoKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNSZWNvcmQkMSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBpc1JlY29yZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCI7XG59XG5jb25zdCBJU19ET1RUQUJMRSA9IC9eW2Etel8kXSsvO1xuZnVuY3Rpb24gYXJyYXlUb0pTT05NYXRjaFBhdGgocGF0aEFycmF5KSB7XG4gIGxldCBwYXRoID0gXCJcIjtcbiAgcmV0dXJuIHBhdGhBcnJheS5mb3JFYWNoKChzZWdtZW50LCBpbmRleCkgPT4ge1xuICAgIHBhdGggKz0gc3RyaW5naWZ5U2VnbWVudChzZWdtZW50LCBpbmRleCA9PT0gMCk7XG4gIH0pLCBwYXRoO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U2VnbWVudChzZWdtZW50LCBoYXNMZWFkaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBgWyR7c2VnbWVudH1dYDtcbiAgaWYgKGlzUmVjb3JkKHNlZ21lbnQpKSB7XG4gICAgY29uc3Qgc2VnID0gc2VnbWVudDtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2VnbWVudCkubWFwKChrZXkpID0+IGlzUHJpbWl0aXZlVmFsdWUoc2VnW2tleV0pID8gYFske2tleX09PVwiJHtzZWdba2V5XX1cIl1gIDogXCJcIikuam9pbihcIlwiKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHNlZ21lbnQgPT0gXCJzdHJpbmdcIiAmJiBJU19ET1RUQUJMRS50ZXN0KHNlZ21lbnQpID8gaGFzTGVhZGluZyA/IHNlZ21lbnQgOiBgLiR7c2VnbWVudH1gIDogYFsnJHtzZWdtZW50fSddYDtcbn1cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVmFsdWUodmFsKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiAhMDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjZW5kJDEodGFpbCkge1xuICBjb25zdCBbaGVhZCwgbmV3VGFpbF0gPSBzcGxpdElmUGF0aCh0YWlsKTtcbiAgaWYgKCFoZWFkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWQgY2Fubm90IGJlIG51bGxcIik7XG4gIHJldHVybiBzcHJlYWRJZlVuaW9uSGVhZChoZWFkLCBuZXdUYWlsKTtcbn1cbmZ1bmN0aW9uIHNwbGl0SWZQYXRoKHRhaWwpIHtcbiAgaWYgKHRhaWwudHlwZSAhPT0gXCJwYXRoXCIpXG4gICAgcmV0dXJuIFt0YWlsLCBudWxsXTtcbiAgY29uc3Qgbm9kZXMgPSB0YWlsLm5vZGVzO1xuICByZXR1cm4gbm9kZXMubGVuZ3RoID09PSAwID8gW251bGwsIG51bGxdIDogbm9kZXMubGVuZ3RoID09PSAxID8gW25vZGVzWzBdLCBudWxsXSA6IFtub2Rlc1swXSwgeyB0eXBlOiBcInBhdGhcIiwgbm9kZXM6IG5vZGVzLnNsaWNlKDEpIH1dO1xufVxuZnVuY3Rpb24gY29uY2F0UGF0aHMocGF0aDEsIHBhdGgyKSB7XG4gIGlmICghcGF0aDEgJiYgIXBhdGgyKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBub2RlczEgPSBwYXRoMSA/IHBhdGgxLm5vZGVzIDogW10sIG5vZGVzMiA9IHBhdGgyID8gcGF0aDIubm9kZXMgOiBbXTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBhdGhcIixcbiAgICBub2Rlczogbm9kZXMxLmNvbmNhdChub2RlczIpXG4gIH07XG59XG5mdW5jdGlvbiBzcHJlYWRJZlVuaW9uSGVhZChoZWFkLCB0YWlsKSB7XG4gIHJldHVybiBoZWFkLnR5cGUgIT09IFwidW5pb25cIiA/IFtbaGVhZCwgdGFpbF1dIDogaGVhZC5ub2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcInBhdGhcIikge1xuICAgICAgY29uc3QgW3N1YkhlYWQsIHN1YlRhaWxdID0gc3BsaXRJZlBhdGgobm9kZSk7XG4gICAgICByZXR1cm4gW3N1YkhlYWQsIGNvbmNhdFBhdGhzKHN1YlRhaWwsIHRhaWwpXTtcbiAgICB9XG4gICAgcmV0dXJuIFtub2RlLCB0YWlsXTtcbiAgfSk7XG59XG5jb25zdCBkaWdpdENoYXIgPSAvWzAtOV0vLCBhdHRyaWJ1dGVDaGFyTWF0Y2hlciA9IC9eW2EtekEtWjAtOV9dJC8sIGF0dHJpYnV0ZUZpcnN0Q2hhck1hdGNoZXIgPSAvXlthLXpBLVpfXSQvLCBzeW1ib2xzID0ge1xuICAvLyBOT1RFOiBUaGVzZSBhcmUgY29tcGFyZWQgYWdhaW5zdCBpbiBvcmRlciBvZiBkZWZpbml0aW9uLFxuICAvLyB0aHVzICc9PScgbXVzdCBjb21lIGJlZm9yZSAnPScsICc+PScgYmVmb3JlICc+JywgZXRjLlxuICBvcGVyYXRvcjogW1wiLi5cIiwgXCIuXCIsIFwiLFwiLCBcIjpcIiwgXCI/XCJdLFxuICBjb21wYXJhdG9yOiBbXCI+PVwiLCBcIjw9XCIsIFwiPFwiLCBcIj5cIiwgXCI9PVwiLCBcIiE9XCJdLFxuICBrZXl3b3JkOiBbXCIkXCIsIFwiQFwiXSxcbiAgYm9vbGVhbjogW1widHJ1ZVwiLCBcImZhbHNlXCJdLFxuICBwYXJlbjogW1wiW1wiLCBcIl1cIl1cbn0sIHN5bWJvbENsYXNzZXMgPSBPYmplY3Qua2V5cyhzeW1ib2xzKTtcbmNsYXNzIFRva2VuaXplciB7XG4gIHNvdXJjZTtcbiAgaTtcbiAgbGVuZ3RoO1xuICB0b2tlbml6ZXJzO1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBwYXRoLCB0aGlzLmxlbmd0aCA9IHBhdGgubGVuZ3RoLCB0aGlzLmkgPSAwLCB0aGlzLnRva2VuaXplcnMgPSBbXG4gICAgICB0aGlzLnRva2VuaXplU3ltYm9sLFxuICAgICAgdGhpcy50b2tlbml6ZUlkZW50aWZpZXIsXG4gICAgICB0aGlzLnRva2VuaXplTnVtYmVyLFxuICAgICAgdGhpcy50b2tlbml6ZVF1b3RlZFxuICAgIF0ubWFwKChmbikgPT4gZm4uYmluZCh0aGlzKSk7XG4gIH1cbiAgdG9rZW5pemUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yICg7ICF0aGlzLkVPRigpOyApIHtcbiAgICAgIHRoaXMuY2hvbXBXaGl0ZXNwYWNlKCk7XG4gICAgICBsZXQgdG9rZW4gPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLnRva2VuaXplcnMuc29tZSgodG9rZW5pemVyKSA9PiAodG9rZW4gPSB0b2tlbml6ZXIoKSwgISF0b2tlbikpIHx8ICF0b2tlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRva2VucyBpbiBqc29ucGF0aCAnJHt0aGlzLnNvdXJjZX0nIEAgJHt0aGlzLml9YCk7XG4gICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdGFrZVdoaWxlKGZuKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yICg7ICF0aGlzLkVPRigpOyApIHtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gZm4odGhpcy5zb3VyY2VbdGhpcy5pXSk7XG4gICAgICBpZiAobmV4dENoYXIgPT09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgcmVzdWx0ICs9IG5leHRDaGFyLCB0aGlzLmkrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaSA9PT0gc3RhcnQgPyBudWxsIDogcmVzdWx0O1xuICB9XG4gIEVPRigpIHtcbiAgICByZXR1cm4gdGhpcy5pID49IHRoaXMubGVuZ3RoO1xuICB9XG4gIHBlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuRU9GKCkgPyBudWxsIDogdGhpcy5zb3VyY2VbdGhpcy5pXTtcbiAgfVxuICBjb25zdW1lKHN0cikge1xuICAgIGlmICh0aGlzLmkgKyBzdHIubGVuZ3RoID4gdGhpcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7c3RyfSBhdCBlbmQgb2YganNvbnBhdGhgKTtcbiAgICBpZiAoc3RyID09PSB0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmksIHRoaXMuaSArIHN0ci5sZW5ndGgpKVxuICAgICAgdGhpcy5pICs9IHN0ci5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBcIiR7c3RyfVwiLCBidXQgc291cmNlIGNvbnRhaW5lZCBcIiR7dGhpcy5zb3VyY2Uuc2xpY2UoKX1gKTtcbiAgfVxuICAvLyBUcmllcyB0byBtYXRjaCB0aGUgdXBjb21pbmcgYml0IG9mIHN0cmluZyB3aXRoIHRoZSBwcm92aWRlZCBzdHJpbmcuIElmIGl0IG1hdGNoZXMsIHJldHVybnNcbiAgLy8gdGhlIHN0cmluZywgdGhlbiBhZHZhbmNlcyB0aGUgcmVhZCBwb2ludGVyIHRvIHRoZSBuZXh0IGJpdC4gSWYgbm90LCByZXR1cm5zIG51bGwgYW5kIG5vdGhpbmdcbiAgLy8gaGFwcGVucy5cbiAgdHJ5Q29uc3VtZShzdHIpIHtcbiAgICBpZiAodGhpcy5pICsgc3RyLmxlbmd0aCA+IHRoaXMubGVuZ3RoKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHN0ciA9PT0gdGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5pLCB0aGlzLmkgKyBzdHIubGVuZ3RoKSkge1xuICAgICAgaWYgKHN0clswXS5tYXRjaChhdHRyaWJ1dGVDaGFyTWF0Y2hlcikgJiYgdGhpcy5sZW5ndGggPiB0aGlzLmkgKyBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGhpcy5zb3VyY2VbdGhpcy5pICsgc3RyLmxlbmd0aF07XG4gICAgICAgIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhci5tYXRjaChhdHRyaWJ1dGVDaGFyTWF0Y2hlcikpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pICs9IHN0ci5sZW5ndGgsIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2hvbXBXaGl0ZXNwYWNlKCkge1xuICAgIHRoaXMudGFrZVdoaWxlKChjaGFyKSA9PiBjaGFyID09PSBcIiBcIiA/IFwiXCIgOiBudWxsKTtcbiAgfVxuICB0b2tlbml6ZVF1b3RlZCgpIHtcbiAgICBjb25zdCBxdW90ZSA9IHRoaXMucGVlaygpO1xuICAgIGlmIChxdW90ZSA9PT0gXCInXCIgfHwgcXVvdGUgPT09ICdcIicpIHtcbiAgICAgIHRoaXMuY29uc3VtZShxdW90ZSk7XG4gICAgICBsZXQgZXNjYXBlID0gITE7XG4gICAgICBjb25zdCBpbm5lciA9IHRoaXMudGFrZVdoaWxlKChjaGFyKSA9PiBlc2NhcGUgPyAoZXNjYXBlID0gITEsIGNoYXIpIDogY2hhciA9PT0gXCJcXFxcXCIgPyAoZXNjYXBlID0gITAsIFwiXCIpIDogY2hhciAhPSBxdW90ZSA/IGNoYXIgOiBudWxsKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN1bWUocXVvdGUpLCB7XG4gICAgICAgIHR5cGU6IFwicXVvdGVkXCIsXG4gICAgICAgIHZhbHVlOiBpbm5lcixcbiAgICAgICAgcXVvdGU6IHF1b3RlID09PSAnXCInID8gXCJkb3VibGVcIiA6IFwic2luZ2xlXCJcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRva2VuaXplSWRlbnRpZmllcigpIHtcbiAgICBsZXQgZmlyc3QgPSAhMDtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy50YWtlV2hpbGUoKGNoYXIpID0+IGZpcnN0ID8gKGZpcnN0ID0gITEsIGNoYXIubWF0Y2goYXR0cmlidXRlRmlyc3RDaGFyTWF0Y2hlcikgPyBjaGFyIDogbnVsbCkgOiBjaGFyLm1hdGNoKGF0dHJpYnV0ZUNoYXJNYXRjaGVyKSA/IGNoYXIgOiBudWxsKTtcbiAgICByZXR1cm4gaWRlbnRpZmllciAhPT0gbnVsbCA/IHtcbiAgICAgIHR5cGU6IFwiaWRlbnRpZmllclwiLFxuICAgICAgbmFtZTogaWRlbnRpZmllclxuICAgIH0gOiBudWxsO1xuICB9XG4gIHRva2VuaXplTnVtYmVyKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pO1xuICAgIGxldCBkb3RTZWVuID0gITEsIGRpZ2l0U2VlbiA9ICExLCBuZWdhdGl2ZSA9ICExO1xuICAgIHRoaXMucGVlaygpID09PSBcIi1cIiAmJiAobmVnYXRpdmUgPSAhMCwgdGhpcy5jb25zdW1lKFwiLVwiKSk7XG4gICAgY29uc3QgbnVtYmVyID0gdGhpcy50YWtlV2hpbGUoKGNoYXIpID0+IGNoYXIgPT09IFwiLlwiICYmICFkb3RTZWVuICYmIGRpZ2l0U2VlbiA/IChkb3RTZWVuID0gITAsIGNoYXIpIDogKGRpZ2l0U2VlbiA9ICEwLCBjaGFyLm1hdGNoKGRpZ2l0Q2hhcikgPyBjaGFyIDogbnVsbCkpO1xuICAgIHJldHVybiBudW1iZXIgIT09IG51bGwgPyB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgdmFsdWU6IG5lZ2F0aXZlID8gLW51bWJlciA6ICtudW1iZXIsXG4gICAgICByYXc6IG5lZ2F0aXZlID8gYC0ke251bWJlcn1gIDogbnVtYmVyXG4gICAgfSA6ICh0aGlzLmkgPSBzdGFydCwgbnVsbCk7XG4gIH1cbiAgdG9rZW5pemVTeW1ib2woKSB7XG4gICAgZm9yIChjb25zdCBzeW1ib2xDbGFzcyBvZiBzeW1ib2xDbGFzc2VzKSB7XG4gICAgICBjb25zdCBzeW1ib2wgPSBzeW1ib2xzW3N5bWJvbENsYXNzXS5maW5kKChwYXR0ZXJuKSA9PiB0aGlzLnRyeUNvbnN1bWUocGF0dGVybikpO1xuICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBzeW1ib2xDbGFzcyxcbiAgICAgICAgICBzeW1ib2xcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRva2VuaXplKGpzb25wYXRoKSB7XG4gIHJldHVybiBuZXcgVG9rZW5pemVyKGpzb25wYXRoKS50b2tlbml6ZSgpO1xufVxuY2xhc3MgUGFyc2VyIHtcbiAgdG9rZW5zO1xuICBsZW5ndGg7XG4gIGk7XG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICB0aGlzLnRva2VucyA9IHRva2VuaXplKHBhdGgpLCB0aGlzLmxlbmd0aCA9IHRoaXMudG9rZW5zLmxlbmd0aCwgdGhpcy5pID0gMDtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBhdGgoKTtcbiAgfVxuICBFT0YoKSB7XG4gICAgcmV0dXJuIHRoaXMuaSA+PSB0aGlzLmxlbmd0aDtcbiAgfVxuICAvLyBMb29rIGF0IHVwY29taW5nIHRva2VuXG4gIHBlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuRU9GKCkgPyBudWxsIDogdGhpcy50b2tlbnNbdGhpcy5pXTtcbiAgfVxuICBjb25zdW1lKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVlaygpO1xuICAgIHJldHVybiB0aGlzLmkgKz0gMSwgcmVzdWx0O1xuICB9XG4gIC8vIFJldHVybiBuZXh0IHRva2VuIGlmIGl0IG1hdGNoZXMgdGhlIHBhdHRlcm5cbiAgcHJvYmUocGF0dGVybikge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5wZWVrKCk7XG4gICAgaWYgKCF0b2tlbilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHJlY29yZCA9IHRva2VuO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwYXR0ZXJuKS5ldmVyeSgoa2V5KSA9PiBrZXkgaW4gdG9rZW4gJiYgcGF0dGVybltrZXldID09PSByZWNvcmRba2V5XSkgPyB0b2tlbiA6IG51bGw7XG4gIH1cbiAgLy8gUmV0dXJuIGFuZCBjb25zdW1lIG5leHQgdG9rZW4gaWYgaXQgbWF0Y2hlcyB0aGUgcGF0dGVyblxuICBtYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvYmUocGF0dGVybikgPyB0aGlzLmNvbnN1bWUoKSA6IG51bGw7XG4gIH1cbiAgcGFyc2VBdHRyaWJ1dGUoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLm1hdGNoKHsgdHlwZTogXCJpZGVudGlmaWVyXCIgfSk7XG4gICAgaWYgKHRva2VuICYmIHRva2VuLnR5cGUgPT09IFwiaWRlbnRpZmllclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhdHRyaWJ1dGVcIixcbiAgICAgICAgbmFtZTogdG9rZW4ubmFtZVxuICAgICAgfTtcbiAgICBjb25zdCBxdW90ZWQgPSB0aGlzLm1hdGNoKHsgdHlwZTogXCJxdW90ZWRcIiwgcXVvdGU6IFwic2luZ2xlXCIgfSk7XG4gICAgcmV0dXJuIHF1b3RlZCAmJiBxdW90ZWQudHlwZSA9PT0gXCJxdW90ZWRcIiA/IHtcbiAgICAgIHR5cGU6IFwiYXR0cmlidXRlXCIsXG4gICAgICBuYW1lOiBxdW90ZWQudmFsdWUgfHwgXCJcIlxuICAgIH0gOiBudWxsO1xuICB9XG4gIHBhcnNlQWxpYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goeyB0eXBlOiBcImtleXdvcmRcIiwgc3ltYm9sOiBcIkBcIiB9KSB8fCB0aGlzLm1hdGNoKHsgdHlwZTogXCJrZXl3b3JkXCIsIHN5bWJvbDogXCIkXCIgfSkgPyB7XG4gICAgICB0eXBlOiBcImFsaWFzXCIsXG4gICAgICB0YXJnZXQ6IFwic2VsZlwiXG4gICAgfSA6IG51bGw7XG4gIH1cbiAgcGFyc2VOdW1iZXIoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLm1hdGNoKHsgdHlwZTogXCJudW1iZXJcIiB9KTtcbiAgICByZXR1cm4gdG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gXCJudW1iZXJcIiA/IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICB9IDogbnVsbDtcbiAgfVxuICBwYXJzZU51bWJlclZhbHVlKCkge1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTnVtYmVyKCk7XG4gICAgcmV0dXJuIGV4cHIgPyBleHByLnZhbHVlIDogbnVsbDtcbiAgfVxuICBwYXJzZVNsaWNlU2VsZWN0b3IoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmksIHJhbmdlU3RhcnQgPSB0aGlzLnBhcnNlTnVtYmVyVmFsdWUoKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goeyB0eXBlOiBcIm9wZXJhdG9yXCIsIHN5bWJvbDogXCI6XCIgfSkpXG4gICAgICByZXR1cm4gcmFuZ2VTdGFydCA9PT0gbnVsbCA/ICh0aGlzLmkgPSBzdGFydCwgbnVsbCkgOiB7IHR5cGU6IFwiaW5kZXhcIiwgdmFsdWU6IHJhbmdlU3RhcnQgfTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICBzdGFydDogcmFuZ2VTdGFydCxcbiAgICAgIGVuZDogdGhpcy5wYXJzZU51bWJlclZhbHVlKClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm1hdGNoKHsgdHlwZTogXCJvcGVyYXRvclwiLCBzeW1ib2w6IFwiOlwiIH0pICYmIChyZXN1bHQuc3RlcCA9IHRoaXMucGFyc2VOdW1iZXJWYWx1ZSgpKSwgcmVzdWx0LnN0YXJ0ID09PSBudWxsICYmIHJlc3VsdC5lbmQgPT09IG51bGwgPyAodGhpcy5pID0gc3RhcnQsIG51bGwpIDogcmVzdWx0O1xuICB9XG4gIHBhcnNlVmFsdWVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBdHRyaWJ1dGUoKSB8fCB0aGlzLnBhcnNlU2xpY2VTZWxlY3RvcigpO1xuICB9XG4gIHBhcnNlTGl0ZXJhbFZhbHVlKCkge1xuICAgIGNvbnN0IGxpdGVyYWxTdHJpbmcgPSB0aGlzLm1hdGNoKHsgdHlwZTogXCJxdW90ZWRcIiwgcXVvdGU6IFwiZG91YmxlXCIgfSk7XG4gICAgaWYgKGxpdGVyYWxTdHJpbmcgJiYgbGl0ZXJhbFN0cmluZy50eXBlID09PSBcInF1b3RlZFwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgdmFsdWU6IGxpdGVyYWxTdHJpbmcudmFsdWUgfHwgXCJcIlxuICAgICAgfTtcbiAgICBjb25zdCBsaXRlcmFsQm9vbGVhbiA9IHRoaXMubWF0Y2goeyB0eXBlOiBcImJvb2xlYW5cIiB9KTtcbiAgICByZXR1cm4gbGl0ZXJhbEJvb2xlYW4gJiYgbGl0ZXJhbEJvb2xlYW4udHlwZSA9PT0gXCJib29sZWFuXCIgPyB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIHZhbHVlOiBsaXRlcmFsQm9vbGVhbi5zeW1ib2wgPT09IFwidHJ1ZVwiXG4gICAgfSA6IHRoaXMucGFyc2VOdW1iZXIoKTtcbiAgfVxuICAvLyBUT0RPOiBSZW9yZGVyIGNvbnN0cmFpbnRzIHNvIHRoYXQgbGl0ZXJhbCB2YWx1ZSBpcyBhbHdheXMgb24gcmhzLCBhbmQgdmFyaWFibGUgaXMgYWx3YXlzXG4gIC8vIG9uIGxocy5cbiAgcGFyc2VGaWx0ZXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pLCBleHByID0gdGhpcy5wYXJzZUF0dHJpYnV0ZSgpIHx8IHRoaXMucGFyc2VBbGlhcygpO1xuICAgIGlmICghZXhwcilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKHsgdHlwZTogXCJvcGVyYXRvclwiLCBzeW1ib2w6IFwiP1wiIH0pKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjb25zdHJhaW50XCIsXG4gICAgICAgIG9wZXJhdG9yOiBcIj9cIixcbiAgICAgICAgbGhzOiBleHByXG4gICAgICB9O1xuICAgIGNvbnN0IGJpbk9wID0gdGhpcy5tYXRjaCh7IHR5cGU6IFwiY29tcGFyYXRvclwiIH0pO1xuICAgIGlmICghYmluT3AgfHwgYmluT3AudHlwZSAhPT0gXCJjb21wYXJhdG9yXCIpXG4gICAgICByZXR1cm4gdGhpcy5pID0gc3RhcnQsIG51bGw7XG4gICAgY29uc3QgbGhzID0gZXhwciwgcmhzID0gdGhpcy5wYXJzZUxpdGVyYWxWYWx1ZSgpO1xuICAgIGlmICghcmhzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVyYXRvciAke2Jpbk9wLnN5bWJvbH0gbmVlZHMgYSBsaXRlcmFsIHZhbHVlIGF0IHRoZSByaWdodCBoYW5kIHNpZGVgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb25zdHJhaW50XCIsXG4gICAgICBvcGVyYXRvcjogYmluT3Auc3ltYm9sLFxuICAgICAgbGhzLFxuICAgICAgcmhzXG4gICAgfTtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGaWx0ZXJFeHByZXNzaW9uKCkgfHwgdGhpcy5wYXJzZVZhbHVlUmVmZXJlbmNlKCk7XG4gIH1cbiAgcGFyc2VVbmlvbigpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goeyB0eXBlOiBcInBhcmVuXCIsIHN5bWJvbDogXCJbXCIgfSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB0ZXJtcyA9IFtdO1xuICAgIGxldCBleHByID0gdGhpcy5wYXJzZUZpbHRlckV4cHJlc3Npb24oKSB8fCB0aGlzLnBhcnNlUGF0aCgpIHx8IHRoaXMucGFyc2VWYWx1ZVJlZmVyZW5jZSgpO1xuICAgIGZvciAoOyBleHByICYmICh0ZXJtcy5wdXNoKGV4cHIpLCAhdGhpcy5tYXRjaCh7IHR5cGU6IFwicGFyZW5cIiwgc3ltYm9sOiBcIl1cIiB9KSk7ICkge1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKHsgdHlwZTogXCJvcGVyYXRvclwiLCBzeW1ib2w6IFwiLFwiIH0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBdXCIpO1xuICAgICAgaWYgKGV4cHIgPSB0aGlzLnBhcnNlRmlsdGVyRXhwcmVzc2lvbigpIHx8IHRoaXMucGFyc2VQYXRoKCkgfHwgdGhpcy5wYXJzZVZhbHVlUmVmZXJlbmNlKCksICFleHByKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBleHByZXNzaW9uIGZvbGxvd2luZyAnLCdcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICBub2RlczogdGVybXNcbiAgICB9O1xuICB9XG4gIHBhcnNlUmVjdXJzaXZlKCkge1xuICAgIGlmICghdGhpcy5tYXRjaCh7IHR5cGU6IFwib3BlcmF0b3JcIiwgc3ltYm9sOiBcIi4uXCIgfSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBzdWJwYXRoID0gdGhpcy5wYXJzZVBhdGgoKTtcbiAgICBpZiAoIXN1YnBhdGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwYXRoIGZvbGxvd2luZyAnLi4nIG9wZXJhdG9yXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlY3Vyc2l2ZVwiLFxuICAgICAgdGVybTogc3VicGF0aFxuICAgIH07XG4gIH1cbiAgcGFyc2VQYXRoKCkge1xuICAgIGNvbnN0IG5vZGVzID0gW10sIGV4cHIgPSB0aGlzLnBhcnNlQXR0cmlidXRlKCkgfHwgdGhpcy5wYXJzZVVuaW9uKCkgfHwgdGhpcy5wYXJzZVJlY3Vyc2l2ZSgpO1xuICAgIGlmICghZXhwcilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGZvciAobm9kZXMucHVzaChleHByKTsgIXRoaXMuRU9GKCk7IClcbiAgICAgIGlmICh0aGlzLm1hdGNoKHsgdHlwZTogXCJvcGVyYXRvclwiLCBzeW1ib2w6IFwiLlwiIH0pKSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLnBhcnNlQXR0cmlidXRlKCk7XG4gICAgICAgIGlmICghYXR0cilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhdHRyaWJ1dGUgbmFtZSBmb2xsb3dpbmcgJy5cIik7XG4gICAgICAgIG5vZGVzLnB1c2goYXR0cik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb2JlKHsgdHlwZTogXCJwYXJlblwiLCBzeW1ib2w6IFwiW1wiIH0pKSB7XG4gICAgICAgIGNvbnN0IHVuaW9uID0gdGhpcy5wYXJzZVVuaW9uKCk7XG4gICAgICAgIGlmICghdW5pb24pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdW5pb24gZm9sbG93aW5nICdbJ1wiKTtcbiAgICAgICAgbm9kZXMucHVzaCh1bmlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZWN1cnNpdmUgPSB0aGlzLnBhcnNlUmVjdXJzaXZlKCk7XG4gICAgICAgIHJlY3Vyc2l2ZSAmJiBub2Rlcy5wdXNoKHJlY3Vyc2l2ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPT09IDEgPyBub2Rlc1swXSA6IHtcbiAgICAgIHR5cGU6IFwicGF0aFwiLFxuICAgICAgbm9kZXNcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUpzb25QYXRoKHBhdGgpIHtcbiAgY29uc3QgcGFyc2VkID0gbmV3IFBhcnNlcihwYXRoKS5wYXJzZSgpO1xuICBpZiAoIXBhcnNlZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBKU09OIHBhdGggXCIke3BhdGh9XCJgKTtcbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIHRvUGF0aChleHByKSB7XG4gIHJldHVybiB0b1BhdGhJbm5lcihleHByLCAhMSk7XG59XG5mdW5jdGlvbiB0b1BhdGhJbm5lcihleHByLCBpblVuaW9uKSB7XG4gIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcImF0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIGV4cHIubmFtZTtcbiAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgIHJldHVybiBleHByLnRhcmdldCA9PT0gXCJzZWxmXCIgPyBcIkBcIiA6IFwiJFwiO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBgJHtleHByLnZhbHVlfWA7XG4gICAgY2FzZSBcInJhbmdlXCI6IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgcmV0dXJuIGluVW5pb24gfHwgcmVzdWx0LnB1c2goXCJbXCIpLCBleHByLnN0YXJ0ICYmIHJlc3VsdC5wdXNoKGAke2V4cHIuc3RhcnR9YCksIHJlc3VsdC5wdXNoKFwiOlwiKSwgZXhwci5lbmQgJiYgcmVzdWx0LnB1c2goYCR7ZXhwci5lbmR9YCksIGV4cHIuc3RlcCAmJiByZXN1bHQucHVzaChgOiR7ZXhwci5zdGVwfWApLCBpblVuaW9uIHx8IHJlc3VsdC5wdXNoKFwiXVwiKSwgcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgcmV0dXJuIGluVW5pb24gPyBgJHtleHByLnZhbHVlfWAgOiBgWyR7ZXhwci52YWx1ZX1dYDtcbiAgICBjYXNlIFwiY29uc3RyYWludFwiOiB7XG4gICAgICBjb25zdCByaHMgPSBleHByLnJocyA/IGAgJHt0b1BhdGhJbm5lcihleHByLnJocywgITEpfWAgOiBcIlwiLCBpbm5lciA9IGAke3RvUGF0aElubmVyKGV4cHIubGhzLCAhMSl9ICR7ZXhwci5vcGVyYXRvcn0ke3Joc31gO1xuICAgICAgcmV0dXJuIGluVW5pb24gPyBpbm5lciA6IGBbJHtpbm5lcn1dYDtcbiAgICB9XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4cHIudmFsdWUpO1xuICAgIGNhc2UgXCJwYXRoXCI6IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBub2RlcyA9IGV4cHIubm9kZXMuc2xpY2UoKTtcbiAgICAgIGZvciAoOyBub2Rlcy5sZW5ndGggPiAwOyApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzLnNoaWZ0KCk7XG4gICAgICAgIG5vZGUgJiYgcmVzdWx0LnB1c2godG9QYXRoKG5vZGUpKTtcbiAgICAgICAgY29uc3QgdXBjb21pbmcgPSBub2Rlc1swXTtcbiAgICAgICAgdXBjb21pbmcgJiYgdG9QYXRoSW5uZXIodXBjb21pbmcsICExKVswXSAhPT0gXCJbXCIgJiYgcmVzdWx0LnB1c2goXCIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBjYXNlIFwidW5pb25cIjpcbiAgICAgIHJldHVybiBgWyR7ZXhwci5ub2Rlcy5tYXAoKGUpID0+IHRvUGF0aElubmVyKGUsICEwKSkuam9pbihcIixcIil9XWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGUgJHtleHByLnR5cGV9YCk7XG4gICAgY2FzZSBcInJlY3Vyc2l2ZVwiOlxuICAgICAgcmV0dXJuIGAuLiR7dG9QYXRoSW5uZXIoZXhwci50ZXJtLCAhMSl9YDtcbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbiB7XG4gIGV4cHI7XG4gIGNvbnN0cnVjdG9yKGV4cHIpIHtcbiAgICBpZiAoIWV4cHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gY3JlYXRlIEV4cHJlc3Npb24gZnJvbSBudWxsLXZhbHVlXCIpO1xuICAgIGlmIChcImV4cHJcIiBpbiBleHByID8gdGhpcy5leHByID0gZXhwci5leHByIDogdGhpcy5leHByID0gZXhwciwgIShcInR5cGVcIiBpbiB0aGlzLmV4cHIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdCB0byBjcmVhdGUgRXhwcmVzc2lvbiBmb3IgZXhwcmVzc2lvbiB3aXRoIG5vIHR5cGVcIik7XG4gIH1cbiAgaXNQYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHIudHlwZSA9PT0gXCJwYXRoXCI7XG4gIH1cbiAgaXNVbmlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnR5cGUgPT09IFwidW5pb25cIjtcbiAgfVxuICBpc0NvbGxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXRoKCkgfHwgdGhpcy5pc1VuaW9uKCk7XG4gIH1cbiAgaXNDb25zdHJhaW50KCkge1xuICAgIHJldHVybiB0aGlzLmV4cHIudHlwZSA9PT0gXCJjb25zdHJhaW50XCI7XG4gIH1cbiAgaXNSZWN1cnNpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci50eXBlID09PSBcInJlY3Vyc2l2ZVwiO1xuICB9XG4gIGlzRXhpc3RlbmNlQ29uc3RyYWludCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnR5cGUgPT09IFwiY29uc3RyYWludFwiICYmIHRoaXMuZXhwci5vcGVyYXRvciA9PT0gXCI/XCI7XG4gIH1cbiAgaXNJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnR5cGUgPT09IFwiaW5kZXhcIjtcbiAgfVxuICBpc1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHIudHlwZSA9PT0gXCJyYW5nZVwiO1xuICB9XG4gIGV4cGFuZFJhbmdlKHByb2JlKSB7XG4gICAgY29uc3QgcHJvYmVMZW5ndGggPSAoKSA9PiB7XG4gICAgICBpZiAoIXByb2JlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBhbmRSYW5nZSgpIHJlcXVpcmVkIGEgcHJvYmUgdGhhdCB3YXMgbm90IHBhc3NlZFwiKTtcbiAgICAgIHJldHVybiBwcm9iZS5sZW5ndGgoKTtcbiAgICB9O1xuICAgIGxldCBzdGFydCA9IFwic3RhcnRcIiBpbiB0aGlzLmV4cHIgJiYgdGhpcy5leHByLnN0YXJ0IHx8IDA7XG4gICAgc3RhcnQgPSBpbnRlcnByZXROZWdhdGl2ZUluZGV4KHN0YXJ0LCBwcm9iZSk7XG4gICAgbGV0IGVuZCA9IFwiZW5kXCIgaW4gdGhpcy5leHByICYmIHRoaXMuZXhwci5lbmQgfHwgcHJvYmVMZW5ndGgoKTtcbiAgICBlbmQgPSBpbnRlcnByZXROZWdhdGl2ZUluZGV4KGVuZCwgcHJvYmUpO1xuICAgIGNvbnN0IHN0ZXAgPSBcInN0ZXBcIiBpbiB0aGlzLmV4cHIgJiYgdGhpcy5leHByLnN0ZXAgfHwgMTtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kLCBzdGVwIH07XG4gIH1cbiAgaXNBdHRyaWJ1dGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci50eXBlID09PSBcImF0dHJpYnV0ZVwiO1xuICB9XG4gIC8vIElzIGEgcmFuZ2Ugb3IgaW5kZXggLT4gc29tZXRoaW5nIHJlZmVyZW5jaW5nIGluZGV4ZXNcbiAgaXNJbmRleFJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luZGV4KCkgfHwgdGhpcy5pc1JhbmdlKCk7XG4gIH1cbiAgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJuYW1lXCIgaW4gdGhpcy5leHByID8gdGhpcy5leHByLm5hbWUgOiBcIlwiO1xuICB9XG4gIGlzU2VsZlJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnR5cGUgPT09IFwiYWxpYXNcIiAmJiB0aGlzLmV4cHIudGFyZ2V0ID09PSBcInNlbGZcIjtcbiAgfVxuICBjb25zdHJhaW50VGFyZ2V0SXNTZWxmKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHIudHlwZSA9PT0gXCJjb25zdHJhaW50XCIgJiYgdGhpcy5leHByLmxocy50eXBlID09PSBcImFsaWFzXCIgJiYgdGhpcy5leHByLmxocy50YXJnZXQgPT09IFwic2VsZlwiO1xuICB9XG4gIGNvbnN0cmFpbnRUYXJnZXRJc0F0dHJpYnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnR5cGUgPT09IFwiY29uc3RyYWludFwiICYmIHRoaXMuZXhwci5saHMudHlwZSA9PT0gXCJhdHRyaWJ1dGVcIjtcbiAgfVxuICB0ZXN0Q29uc3RyYWludChwcm9iZSkge1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLmV4cHI7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJjb25zdHJhaW50XCIgJiYgZXhwci5saHMudHlwZSA9PT0gXCJhbGlhc1wiICYmIGV4cHIubGhzLnRhcmdldCA9PT0gXCJzZWxmXCIpIHtcbiAgICAgIGlmIChwcm9iZS5jb250YWluZXJUeXBlKCkgIT09IFwicHJpbWl0aXZlXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiY29uc3RyYWludFwiICYmIGV4cHIub3BlcmF0b3IgPT09IFwiP1wiKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBjb25zdCBsaHMyID0gcHJvYmUuZ2V0KCksIHJoczIgPSBleHByLnJocyAmJiBcInZhbHVlXCIgaW4gZXhwci5yaHMgPyBleHByLnJocy52YWx1ZSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0ZXN0QmluYXJ5T3BlcmF0b3IobGhzMiwgZXhwci5vcGVyYXRvciwgcmhzMik7XG4gICAgfVxuICAgIGlmIChleHByLnR5cGUgIT09IFwiY29uc3RyYWludFwiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGxocyA9IGV4cHIubGhzO1xuICAgIGlmICghbGhzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTEhTIG9mIGV4cHJlc3Npb25cIik7XG4gICAgaWYgKGxocy50eXBlICE9PSBcImF0dHJpYnV0ZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJhaW50IHRhcmdldCAke2xocy50eXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgaWYgKHByb2JlLmNvbnRhaW5lclR5cGUoKSAhPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBsaHNWYWx1ZSA9IHByb2JlLmdldEF0dHJpYnV0ZShsaHMubmFtZSk7XG4gICAgaWYgKGxoc1ZhbHVlID09IG51bGwgfHwgbGhzVmFsdWUuY29udGFpbmVyVHlwZSgpICE9PSBcInByaW1pdGl2ZVwiKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICh0aGlzLmlzRXhpc3RlbmNlQ29uc3RyYWludCgpKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IHJocyA9IGV4cHIucmhzICYmIFwidmFsdWVcIiBpbiBleHByLnJocyA/IGV4cHIucmhzLnZhbHVlIDogdm9pZCAwO1xuICAgIHJldHVybiB0ZXN0QmluYXJ5T3BlcmF0b3IobGhzVmFsdWUuZ2V0KCksIGV4cHIub3BlcmF0b3IsIHJocyk7XG4gIH1cbiAgcGF0aE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLmV4cHIudHlwZSA9PT0gXCJwYXRoXCIgPyB0aGlzLmV4cHIubm9kZXMgOiBbdGhpcy5leHByXTtcbiAgfVxuICBwcmVwZW5kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IG5ldyBFeHByZXNzaW9uKHtcbiAgICAgIHR5cGU6IFwicGF0aFwiLFxuICAgICAgbm9kZXM6IG5vZGUucGF0aE5vZGVzKCkuY29uY2F0KHRoaXMucGF0aE5vZGVzKCkpXG4gICAgfSkgOiB0aGlzO1xuICB9XG4gIGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciA/IG90aGVyLnByZXBlbmQodGhpcykgOiB0aGlzO1xuICB9XG4gIGRlc2NlbmQoKSB7XG4gICAgcmV0dXJuIGRlc2NlbmQkMSh0aGlzLmV4cHIpLm1hcCgoaGVhZFRhaWwpID0+IHtcbiAgICAgIGNvbnN0IFtoZWFkLCB0YWlsXSA9IGhlYWRUYWlsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZDogaGVhZCA/IG5ldyBFeHByZXNzaW9uKGhlYWQpIDogbnVsbCxcbiAgICAgICAgdGFpbDogdGFpbCA/IG5ldyBFeHByZXNzaW9uKHRhaWwpIDogbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICB1bndyYXBSZWN1cnNpdmUoKSB7XG4gICAgaWYgKHRoaXMuZXhwci50eXBlICE9PSBcInJlY3Vyc2l2ZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0IHRvIHVud3JhcCByZWN1cnNpdmUgb24gdHlwZSAke3RoaXMuZXhwci50eXBlfWApO1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbih0aGlzLmV4cHIudGVybSk7XG4gIH1cbiAgdG9JbmRpY2llcyhwcm9iZSkge1xuICAgIGlmICh0aGlzLmV4cHIudHlwZSAhPT0gXCJpbmRleFwiICYmIHRoaXMuZXhwci50eXBlICE9PSBcInJhbmdlXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gaW5kZXhlc1wiKTtcbiAgICBpZiAodGhpcy5leHByLnR5cGUgPT09IFwiaW5kZXhcIilcbiAgICAgIHJldHVybiBbaW50ZXJwcmV0TmVnYXRpdmVJbmRleCh0aGlzLmV4cHIudmFsdWUsIHByb2JlKV07XG4gICAgY29uc3QgcmVzdWx0ID0gW10sIHJhbmdlID0gdGhpcy5leHBhbmRSYW5nZShwcm9iZSk7XG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgcmFuZ2Uuc3RlcCA8IDAgJiYgKFtzdGFydCwgZW5kXSA9IFtlbmQsIHN0YXJ0XSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRvRmllbGRSZWZlcmVuY2VzKCkge1xuICAgIGlmICh0aGlzLmlzSW5kZXhSZWZlcmVuY2UoKSlcbiAgICAgIHJldHVybiB0aGlzLnRvSW5kaWNpZXMoKTtcbiAgICBpZiAodGhpcy5leHByLnR5cGUgPT09IFwiYXR0cmlidXRlXCIpXG4gICAgICByZXR1cm4gW3RoaXMuZXhwci5uYW1lXTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNvbnZlcnQgJHt0aGlzLmV4cHIudHlwZX0gdG8gZmllbGQgcmVmZXJlbmNlc2ApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0b1BhdGgodGhpcy5leHByKTtcbiAgfVxuICBzdGF0aWMgZnJvbVBhdGgocGF0aCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSnNvblBhdGgocGF0aCk7XG4gICAgaWYgKCFwYXJzZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBwYXRoIFwiJHtwYXRofVwiYCk7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHBhcnNlZCk7XG4gIH1cbiAgc3RhdGljIGF0dHJpYnV0ZVJlZmVyZW5jZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uKHtcbiAgICAgIHR5cGU6IFwiYXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGluZGV4UmVmZXJlbmNlKGkpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb24oe1xuICAgICAgdHlwZTogXCJpbmRleFwiLFxuICAgICAgdmFsdWU6IGlcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gdGVzdEJpbmFyeU9wZXJhdG9yKGxoc1ZhbHVlLCBvcGVyYXRvciwgcmhzVmFsdWUpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgXCI+XCI6XG4gICAgICByZXR1cm4gbGhzVmFsdWUgPiByaHNWYWx1ZTtcbiAgICBjYXNlIFwiPj1cIjpcbiAgICAgIHJldHVybiBsaHNWYWx1ZSA+PSByaHNWYWx1ZTtcbiAgICBjYXNlIFwiPFwiOlxuICAgICAgcmV0dXJuIGxoc1ZhbHVlIDwgcmhzVmFsdWU7XG4gICAgY2FzZSBcIjw9XCI6XG4gICAgICByZXR1cm4gbGhzVmFsdWUgPD0gcmhzVmFsdWU7XG4gICAgY2FzZSBcIj09XCI6XG4gICAgICByZXR1cm4gbGhzVmFsdWUgPT09IHJoc1ZhbHVlO1xuICAgIGNhc2UgXCIhPVwiOlxuICAgICAgcmV0dXJuIGxoc1ZhbHVlICE9PSByaHNWYWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBiaW5hcnkgb3BlcmF0b3IgJHtvcGVyYXRvcn1gKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwcmV0TmVnYXRpdmVJbmRleChpbmRleCwgcHJvYmUpIHtcbiAgaWYgKGluZGV4ID49IDApXG4gICAgcmV0dXJuIGluZGV4O1xuICBpZiAoIXByb2JlKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludGVycHJldE5lZ2F0aXZlSW5kZXgoKSBtdXN0IGhhdmUgYSBwcm9iZSB3aGVuIDwgMFwiKTtcbiAgcmV0dXJuIGluZGV4ICsgcHJvYmUubGVuZ3RoKCk7XG59XG5jbGFzcyBEZXNjZW5kZXIge1xuICBoZWFkO1xuICB0YWlsO1xuICBjb25zdHJ1Y3RvcihoZWFkLCB0YWlsKSB7XG4gICAgdGhpcy5oZWFkID0gaGVhZCwgdGhpcy50YWlsID0gdGFpbDtcbiAgfVxuICAvLyBJdGVyYXRlIHRoaXMgZGVzY2VuZGVyIG9uY2UgcHJvY2Vzc2luZyBhbnkgY29uc3RyYWludHMgdGhhdCBhcmVcbiAgLy8gcmVzb2x2YWJsZSBvbiB0aGUgY3VycmVudCB2YWx1ZS4gUmV0dXJucyBhbiBhcnJheSBvZiBuZXcgZGVzY2VuZGVyc1xuICAvLyB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGJlIHdpdGhvdXQgY29uc3RyYWludHMgaW4gdGhlIGhlYWRcbiAgaXRlcmF0ZShwcm9iZSkge1xuICAgIGxldCByZXN1bHQgPSBbdGhpc107XG4gICAgaWYgKHRoaXMuaGVhZCAmJiB0aGlzLmhlYWQuaXNDb25zdHJhaW50KCkpIHtcbiAgICAgIGxldCBhbnlDb25zdHJhaW50cyA9ICEwO1xuICAgICAgZm9yICg7IGFueUNvbnN0cmFpbnRzOyApXG4gICAgICAgIHJlc3VsdCA9IGZsYXR0ZW4oXG4gICAgICAgICAgcmVzdWx0Lm1hcCgoZGVzY2VuZGVyKSA9PiBkZXNjZW5kZXIuaXRlcmF0ZUNvbnN0cmFpbnRzKHByb2JlKSlcbiAgICAgICAgKSwgYW55Q29uc3RyYWludHMgPSByZXN1bHQuc29tZSgoZGVzY2VuZGVyKSA9PiBkZXNjZW5kZXIuaGVhZCAmJiBkZXNjZW5kZXIuaGVhZC5pc0NvbnN0cmFpbnQoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNSZWN1cnNpdmUoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuaGVhZCAmJiB0aGlzLmhlYWQuaXNSZWN1cnNpdmUoKSk7XG4gIH1cbiAgaGFzQXJyaXZlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkID09PSBudWxsICYmIHRoaXMudGFpbCA9PT0gbnVsbDtcbiAgfVxuICBleHRyYWN0UmVjdXJzaXZlcygpIHtcbiAgICBpZiAodGhpcy5oZWFkICYmIHRoaXMuaGVhZC5pc1JlY3Vyc2l2ZSgpKSB7XG4gICAgICBjb25zdCB0ZXJtID0gdGhpcy5oZWFkLnVud3JhcFJlY3Vyc2l2ZSgpO1xuICAgICAgcmV0dXJuIG5ldyBEZXNjZW5kZXIobnVsbCwgdGVybS5jb25jYXQodGhpcy50YWlsKSkuZGVzY2VuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgaXRlcmF0ZUNvbnN0cmFpbnRzKHByb2JlKSB7XG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZDtcbiAgICBpZiAoaGVhZCA9PT0gbnVsbCB8fCAhaGVhZC5pc0NvbnN0cmFpbnQoKSlcbiAgICAgIHJldHVybiBbdGhpc107XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKHByb2JlLmNvbnRhaW5lclR5cGUoKSA9PT0gXCJwcmltaXRpdmVcIiAmJiBoZWFkLmNvbnN0cmFpbnRUYXJnZXRJc1NlbGYoKSlcbiAgICAgIHJldHVybiBoZWFkLnRlc3RDb25zdHJhaW50KHByb2JlKSAmJiByZXN1bHQucHVzaCguLi50aGlzLmRlc2NlbmQoKSksIHJlc3VsdDtcbiAgICBpZiAocHJvYmUuY29udGFpbmVyVHlwZSgpID09PSBcImFycmF5XCIpIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHByb2JlLmxlbmd0aCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb25zdHJhaW50ID0gcHJvYmUuZ2V0SW5kZXgoaSk7XG4gICAgICAgIGNvbnN0cmFpbnQgJiYgaGVhZC50ZXN0Q29uc3RyYWludChjb25zdHJhaW50KSAmJiByZXN1bHQucHVzaChuZXcgRGVzY2VuZGVyKG5ldyBFeHByZXNzaW9uKHsgdHlwZTogXCJpbmRleFwiLCB2YWx1ZTogaSB9KSwgdGhpcy50YWlsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvYmUuY29udGFpbmVyVHlwZSgpID09PSBcIm9iamVjdFwiID8gaGVhZC5jb25zdHJhaW50VGFyZ2V0SXNTZWxmKCkgPyBbXSA6IGhlYWQudGVzdENvbnN0cmFpbnQocHJvYmUpID8gdGhpcy5kZXNjZW5kKCkgOiByZXN1bHQgOiByZXN1bHQ7XG4gIH1cbiAgZGVzY2VuZCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsID8gdGhpcy50YWlsLmRlc2NlbmQoKS5tYXAoKGh0KSA9PiBuZXcgRGVzY2VuZGVyKGh0LmhlYWQsIGh0LnRhaWwpKSA6IFtuZXcgRGVzY2VuZGVyKG51bGwsIG51bGwpXTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXCI8XCJdO1xuICAgIHJldHVybiB0aGlzLmhlYWQgJiYgcmVzdWx0LnB1c2godGhpcy5oZWFkLnRvU3RyaW5nKCkpLCByZXN1bHQucHVzaChcInxcIiksIHRoaXMudGFpbCAmJiByZXN1bHQucHVzaCh0aGlzLnRhaWwudG9TdHJpbmcoKSksIHJlc3VsdC5wdXNoKFwiPlwiKSwgcmVzdWx0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmNsYXNzIE1hdGNoZXIge1xuICBhY3RpdmU7XG4gIHJlY3Vyc2l2ZXM7XG4gIHBheWxvYWQ7XG4gIGNvbnN0cnVjdG9yKGFjdGl2ZSwgcGFyZW50KSB7XG4gICAgdGhpcy5hY3RpdmUgPSBhY3RpdmUgfHwgW10sIHBhcmVudCA/ICh0aGlzLnJlY3Vyc2l2ZXMgPSBwYXJlbnQucmVjdXJzaXZlcywgdGhpcy5wYXlsb2FkID0gcGFyZW50LnBheWxvYWQpIDogdGhpcy5yZWN1cnNpdmVzID0gW10sIHRoaXMuZXh0cmFjdFJlY3Vyc2l2ZXMoKTtcbiAgfVxuICBzZXRQYXlsb2FkKHBheWxvYWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXlsb2FkID0gcGF5bG9hZCwgdGhpcztcbiAgfVxuICAvLyBNb3ZlcyBhbnkgcmVjdXJzaXZlIGRlc2NlbmRlcnMgb250byB0aGUgcmVjdXJzaXZlIHRyYWNrLCByZW1vdmluZyB0aGVtIGZyb21cbiAgLy8gdGhlIGFjdGl2ZSBzZXRcbiAgZXh0cmFjdFJlY3Vyc2l2ZXMoKSB7XG4gICAgdGhpcy5hY3RpdmUgPSB0aGlzLmFjdGl2ZS5maWx0ZXIoKGRlc2NlbmRlcikgPT4gZGVzY2VuZGVyLmlzUmVjdXJzaXZlKCkgPyAodGhpcy5yZWN1cnNpdmVzLnB1c2goLi4uZGVzY2VuZGVyLmV4dHJhY3RSZWN1cnNpdmVzKCkpLCAhMSkgOiAhMCk7XG4gIH1cbiAgLy8gRmluZCByZWN1cnNpdmVzIHRoYXQgYXJlIHJlbGV2YW50IG5vdyBhbmQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgYWN0aXZlIHNldFxuICBhY3RpdmVSZWN1cnNpdmVzKHByb2JlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlcy5maWx0ZXIoKGRlc2NlbmRlcikgPT4ge1xuICAgICAgY29uc3QgaGVhZCA9IGRlc2NlbmRlci5oZWFkO1xuICAgICAgcmV0dXJuIGhlYWQgPyBoZWFkLmlzQ29uc3RyYWludCgpIHx8IHByb2JlLmNvbnRhaW5lclR5cGUoKSA9PT0gXCJhcnJheVwiICYmIGhlYWQuaXNJbmRleFJlZmVyZW5jZSgpID8gITAgOiBwcm9iZS5jb250YWluZXJUeXBlKCkgPT09IFwib2JqZWN0XCIgPyBoZWFkLmlzQXR0cmlidXRlUmVmZXJlbmNlKCkgJiYgcHJvYmUuaGFzQXR0cmlidXRlKGhlYWQubmFtZSgpKSA6ICExIDogITE7XG4gICAgfSk7XG4gIH1cbiAgbWF0Y2gocHJvYmUpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVyYXRlKHByb2JlKS5leHRyYWN0TWF0Y2hlcyhwcm9iZSk7XG4gIH1cbiAgaXRlcmF0ZShwcm9iZSkge1xuICAgIGNvbnN0IG5ld0FjdGl2ZVNldCA9IFtdO1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZS5jb25jYXQodGhpcy5hY3RpdmVSZWN1cnNpdmVzKHByb2JlKSkuZm9yRWFjaCgoZGVzY2VuZGVyKSA9PiB7XG4gICAgICBuZXdBY3RpdmVTZXQucHVzaCguLi5kZXNjZW5kZXIuaXRlcmF0ZShwcm9iZSkpO1xuICAgIH0pLCBuZXcgTWF0Y2hlcihuZXdBY3RpdmVTZXQsIHRoaXMpO1xuICB9XG4gIC8vIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlIGRlc2NlbmRlcnMgaW4gdGhlIGFjdGl2ZSBvciByZWN1cnNpdmUgc2V0XG4gIC8vIGNvbnNpZGVyIHRoZSBjdXJyZW50IHN0YXRlIGEgZmluYWwgZGVzdGluYXRpb25cbiAgaXNEZXN0aW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmUuc29tZSgoZGVzY2VuZGVyKSA9PiBkZXNjZW5kZXIuaGFzQXJyaXZlZCgpKTtcbiAgfVxuICBoYXNSZWN1cnNpdmVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZXMubGVuZ3RoID4gMDtcbiAgfVxuICAvLyBSZXR1cm5zIGFueSBwYXlsb2FkIGRlbGl2aWVyaWVzIGFuZCBsZWFkcyB0aGF0IG5lZWRzIHRvIGJlIGZvbGxvd2VkIHRvIGNvbXBsZXRlXG4gIC8vIHRoZSBwcm9jZXNzLlxuICBleHRyYWN0TWF0Y2hlcyhwcm9iZSkge1xuICAgIGNvbnN0IGxlYWRzID0gW10sIHRhcmdldHMgPSBbXTtcbiAgICBpZiAodGhpcy5hY3RpdmUuZm9yRWFjaCgoZGVzY2VuZGVyKSA9PiB7XG4gICAgICBpZiAoZGVzY2VuZGVyLmhhc0Fycml2ZWQoKSkge1xuICAgICAgICB0YXJnZXRzLnB1c2goXG4gICAgICAgICAgbmV3IEV4cHJlc3Npb24oe1xuICAgICAgICAgICAgdHlwZTogXCJhbGlhc1wiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcInNlbGZcIlxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlc2NlbmRlckhlYWQgPSBkZXNjZW5kZXIuaGVhZDtcbiAgICAgIGlmIChkZXNjZW5kZXJIZWFkICYmICEocHJvYmUuY29udGFpbmVyVHlwZSgpID09PSBcImFycmF5XCIgJiYgIWRlc2NlbmRlckhlYWQuaXNJbmRleFJlZmVyZW5jZSgpKSAmJiAhKHByb2JlLmNvbnRhaW5lclR5cGUoKSA9PT0gXCJvYmplY3RcIiAmJiAhZGVzY2VuZGVySGVhZC5pc0F0dHJpYnV0ZVJlZmVyZW5jZSgpKSlcbiAgICAgICAgaWYgKGRlc2NlbmRlci50YWlsKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKGRlc2NlbmRlci5kZXNjZW5kKCksIHRoaXMpO1xuICAgICAgICAgIGRlc2NlbmRlckhlYWQudG9GaWVsZFJlZmVyZW5jZXMoKS5mb3JFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIGxlYWRzLnB1c2goe1xuICAgICAgICAgICAgICB0YXJnZXQ6IGRlc2NlbmRlckhlYWQsXG4gICAgICAgICAgICAgIG1hdGNoZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0YXJnZXRzLnB1c2goZGVzY2VuZGVySGVhZCk7XG4gICAgfSksIHRoaXMuaGFzUmVjdXJzaXZlcygpKSB7XG4gICAgICBjb25zdCByZWN1cnNpdmVzTWF0Y2hlciA9IG5ldyBNYXRjaGVyKFtdLCB0aGlzKTtcbiAgICAgIGlmIChwcm9iZS5jb250YWluZXJUeXBlKCkgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwcm9iZS5sZW5ndGgoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgICBsZWFkcy5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDogRXhwcmVzc2lvbi5pbmRleFJlZmVyZW5jZShpKSxcbiAgICAgICAgICAgIG1hdGNoZXI6IHJlY3Vyc2l2ZXNNYXRjaGVyXG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgcHJvYmUuY29udGFpbmVyVHlwZSgpID09PSBcIm9iamVjdFwiICYmIHByb2JlLmF0dHJpYnV0ZUtleXMoKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGxlYWRzLnB1c2goe1xuICAgICAgICAgIHRhcmdldDogRXhwcmVzc2lvbi5hdHRyaWJ1dGVSZWZlcmVuY2UobmFtZSksXG4gICAgICAgICAgbWF0Y2hlcjogcmVjdXJzaXZlc01hdGNoZXJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldHMubGVuZ3RoID4gMCA/IHsgbGVhZHMsIGRlbGl2ZXJ5OiB7IHRhcmdldHMsIHBheWxvYWQ6IHRoaXMucGF5bG9hZCB9IH0gOiB7IGxlYWRzIH07XG4gIH1cbiAgc3RhdGljIGZyb21QYXRoKGpzb25wYXRoKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhcnNlSnNvblBhdGgoanNvbnBhdGgpO1xuICAgIGlmICghcGF0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHBhdGggZnJvbSBcIiR7anNvbnBhdGh9XCJgKTtcbiAgICBjb25zdCBkZXNjZW5kZXIgPSBuZXcgRGVzY2VuZGVyKG51bGwsIG5ldyBFeHByZXNzaW9uKHBhdGgpKTtcbiAgICByZXR1cm4gbmV3IE1hdGNoZXIoZGVzY2VuZGVyLmRlc2NlbmQoKSk7XG4gIH1cbn1cbmNsYXNzIFBsYWluUHJvYmUge1xuICBfdmFsdWU7XG4gIHBhdGg7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXRoKSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZSwgdGhpcy5wYXRoID0gcGF0aCB8fCBbXTtcbiAgfVxuICBjb250YWluZXJUeXBlKCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX3ZhbHVlKSA/IFwiYXJyYXlcIiA6IHRoaXMuX3ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aGlzLl92YWx1ZSA9PSBcIm9iamVjdFwiID8gXCJvYmplY3RcIiA6IFwicHJpbWl0aXZlXCI7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl92YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb24ndCByZXR1cm4gbGVuZ3RoIG9mIG5vbi1pbmRleGFibGUgX3ZhbHVlXCIpO1xuICAgIHJldHVybiB0aGlzLl92YWx1ZS5sZW5ndGg7XG4gIH1cbiAgZ2V0SW5kZXgoaSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMuX3ZhbHVlKSA/IGkgPj0gdGhpcy5sZW5ndGgoKSA/IG51bGwgOiBuZXcgUGxhaW5Qcm9iZSh0aGlzLl92YWx1ZVtpXSwgdGhpcy5wYXRoLmNvbmNhdChpKSkgOiAhMTtcbiAgfVxuICBoYXNBdHRyaWJ1dGUoa2V5KSB7XG4gICAgcmV0dXJuIGlzUmVjb3JkKHRoaXMuX3ZhbHVlKSA/IHRoaXMuX3ZhbHVlLmhhc093blByb3BlcnR5KGtleSkgOiAhMTtcbiAgfVxuICBhdHRyaWJ1dGVLZXlzKCkge1xuICAgIHJldHVybiBpc1JlY29yZCh0aGlzLl92YWx1ZSkgPyBPYmplY3Qua2V5cyh0aGlzLl92YWx1ZSkgOiBbXTtcbiAgfVxuICBnZXRBdHRyaWJ1dGUoa2V5KSB7XG4gICAgaWYgKCFpc1JlY29yZCh0aGlzLl92YWx1ZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRBdHRyaWJ1dGUgb25seSBhcHBsaWVzIHRvIHBsYWluIG9iamVjdHNcIik7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKGtleSkgPyBuZXcgUGxhaW5Qcm9iZSh0aGlzLl92YWx1ZVtrZXldLCB0aGlzLnBhdGguY29uY2F0KGtleSkpIDogbnVsbDtcbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0QWNjZXNzb3JzKHBhdGgsIHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdLCBtYXRjaGVyID0gTWF0Y2hlci5mcm9tUGF0aChwYXRoKS5zZXRQYXlsb2FkKGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIHJlc3VsdC5wdXNoKC4uLnZhbHVlcyk7XG4gIH0pLCBhY2Nlc3NvciA9IG5ldyBQbGFpblByb2JlKHZhbHVlKTtcbiAgcmV0dXJuIGRlc2NlbmQobWF0Y2hlciwgYWNjZXNzb3IpLCByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZXNjZW5kKG1hdGNoZXIsIGFjY2Vzc29yKSB7XG4gIGNvbnN0IHsgbGVhZHMsIGRlbGl2ZXJ5IH0gPSBtYXRjaGVyLm1hdGNoKGFjY2Vzc29yKTtcbiAgbGVhZHMuZm9yRWFjaCgobGVhZCkgPT4ge1xuICAgIGFjY2Vzc29yc0Zyb21UYXJnZXQobGVhZC50YXJnZXQsIGFjY2Vzc29yKS5mb3JFYWNoKChjaGlsZEFjY2Vzc29yKSA9PiB7XG4gICAgICBkZXNjZW5kKGxlYWQubWF0Y2hlciwgY2hpbGRBY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH0pLCBkZWxpdmVyeSAmJiBkZWxpdmVyeS50YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgIHR5cGVvZiBkZWxpdmVyeS5wYXlsb2FkID09IFwiZnVuY3Rpb25cIiAmJiBkZWxpdmVyeS5wYXlsb2FkKGFjY2Vzc29yc0Zyb21UYXJnZXQodGFyZ2V0LCBhY2Nlc3NvcikpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFjY2Vzc29yc0Zyb21UYXJnZXQodGFyZ2V0LCBhY2Nlc3Nvcikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKHRhcmdldC5pc0luZGV4UmVmZXJlbmNlKCkpXG4gICAgdGFyZ2V0LnRvSW5kaWNpZXMoYWNjZXNzb3IpLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHJlc3VsdC5wdXNoKGFjY2Vzc29yLmdldEluZGV4KGkpKTtcbiAgICB9KTtcbiAgZWxzZSBpZiAodGFyZ2V0LmlzQXR0cmlidXRlUmVmZXJlbmNlKCkpXG4gICAgcmVzdWx0LnB1c2goYWNjZXNzb3IuZ2V0QXR0cmlidXRlKHRhcmdldC5uYW1lKCkpKTtcbiAgZWxzZSBpZiAodGFyZ2V0LmlzU2VsZlJlZmVyZW5jZSgpKVxuICAgIHJlc3VsdC5wdXNoKGFjY2Vzc29yKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGRlcml2ZSBhY2Nlc3NvciBmb3IgdGFyZ2V0ICR7dGFyZ2V0LnRvU3RyaW5nKCl9YCk7XG4gIHJldHVybiBjb21wYWN0KHJlc3VsdCk7XG59XG5mdW5jdGlvbiBleHRyYWN0KHBhdGgsIHZhbHVlKSB7XG4gIHJldHVybiBleHRyYWN0QWNjZXNzb3JzKHBhdGgsIHZhbHVlKS5tYXAoKGFjYykgPT4gYWNjLmdldCgpKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RXaXRoUGF0aChwYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gZXh0cmFjdEFjY2Vzc29ycyhwYXRoLCB2YWx1ZSkubWFwKChhY2MpID0+ICh7IHBhdGg6IGFjYy5wYXRoLCB2YWx1ZTogYWNjLmdldCgpIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGx5UGF0Y2gocGF0Y2gsIG9sZFZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygb2xkVmFsdWUgIT0gXCJzdHJpbmdcIikgcmV0dXJuIG9sZFZhbHVlO1xuICBjb25zdCBbcmVzdWx0XSA9IGFwcGx5UGF0Y2hlcyhwYXRjaCwgb2xkVmFsdWUsIHsgYWxsb3dFeGNlZWRpbmdJbmRpY2VzOiAhMCB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIERpZmZNYXRjaFBhdGNoIHtcbiAgcGF0aDtcbiAgZG1wUGF0Y2g7XG4gIGlkO1xuICBjb25zdHJ1Y3RvcihpZCwgcGF0aCwgZG1wUGF0Y2hTcmMpIHtcbiAgICB0aGlzLmlkID0gaWQsIHRoaXMucGF0aCA9IHBhdGgsIHRoaXMuZG1wUGF0Y2ggPSBwYXJzZVBhdGNoJDEoZG1wUGF0Y2hTcmMpO1xuICB9XG4gIGFwcGx5KHRhcmdldHMsIGFjY2Vzc29yKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFjY2Vzc29yO1xuICAgIGlmIChyZXN1bHQuY29udGFpbmVyVHlwZSgpID09PSBcInByaW1pdGl2ZVwiKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlzSW5kZXhSZWZlcmVuY2UoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhcmdldC50b0luZGljaWVzKGFjY2Vzc29yKSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSByZXN1bHQuZ2V0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gaXRlbS5nZXQoKSwgbmV4dFZhbHVlID0gYXBwbHlQYXRjaCh0aGlzLmRtcFBhdGNoLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNldEluZGV4KGluZGV4LCBuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldC5pc0F0dHJpYnV0ZVJlZmVyZW5jZSgpICYmIHJlc3VsdC5oYXNBdHRyaWJ1dGUodGFyZ2V0Lm5hbWUoKSkpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gcmVzdWx0LmdldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpKTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gYXR0cmlidXRlLmdldCgpLCBuZXh0VmFsdWUgPSBhcHBseVBhdGNoKHRoaXMuZG1wUGF0Y2gsIG9sZFZhbHVlKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpLCBuZXh0VmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGFwcGx5IGRpZmZNYXRjaFBhdGNoIHRvIHRhcmdldCAke3RhcmdldC50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBwZXJmb3JtSW5jcmVtZW50KHByZXZpb3VzVmFsdWUsIGRlbHRhKSB7XG4gIHJldHVybiB0eXBlb2YgcHJldmlvdXNWYWx1ZSAhPSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNGaW5pdGUocHJldmlvdXNWYWx1ZSkgPyBwcmV2aW91c1ZhbHVlIDogcHJldmlvdXNWYWx1ZSArIGRlbHRhO1xufVxuY2xhc3MgSW5jUGF0Y2gge1xuICBwYXRoO1xuICB2YWx1ZTtcbiAgaWQ7XG4gIGNvbnN0cnVjdG9yKGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGgsIHRoaXMudmFsdWUgPSB2YWx1ZSwgdGhpcy5pZCA9IGlkO1xuICB9XG4gIGFwcGx5KHRhcmdldHMsIGFjY2Vzc29yKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFjY2Vzc29yO1xuICAgIGlmIChyZXN1bHQuY29udGFpbmVyVHlwZSgpID09PSBcInByaW1pdGl2ZVwiKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICBpZiAodGFyZ2V0LmlzSW5kZXhSZWZlcmVuY2UoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhcmdldC50b0luZGljaWVzKGFjY2Vzc29yKSkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSByZXN1bHQuZ2V0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgIGlmICghaXRlbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBpdGVtLmdldCgpO1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zZXRJbmRleChpbmRleCwgcGVyZm9ybUluY3JlbWVudChwcmV2aW91c1ZhbHVlLCB0aGlzLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0LmlzQXR0cmlidXRlUmVmZXJlbmNlKCkpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gcmVzdWx0LmdldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpKTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBhdHRyaWJ1dGUuZ2V0KCk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zZXRBdHRyaWJ1dGUodGFyZ2V0Lm5hbWUoKSwgcGVyZm9ybUluY3JlbWVudChwcmV2aW91c1ZhbHVlLCB0aGlzLnZhbHVlKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gYXBwbHkgdG8gdGFyZ2V0ICR7dGFyZ2V0LnRvU3RyaW5nKCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHRhcmdldHNUb0luZGljaWVzKHRhcmdldHMsIGFjY2Vzc29yKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICByZXR1cm4gdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQuaXNJbmRleFJlZmVyZW5jZSgpICYmIHJlc3VsdC5wdXNoKC4uLnRhcmdldC50b0luZGljaWVzKGFjY2Vzc29yKSk7XG4gIH0pLCByZXN1bHQuc29ydCgpO1xufVxuY2xhc3MgSW5zZXJ0UGF0Y2gge1xuICBsb2NhdGlvbjtcbiAgcGF0aDtcbiAgaXRlbXM7XG4gIGlkO1xuICBjb25zdHJ1Y3RvcihpZCwgbG9jYXRpb24sIHBhdGgsIGl0ZW1zKSB7XG4gICAgdGhpcy5pZCA9IGlkLCB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb24sIHRoaXMucGF0aCA9IHBhdGgsIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgfVxuICBhcHBseSh0YXJnZXRzLCBhY2Nlc3Nvcikge1xuICAgIGxldCByZXN1bHQgPSBhY2Nlc3NvcjtcbiAgICBpZiAoYWNjZXNzb3IuY29udGFpbmVyVHlwZSgpICE9PSBcImFycmF5XCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0IHRvIGFwcGx5IGluc2VydCBwYXRjaCB0byBub24tYXJyYXkgdmFsdWVcIik7XG4gICAgc3dpdGNoICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICBjYXNlIFwiYmVmb3JlXCI6IHtcbiAgICAgICAgY29uc3QgcG9zID0gbWluSW5kZXgodGFyZ2V0cywgYWNjZXNzb3IpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuaW5zZXJ0SXRlbXNBdChwb3MsIHRoaXMuaXRlbXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhZnRlclwiOiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IG1heEluZGV4KHRhcmdldHMsIGFjY2Vzc29yKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmluc2VydEl0ZW1zQXQocG9zICsgMSwgdGhpcy5pdGVtcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJlcGxhY2VcIjoge1xuICAgICAgICBjb25zdCBpbmRpY2llcyA9IHRhcmdldHNUb0luZGljaWVzKHRhcmdldHMsIGFjY2Vzc29yKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnVuc2V0SW5kaWNlcyhpbmRpY2llcyksIHJlc3VsdCA9IHJlc3VsdC5pbnNlcnRJdGVtc0F0KGluZGljaWVzWzBdLCB0aGlzLml0ZW1zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvY2F0aW9uIGF0bTogJHt0aGlzLmxvY2F0aW9ufWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBtaW5JbmRleCh0YXJnZXRzLCBhY2Nlc3Nvcikge1xuICBsZXQgcmVzdWx0ID0gbWluKHRhcmdldHNUb0luZGljaWVzKHRhcmdldHMsIGFjY2Vzc29yKSkgfHwgMDtcbiAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgaWYgKHRhcmdldC5pc1JhbmdlKCkpIHtcbiAgICAgIGNvbnN0IHsgc3RhcnQgfSA9IHRhcmdldC5leHBhbmRSYW5nZSgpO1xuICAgICAgc3RhcnQgPCByZXN1bHQgJiYgKHJlc3VsdCA9IHN0YXJ0KTtcbiAgICB9XG4gIH0pLCByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXhJbmRleCh0YXJnZXRzLCBhY2Nlc3Nvcikge1xuICBsZXQgcmVzdWx0ID0gbWF4KHRhcmdldHNUb0luZGljaWVzKHRhcmdldHMsIGFjY2Vzc29yKSkgfHwgMDtcbiAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgaWYgKHRhcmdldC5pc1JhbmdlKCkpIHtcbiAgICAgIGNvbnN0IHsgZW5kIH0gPSB0YXJnZXQuZXhwYW5kUmFuZ2UoKTtcbiAgICAgIGVuZCA+IHJlc3VsdCAmJiAocmVzdWx0ID0gZW5kKTtcbiAgICB9XG4gIH0pLCByZXN1bHQ7XG59XG5jbGFzcyBTZXRJZk1pc3NpbmdQYXRjaCB7XG4gIGlkO1xuICBwYXRoO1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IoaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdGhpcy5pZCA9IGlkLCB0aGlzLnBhdGggPSBwYXRoLCB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgYXBwbHkodGFyZ2V0cywgYWNjZXNzb3IpIHtcbiAgICBsZXQgcmVzdWx0ID0gYWNjZXNzb3I7XG4gICAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoIXRhcmdldC5pc0luZGV4UmVmZXJlbmNlKCkpXG4gICAgICAgIGlmICh0YXJnZXQuaXNBdHRyaWJ1dGVSZWZlcmVuY2UoKSlcbiAgICAgICAgICByZXN1bHQuY29udGFpbmVyVHlwZSgpID09PSBcInByaW1pdGl2ZVwiID8gcmVzdWx0ID0gcmVzdWx0LnNldCh7IFt0YXJnZXQubmFtZSgpXTogdGhpcy52YWx1ZSB9KSA6IHJlc3VsdC5oYXNBdHRyaWJ1dGUodGFyZ2V0Lm5hbWUoKSkgfHwgKHJlc3VsdCA9IGFjY2Vzc29yLnNldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpLCB0aGlzLnZhbHVlKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBhcHBseSB0byB0YXJnZXQgJHt0YXJnZXQudG9TdHJpbmcoKX1gKTtcbiAgICB9KSwgcmVzdWx0O1xuICB9XG59XG5jbGFzcyBTZXRQYXRjaCB7XG4gIGlkO1xuICBwYXRoO1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IoaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdGhpcy5pZCA9IGlkLCB0aGlzLnBhdGggPSBwYXRoLCB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgYXBwbHkodGFyZ2V0cywgYWNjZXNzb3IpIHtcbiAgICBsZXQgcmVzdWx0ID0gYWNjZXNzb3I7XG4gICAgcmV0dXJuIHRhcmdldHMuZm9yRWFjaCgodGFyZ2V0KSA9PiB7XG4gICAgICBpZiAodGFyZ2V0LmlzU2VsZlJlZmVyZW5jZSgpKVxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2V0KHRoaXMudmFsdWUpO1xuICAgICAgZWxzZSBpZiAodGFyZ2V0LmlzSW5kZXhSZWZlcmVuY2UoKSlcbiAgICAgICAgdGFyZ2V0LnRvSW5kaWNpZXMoYWNjZXNzb3IpLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2V0SW5kZXgoaSwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgZWxzZSBpZiAodGFyZ2V0LmlzQXR0cmlidXRlUmVmZXJlbmNlKCkpXG4gICAgICAgIHJlc3VsdC5jb250YWluZXJUeXBlKCkgPT09IFwicHJpbWl0aXZlXCIgPyByZXN1bHQgPSByZXN1bHQuc2V0KHsgW3RhcmdldC5uYW1lKCldOiB0aGlzLnZhbHVlIH0pIDogcmVzdWx0ID0gcmVzdWx0LnNldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpLCB0aGlzLnZhbHVlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gYXBwbHkgdG8gdGFyZ2V0ICR7dGFyZ2V0LnRvU3RyaW5nKCl9YCk7XG4gICAgfSksIHJlc3VsdDtcbiAgfVxufVxuY2xhc3MgVW5zZXRQYXRjaCB7XG4gIGlkO1xuICBwYXRoO1xuICB2YWx1ZTtcbiAgY29uc3RydWN0b3IoaWQsIHBhdGgpIHtcbiAgICB0aGlzLmlkID0gaWQsIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgYXBwbHkodGFyZ2V0cywgYWNjZXNzb3IpIHtcbiAgICBsZXQgcmVzdWx0ID0gYWNjZXNzb3I7XG4gICAgc3dpdGNoIChhY2Nlc3Nvci5jb250YWluZXJUeXBlKCkpIHtcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICByZXN1bHQgPSByZXN1bHQudW5zZXRJbmRpY2VzKHRhcmdldHNUb0luZGljaWVzKHRhcmdldHMsIGFjY2Vzc29yKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC51bnNldEF0dHJpYnV0ZSh0YXJnZXQubmFtZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVGFyZ2V0IHZhbHVlIGlzIG5laXRoZXIgaW5kZXhhYmxlIG9yIGFuIG9iamVjdC4gVGhpcyBlcnJvciBzaG91bGQgcG90ZW50aWFsbHkganVzdCBiZSBzaWxlbnRseSBpZ25vcmVkP1wiXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUGF0Y2gocGF0Y2gpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGNoKSlcbiAgICByZXR1cm4gcGF0Y2gucmVkdWNlKChyLCBwKSA9PiByLmNvbmNhdChwYXJzZVBhdGNoKHApKSwgcmVzdWx0KTtcbiAgY29uc3QgeyBzZXQsIHNldElmTWlzc2luZywgdW5zZXQsIGRpZmZNYXRjaFBhdGNoLCBpbmMsIGRlYywgaW5zZXJ0IH0gPSBwYXRjaDtcbiAgaWYgKHNldElmTWlzc2luZyAmJiBPYmplY3Qua2V5cyhzZXRJZk1pc3NpbmcpLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICByZXN1bHQucHVzaChuZXcgU2V0SWZNaXNzaW5nUGF0Y2gocGF0Y2guaWQsIHBhdGgsIHNldElmTWlzc2luZ1twYXRoXSkpO1xuICB9KSwgc2V0ICYmIE9iamVjdC5rZXlzKHNldCkuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKG5ldyBTZXRQYXRjaChwYXRjaC5pZCwgcGF0aCwgc2V0W3BhdGhdKSk7XG4gIH0pLCB1bnNldCAmJiB1bnNldC5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgcmVzdWx0LnB1c2gobmV3IFVuc2V0UGF0Y2gocGF0Y2guaWQsIHBhdGgpKTtcbiAgfSksIGRpZmZNYXRjaFBhdGNoICYmIE9iamVjdC5rZXlzKGRpZmZNYXRjaFBhdGNoKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgcmVzdWx0LnB1c2gobmV3IERpZmZNYXRjaFBhdGNoKHBhdGNoLmlkLCBwYXRoLCBkaWZmTWF0Y2hQYXRjaFtwYXRoXSkpO1xuICB9KSwgaW5jICYmIE9iamVjdC5rZXlzKGluYykuZm9yRWFjaCgocGF0aCkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKG5ldyBJbmNQYXRjaChwYXRjaC5pZCwgcGF0aCwgaW5jW3BhdGhdKSk7XG4gIH0pLCBkZWMgJiYgT2JqZWN0LmtleXMoZGVjKS5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgcmVzdWx0LnB1c2gobmV3IEluY1BhdGNoKHBhdGNoLmlkLCBwYXRoLCAtZGVjW3BhdGhdKSk7XG4gIH0pLCBpbnNlcnQpIHtcbiAgICBsZXQgbG9jYXRpb24sIHBhdGg7XG4gICAgY29uc3Qgc3BlYyA9IGluc2VydDtcbiAgICBpZiAoXCJiZWZvcmVcIiBpbiBzcGVjKVxuICAgICAgbG9jYXRpb24gPSBcImJlZm9yZVwiLCBwYXRoID0gc3BlYy5iZWZvcmU7XG4gICAgZWxzZSBpZiAoXCJhZnRlclwiIGluIHNwZWMpXG4gICAgICBsb2NhdGlvbiA9IFwiYWZ0ZXJcIiwgcGF0aCA9IHNwZWMuYWZ0ZXI7XG4gICAgZWxzZSBpZiAoXCJyZXBsYWNlXCIgaW4gc3BlYylcbiAgICAgIGxvY2F0aW9uID0gXCJyZXBsYWNlXCIsIHBhdGggPSBzcGVjLnJlcGxhY2U7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnNlcnQgcGF0Y2hcIik7XG4gICAgcmVzdWx0LnB1c2gobmV3IEluc2VydFBhdGNoKHBhdGNoLmlkLCBsb2NhdGlvbiwgcGF0aCwgc3BlYy5pdGVtcykpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBQYXRjaGVyIHtcbiAgcGF0Y2hlcztcbiAgY29uc3RydWN0b3IocGF0Y2gpIHtcbiAgICB0aGlzLnBhdGNoZXMgPSBwYXJzZVBhdGNoKHBhdGNoKTtcbiAgfVxuICBhcHBseSh2YWx1ZSkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gbmV3IEltbXV0YWJsZUFjY2Vzc29yKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5hcHBseVZpYUFjY2Vzc29yKGFjY2Vzc29yKS5nZXQoKTtcbiAgfVxuICAvLyBJZiB5b3Ugd2FudCB0byB1c2UgeW91ciBvd24gYWNjZXNzb3IgaW1wbGVtZW50YXRpb24sIHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vIHRvIGludm9rZSB0aGUgcGF0Y2hlci4gU2luY2UgYWxsIHN1YnNlcXVlbnQgYWNjZXNzb3JzIGZvciBjaGlsZHJlbiBvZiB0aGlzIGFjY2Vzc29yXG4gIC8vIGFyZSBvYnRhaW5lZCB0aHJvdWdoIHRoZSBtZXRob2RzIGluIHRoZSBhY2Nlc3NvcnMsIHlvdSByZXRhaW4gZnVsbCBjb250cm9sIG9mIHRoZVxuICAvLyBpbXBsZW1lbnRhdGlvbiB0aHJvZ3VoZ291dCB0aGUgYXBwbGljYXRpb24uIEhhdmUgYSBsb29rIGluIEltbXV0YWJsZUFjY2Vzc29yXG4gIC8vIHRvIHNlZSBhbiBleGFtcGxlIG9mIGhvdyBhY2Nlc3NvcnMgYXJlIGltcGxlbWVudGVkLlxuICBhcHBseVZpYUFjY2Vzc29yKGFjY2Vzc29yKSB7XG4gICAgbGV0IHJlc3VsdCA9IGFjY2Vzc29yO1xuICAgIGNvbnN0IGlkQWNjZXNzb3IgPSBhY2Nlc3Nvci5nZXRBdHRyaWJ1dGUoXCJfaWRcIik7XG4gICAgaWYgKCFpZEFjY2Vzc29yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IHBhdGNoIHRvIGRvY3VtZW50IHdpdGggbm8gX2lkXCIpO1xuICAgIGNvbnN0IGlkID0gaWRBY2Nlc3Nvci5nZXQoKTtcbiAgICBmb3IgKGNvbnN0IHBhdGNoIG9mIHRoaXMucGF0Y2hlcykge1xuICAgICAgaWYgKHBhdGNoLmlkICE9PSBpZClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBtYXRjaGVyID0gTWF0Y2hlci5mcm9tUGF0aChwYXRjaC5wYXRoKS5zZXRQYXlsb2FkKHBhdGNoKTtcbiAgICAgIHJlc3VsdCA9IHByb2Nlc3MobWF0Y2hlciwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2VzcyhtYXRjaGVyLCBhY2Nlc3Nvcikge1xuICBjb25zdCBpc1NldFBhdGNoID0gbWF0Y2hlci5wYXlsb2FkIGluc3RhbmNlb2YgU2V0UGF0Y2ggfHwgbWF0Y2hlci5wYXlsb2FkIGluc3RhbmNlb2YgU2V0SWZNaXNzaW5nUGF0Y2g7XG4gIGxldCByZXN1bHQgPSBhY2Nlc3NvcjtcbiAgY29uc3QgeyBsZWFkcywgZGVsaXZlcnkgfSA9IG1hdGNoZXIubWF0Y2goYWNjZXNzb3IpO1xuICByZXR1cm4gbGVhZHMuZm9yRWFjaCgobGVhZCkgPT4ge1xuICAgIGlmIChsZWFkLnRhcmdldC5pc0luZGV4UmVmZXJlbmNlKCkpXG4gICAgICBsZWFkLnRhcmdldC50b0luZGljaWVzKCkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gcmVzdWx0LmdldEluZGV4KGkpO1xuICAgICAgICBpZiAoIWl0ZW0pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNldEluZGV4QWNjZXNzb3IoaSwgcHJvY2VzcyhsZWFkLm1hdGNoZXIsIGl0ZW0pKTtcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKGxlYWQudGFyZ2V0LmlzQXR0cmlidXRlUmVmZXJlbmNlKCkpIHtcbiAgICAgIGlzU2V0UGF0Y2ggJiYgcmVzdWx0LmNvbnRhaW5lclR5cGUoKSA9PT0gXCJwcmltaXRpdmVcIiAmJiAocmVzdWx0ID0gcmVzdWx0LnNldCh7fSkpO1xuICAgICAgbGV0IG9sZFZhbHVlQWNjZXNzb3IgPSByZXN1bHQuZ2V0QXR0cmlidXRlKGxlYWQudGFyZ2V0Lm5hbWUoKSk7XG4gICAgICBpZiAoIW9sZFZhbHVlQWNjZXNzb3IgJiYgaXNTZXRQYXRjaCAmJiAocmVzdWx0ID0gcmVzdWx0LnNldEF0dHJpYnV0ZShsZWFkLnRhcmdldC5uYW1lKCksIHt9KSwgb2xkVmFsdWVBY2Nlc3NvciA9IHJlc3VsdC5nZXRBdHRyaWJ1dGUobGVhZC50YXJnZXQubmFtZSgpKSksICFvbGRWYWx1ZUFjY2Vzc29yKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuZXdWYWx1ZUFjY2Vzc29yID0gcHJvY2VzcyhsZWFkLm1hdGNoZXIsIG9sZFZhbHVlQWNjZXNzb3IpO1xuICAgICAgb2xkVmFsdWVBY2Nlc3NvciAhPT0gbmV3VmFsdWVBY2Nlc3NvciAmJiAocmVzdWx0ID0gcmVzdWx0LnNldEF0dHJpYnV0ZUFjY2Vzc29yKGxlYWQudGFyZ2V0Lm5hbWUoKSwgbmV3VmFsdWVBY2Nlc3NvcikpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaGFuZGxlIHRhcmdldCAke2xlYWQudGFyZ2V0LnRvU3RyaW5nKCl9YCk7XG4gIH0pLCBkZWxpdmVyeSAmJiBpc1BhdGNoZXIoZGVsaXZlcnkucGF5bG9hZCkgJiYgKHJlc3VsdCA9IGRlbGl2ZXJ5LnBheWxvYWQuYXBwbHkoZGVsaXZlcnkudGFyZ2V0cywgcmVzdWx0KSksIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzUGF0Y2hlcihwYXlsb2FkKSB7XG4gIHJldHVybiAhIShwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09IFwib2JqZWN0XCIgJiYgcGF5bG9hZCAhPT0gbnVsbCAmJiBcImFwcGx5XCIgaW4gcGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZC5hcHBseSA9PSBcImZ1bmN0aW9uXCIpO1xufVxuY29uc3QgbHVpZCA9IHV1aWQ7XG5jbGFzcyBNdXRhdGlvbiB7XG4gIHBhcmFtcztcbiAgY29tcGlsZWQ7XG4gIF9hcHBsaWVzVG9NaXNzaW5nRG9jdW1lbnQ7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gIH1cbiAgZ2V0IHRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnRyYW5zaXRpb247XG4gIH1cbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5pZGVudGl0eTtcbiAgfVxuICBnZXQgcHJldmlvdXNSZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnByZXZpb3VzUmV2O1xuICB9XG4gIGdldCByZXN1bHRSZXYoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLnJlc3VsdFJldjtcbiAgfVxuICBnZXQgbXV0YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmFtcy5tdXRhdGlvbnM7XG4gIH1cbiAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMucGFyYW1zLnRpbWVzdGFtcCA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMucGFyYW1zLnRpbWVzdGFtcCk7XG4gIH1cbiAgZ2V0IGVmZmVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyYW1zLmVmZmVjdHM7XG4gIH1cbiAgYXNzaWduUmFuZG9tVHJhbnNhY3Rpb25JZCgpIHtcbiAgICB0aGlzLnBhcmFtcy50cmFuc2FjdGlvbklkID0gbHVpZCgpLCB0aGlzLnBhcmFtcy5yZXN1bHRSZXYgPSB0aGlzLnBhcmFtcy50cmFuc2FjdGlvbklkO1xuICB9XG4gIGFwcGxpZXNUb01pc3NpbmdEb2N1bWVudCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2FwcGxpZXNUb01pc3NpbmdEb2N1bWVudCA8IFwidVwiKVxuICAgICAgcmV0dXJuIHRoaXMuX2FwcGxpZXNUb01pc3NpbmdEb2N1bWVudDtcbiAgICBjb25zdCBmaXJzdE11dCA9IHRoaXMubXV0YXRpb25zWzBdO1xuICAgIHJldHVybiBmaXJzdE11dCA/IHRoaXMuX2FwcGxpZXNUb01pc3NpbmdEb2N1bWVudCA9ICEhKGZpcnN0TXV0LmNyZWF0ZSB8fCBmaXJzdE11dC5jcmVhdGVJZk5vdEV4aXN0cyB8fCBmaXJzdE11dC5jcmVhdGVPclJlcGxhY2UpIDogdGhpcy5fYXBwbGllc1RvTWlzc2luZ0RvY3VtZW50ID0gITAsIHRoaXMuX2FwcGxpZXNUb01pc3NpbmdEb2N1bWVudDtcbiAgfVxuICAvLyBDb21waWxlcyBhbGwgbXV0YXRpb25zIGludG8gYSBoYW5keSBmdW5jdGlvblxuICBjb21waWxlKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXSwgZ2V0R3VhcmFudGVlZENyZWF0ZWRBdCA9IChkb2MpID0+IGRvYz8uX2NyZWF0ZWRBdCB8fCB0aGlzLnBhcmFtcy50aW1lc3RhbXAgfHwgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xuICAgIHRoaXMubXV0YXRpb25zLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICBpZiAobXV0YXRpb24uY3JlYXRlKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZSA9IG11dGF0aW9uLmNyZWF0ZSB8fCB7fTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKChkb2MpID0+IGRvYyB8fCBPYmplY3QuYXNzaWduKGNyZWF0ZSwge1xuICAgICAgICAgIF9jcmVhdGVkQXQ6IGdldEd1YXJhbnRlZWRDcmVhdGVkQXQoY3JlYXRlKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtdXRhdGlvbi5jcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgICBjb25zdCBjcmVhdGVJZk5vdEV4aXN0cyA9IG11dGF0aW9uLmNyZWF0ZUlmTm90RXhpc3RzIHx8IHt9O1xuICAgICAgICBvcGVyYXRpb25zLnB1c2goXG4gICAgICAgICAgKGRvYykgPT4gZG9jID09PSBudWxsID8gT2JqZWN0LmFzc2lnbihjcmVhdGVJZk5vdEV4aXN0cywge1xuICAgICAgICAgICAgX2NyZWF0ZWRBdDogZ2V0R3VhcmFudGVlZENyZWF0ZWRBdChjcmVhdGVJZk5vdEV4aXN0cylcbiAgICAgICAgICB9KSA6IGRvY1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0YXRpb24uY3JlYXRlT3JSZXBsYWNlKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZU9yUmVwbGFjZSA9IG11dGF0aW9uLmNyZWF0ZU9yUmVwbGFjZSB8fCB7fTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKFxuICAgICAgICAgICgpID0+IE9iamVjdC5hc3NpZ24oY3JlYXRlT3JSZXBsYWNlLCB7XG4gICAgICAgICAgICBfY3JlYXRlZEF0OiBnZXRHdWFyYW50ZWVkQ3JlYXRlZEF0KGNyZWF0ZU9yUmVwbGFjZSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobXV0YXRpb24uZGVsZXRlKSB7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCgoKSA9PiBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG11dGF0aW9uLnBhdGNoKSB7XG4gICAgICAgIGlmIChcInF1ZXJ5XCIgaW4gbXV0YXRpb24ucGF0Y2gpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBQYXRjaGVyKG11dGF0aW9uLnBhdGNoKTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKChkb2MpID0+IHBhdGNoLmFwcGx5KGRvYykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG11dGF0aW9uICR7SlNPTi5zdHJpbmdpZnkobXV0YXRpb24sIG51bGwsIDIpfWApO1xuICAgIH0pLCB0eXBlb2YgdGhpcy5wYXJhbXMudGltZXN0YW1wID09IFwic3RyaW5nXCIgJiYgb3BlcmF0aW9ucy5wdXNoKChkb2MpID0+IGRvYyA/IE9iamVjdC5hc3NpZ24oZG9jLCB7IF91cGRhdGVkQXQ6IHRoaXMucGFyYW1zLnRpbWVzdGFtcCB9KSA6IG51bGwpO1xuICAgIGNvbnN0IHByZXZSZXYgPSB0aGlzLnByZXZpb3VzUmV2LCByZXYgPSB0aGlzLnJlc3VsdFJldiB8fCB0aGlzLnRyYW5zYWN0aW9uSWQ7XG4gICAgdGhpcy5jb21waWxlZCA9IChkb2MpID0+IHtcbiAgICAgIGlmIChwcmV2UmV2ICYmIGRvYyAmJiBwcmV2UmV2ICE9PSBkb2MuX3JldilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQcmV2aW91cyByZXZpc2lvbiBmb3IgdGhpcyBtdXRhdGlvbiB3YXMgJHtwcmV2UmV2fSwgYnV0IHRoZSBkb2N1bWVudCByZXZpc2lvbiBpcyAke2RvYy5fcmV2fWBcbiAgICAgICAgKTtcbiAgICAgIGxldCByZXN1bHQgPSBkb2M7XG4gICAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKVxuICAgICAgICByZXN1bHQgPSBvcGVyYXRpb24ocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQgJiYgcmV2ICYmIChyZXN1bHQgPT09IGRvYyAmJiAocmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgZG9jKSksIHJlc3VsdC5fcmV2ID0gcmV2KSwgcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgYXBwbHkoZG9jdW1lbnQpIHtcbiAgICBkZWJ1ZyhcIkFwcGx5aW5nIG11dGF0aW9uICVPIHRvIGRvY3VtZW50ICVPXCIsIHRoaXMubXV0YXRpb25zLCBkb2N1bWVudCksIHRoaXMuY29tcGlsZWQgfHwgdGhpcy5jb21waWxlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jb21waWxlZChkb2N1bWVudCk7XG4gICAgcmV0dXJuIGRlYnVnKFwiICA9PiAlT1wiLCByZXN1bHQpLCByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFwcGx5QWxsKGRvY3VtZW50LCBtdXRhdGlvbnMpIHtcbiAgICByZXR1cm4gbXV0YXRpb25zLnJlZHVjZSgoZG9jLCBtdXRhdGlvbikgPT4gbXV0YXRpb24uYXBwbHkoZG9jKSwgZG9jdW1lbnQpO1xuICB9XG4gIC8vIEdpdmVuIGEgbnVtYmVyIG9mIHlldC10by1iZS1jb21taXR0ZWQgbXV0YXRpb24gb2JqZWN0cywgY29sbGVjdHMgdGhlbSBpbnRvIG9uZSBiaWcgbXV0YXRpb25cbiAgLy8gYW55IG1ldGFkYXRhIGxpa2UgdHJhbnNhY3Rpb25JZCBpcyBpZ25vcmVkIGFuZCBtdXN0IGJlIHN1Ym1pdHRlZCBieSB0aGUgY2xpZW50LiBJdCBpcyBhc3N1bWVkXG4gIC8vIHRoYXQgYWxsIG11dGF0aW9ucyBhcmUgb24gdGhlIHNhbWUgZG9jdW1lbnQuXG4gIC8vIFRPT086IE9wdGltaXplIG11dGF0aW9ucywgZWxpbWluYXRpbmcgbXV0YXRpb25zIHRoYXQgb3ZlcndyaXRlIHRoZW1zZWx2ZXMhXG4gIHN0YXRpYyBzcXVhc2goZG9jdW1lbnQsIG11dGF0aW9ucykge1xuICAgIGNvbnN0IHNxdWFzaGVkID0gbXV0YXRpb25zLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIG11dGF0aW9uKSA9PiByZXN1bHQuY29uY2F0KC4uLm11dGF0aW9uLm11dGF0aW9ucyksXG4gICAgICBbXVxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBNdXRhdGlvbih7IG11dGF0aW9uczogc3F1YXNoZWQgfSk7XG4gIH1cbn1cbmNsYXNzIERvY3VtZW50IHtcbiAgLyoqXG4gICAqIEluY29taW5nIHBhdGNoZXMgZnJvbSB0aGUgc2VydmVyIHdhaXRpbmcgdG8gYmUgYXBwbGllZCB0byBIRUFEXG4gICAqL1xuICBpbmNvbWluZyA9IFtdO1xuICAvKipcbiAgICogUGF0Y2hlcyB3ZSBrbm93IGhhcyBiZWVuIHN1Yml0dGVkIHRvIHRoZSBzZXJ2ZXIsIGJ1dCBoYXMgbm90IGJlZW4gc2VlbiB5ZXQgaW4gdGhlIHJldHVybiBjaGFubmVsXG4gICAqIHNvIHdlIGNhbid0IGJlIHN1cmUgYWJvdXQgdGhlIG9yZGVyaW5nIHlldCAoc29tZW9uZSBlbHNlIG1pZ2h0IGhhdmUgc2xpcHBlZCBzb21ldGhpbmcgYmV0d2VlbiB0aGVtKVxuICAgKi9cbiAgc3VibWl0dGVkID0gW107XG4gIC8qKlxuICAgKiBQZW5kaW5nIG11dGF0aW9uc1xuICAgKi9cbiAgcGVuZGluZyA9IFtdO1xuICAvKipcbiAgICogT3VyIG1vZGVsIG9mIHRoZSBkb2N1bWVudCBhY2NvcmRpbmcgdG8gdGhlIGluY29taW5nIHBhdGNoZXMgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBIRUFEO1xuICAvKipcbiAgICogT3VyIG9wdGltaXN0aWMgbW9kZWwgb2Ygd2hhdCB0aGUgZG9jdW1lbnQgd2lsbCBwcm9iYWJseSBsb29rIGxpa2UgYXMgc29vbiBhcyBhbGwgb3VyIHBhdGNoZXNcbiAgICogaGF2ZSBiZWVuIHByb2Nlc3NlZC4gVXBkYXRlZCBldmVyeSB0aW1lIHdlIHN0YWdlIGEgbmV3IG11dGF0aW9uLCBidXQgYWxzbyBtaWdodCByZXZlcnQgYmFja1xuICAgKiB0byBwcmV2aW91cyBzdGF0ZXMgaWYgb3VyIG11dGF0aW9ucyBmYWlsLCBvciBjb3VsZCBjaGFuZ2UgaWYgdW5leHBlY3RlZCBtdXRhdGlvbnMgYXJyaXZlXG4gICAqIGJldHdlZW4gb3VyIG93bi4gVGhlIGBvblJlYmFzZWAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBFREdFIGNoYW5nZXMgaW4gdGhpcyBtYW5uZXIuXG4gICAqL1xuICBFREdFO1xuICAvKipcbiAgICogQ2FsbGVkIHdpdGggdGhlIEVER0UgZG9jdW1lbnQgd2hlbiB0aGF0IGRvY3VtZW50IGNoYW5nZXMgZm9yIGEgcmVhc29uIG90aGVyIHRoYW4gdXMgc3RhZ2luZ1xuICAgKiBhIG5ldyBwYXRjaCBvciByZWNlaXZpbmcgYSBtdXRhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgd2hpbGUgb3VyIEVER0UgaXMgaW4gc3luYyB3aXRoIEhFQUQ6XG4gICAqIEkuZS4gd2hlbiBFREdFIGNoYW5nZXMgYmVjYXVzZSB0aGUgb3JkZXIgb2YgbXV0YXRpb25zIGhhcyBjaGFuZ2VkIGluIHJlbGF0aW9uIHRvIG91clxuICAgKiBvcHRpbWlzdGljIHByZWRpY3Rpb25zLlxuICAgKi9cbiAgb25SZWJhc2U7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB3ZSByZWNlaXZlIGEgcGF0Y2ggaW4gdGhlIG5vcm1hbCBvcmRlciBvZiB0aGluZ3MsIGJ1dCB0aGUgbXV0YXRpb24gaXMgbm90IG91cnNcbiAgICovXG4gIG9uTXV0YXRpb247XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBjb25zaXN0ZW5jeSBzdGF0ZSBjaGFuZ2VzIHdpdGggdGhlIGJvb2xlYW4gdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29uc2lzdGVuY3kgc3RhdGVcbiAgICovXG4gIG9uQ29uc2lzdGVuY3lDaGFuZ2VkO1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluY29taW5nIG11dGF0aW9uIGNvbWVzIGluLiBUaGVzZSBhcmUgYWx3YXlzIG9yZGVyZWQgY29ycmVjdGx5LlxuICAgKi9cbiAgb25SZW1vdGVNdXRhdGlvbjtcbiAgLyoqXG4gICAqIFdlIGFyZSBjb25zaXN0ZW50IHdoZW4gdGhlcmUgYXJlIG5vIHVucmVzb2x2ZWQgbXV0YXRpb25zIG9mIG91ciBvd24sIGFuZCBubyB1bi1hcHBsaWNhYmxlXG4gICAqIGluY29taW5nIG11dGF0aW9ucy4gV2hlbiB0aGlzIGhhcyBiZWVuIGdvaW5nIG9uIGZvciB0b28gbG9uZywgYW5kIHRoZXJlIGhhcyBiZWVuIGEgd2hpbGVcbiAgICogc2luY2Ugd2Ugc3RhZ2VkIGEgbmV3IG11dGF0aW9uLCBpdCBpcyB0aW1lIHRvIHJlc2V0IHlvdXIgc3RhdGUuXG4gICAqL1xuICBpbmNvbnNpc3RlbnRBdCA9IG51bGw7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCB0aW1lIHdlIHN0YWdlZCBhIHBhdGNoIG9mIG91ciBvd24uIElmIHdlIGhhdmUgYmVlbiBpbmNvbnNpc3RlbnQgZm9yIGEgd2hpbGUsIGJ1dCBpdFxuICAgKiBoYXNuJ3QgYmVlbiBsb25nIHNpbmNlIHdlIHN0YWdlZCBhIG5ldyBtdXRhdGlvbiwgdGhlIHJlYXNvbiBpcyBwcm9iYWJseSBqdXN0IGJlY2F1c2UgdGhlIHVzZXJcbiAgICogaXMgdHlwaW5nIG9yIHNvbWV0aGluZy5cbiAgICpcbiAgICogU2hvdWxkIGJlIHVzZWQgYXMgYSBndWFyZCBhZ2FpbnN0IHJlc2V0dGluZyBzdGF0ZSBmb3IgaW5jb25zaXN0ZW5jeSByZWFzb25zLlxuICAgKi9cbiAgbGFzdFN0YWdlZEF0ID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgdGhpcy5yZXNldChkb2MpLCB0aGlzLkhFQUQgPSBkb2MsIHRoaXMuRURHRSA9IGRvYztcbiAgfVxuICAvLyBSZXNldCB0aGUgc3RhdGUgb2YgdGhlIERvY3VtZW50LCB1c2VkIHRvIHJlY292ZXIgZnJvbSB1bnNhdm9yeSBzdGF0ZXMgYnkgcmVsb2FkaW5nIHRoZSBkb2N1bWVudFxuICByZXNldChkb2MpIHtcbiAgICB0aGlzLmluY29taW5nID0gW10sIHRoaXMuc3VibWl0dGVkID0gW10sIHRoaXMucGVuZGluZyA9IFtdLCB0aGlzLmluY29uc2lzdGVudEF0ID0gbnVsbCwgdGhpcy5IRUFEID0gZG9jLCB0aGlzLkVER0UgPSBkb2MsIHRoaXMuY29uc2lkZXJJbmNvbWluZygpLCB0aGlzLnVwZGF0ZUNvbnNpc3RlbmN5RmxhZygpO1xuICB9XG4gIC8vIENhbGwgd2hlbiBhIG11dGF0aW9uIGFycml2ZXMgZnJvbSBTYW5pdHlcbiAgYXJyaXZlKG11dGF0aW9uKSB7XG4gICAgdGhpcy5pbmNvbWluZy5wdXNoKG11dGF0aW9uKSwgdGhpcy5jb25zaWRlckluY29taW5nKCksIHRoaXMudXBkYXRlQ29uc2lzdGVuY3lGbGFnKCk7XG4gIH1cbiAgLy8gQ2FsbCB0byBzaWduYWwgdGhhdCB3ZSBhcmUgc3VibWl0dGluZyBhIG11dGF0aW9uLiBSZXR1cm5zIGEgY2FsbGJhY2sgb2JqZWN0IHdpdGggYVxuICAvLyBzdWNjZXNzIGFuZCBmYWlsdXJlIGhhbmRsZXIgdGhhdCBtdXN0IGJlIGNhbGxlZCBhY2NvcmRpbmcgdG8gdGhlIG91dGNvbWUgb2Ygb3VyXG4gIC8vIHN1Ym1pc3Npb24uXG4gIHN0YWdlKG11dGF0aW9uLCBzaWxlbnQpIHtcbiAgICBpZiAoIW11dGF0aW9uLnRyYW5zYWN0aW9uSWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXRhdGlvbnMgX211c3RfIGhhdmUgdHJhbnNhY3Rpb25JZCB3aGVuIHN1Ym1pdHRlZFwiKTtcbiAgICB0aGlzLmxhc3RTdGFnZWRBdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBkZWJ1ZyhcIlN0YWdpbmcgbXV0YXRpb24gJXMgKHB1c2hlZCB0byBwZW5kaW5nKVwiLCBtdXRhdGlvbi50cmFuc2FjdGlvbklkKSwgdGhpcy5wZW5kaW5nLnB1c2gobXV0YXRpb24pLCB0aGlzLkVER0UgPSBtdXRhdGlvbi5hcHBseSh0aGlzLkVER0UpLCB0aGlzLm9uTXV0YXRpb24gJiYgIXNpbGVudCAmJiB0aGlzLm9uTXV0YXRpb24oe1xuICAgICAgbXV0YXRpb24sXG4gICAgICBkb2N1bWVudDogdGhpcy5FREdFLFxuICAgICAgcmVtb3RlOiAhMVxuICAgIH0pO1xuICAgIGNvbnN0IHR4bklkID0gbXV0YXRpb24udHJhbnNhY3Rpb25JZDtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVDb25zaXN0ZW5jeUZsYWcoKSwge1xuICAgICAgc3VjY2VzczogKCkgPT4ge1xuICAgICAgICB0aGlzLnBlbmRpbmdTdWNjZXNzZnVsbHlTdWJtaXR0ZWQodHhuSWQpLCB0aGlzLnVwZGF0ZUNvbnNpc3RlbmN5RmxhZygpO1xuICAgICAgfSxcbiAgICAgIGZhaWx1cmU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nRmFpbGVkKHR4bklkKSwgdGhpcy51cGRhdGVDb25zaXN0ZW5jeUZsYWcoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8vIENhbGwgdG8gY2hlY2sgaWYgZXZlcnl0aGluZyBpcyBuaWNlIGFuZCBxdWlldCBhbmQgdGhlcmUgYXJlIG5vIHVucmVzb2x2ZWQgbXV0YXRpb25zLlxuICAvLyBNZWFucyB0aGlzIG1vZGVsIHRoaW5rcyBib3RoIEhFQUQgYW5kIEVER0UgaXMgdXAgdG8gZGF0ZSB3aXRoIHdoYXQgdGhlIHNlcnZlciBzZWVzLlxuICBpc0NvbnNpc3RlbnQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmluY29uc2lzdGVudEF0O1xuICB9XG4gIC8vIFByaXZhdGVcbiAgLy8gQXR0ZW1wdHMgdG8gYXBwbHkgYW55IHJlc29sdmFibGUgaW5jb21pbmcgcGF0Y2hlcyB0byBIRUFELiBXaWxsIGtlZXAgcGF0Y2hpbmcgYXMgbG9uZyBhcyB0aGVyZVxuICAvLyBhcmUgYXBwbGljYWJsZSBwYXRjaGVzIHRvIGJlIGFwcGxpZWRcbiAgY29uc2lkZXJJbmNvbWluZygpIHtcbiAgICBsZXQgbXVzdFJlYmFzZSA9ICExLCBuZXh0TXV0O1xuICAgIGNvbnN0IHJlYmFzZU11dGF0aW9ucyA9IFtdO1xuICAgIGlmICh0aGlzLkhFQUQgJiYgdGhpcy5IRUFELl91cGRhdGVkQXQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG5ldyBEYXRlKHRoaXMuSEVBRC5fdXBkYXRlZEF0KTtcbiAgICAgIHRoaXMuaW5jb21pbmcuZmluZCgobXV0KSA9PiBtdXQudGltZXN0YW1wICYmIG11dC50aW1lc3RhbXAgPCB1cGRhdGVkQXQpICYmICh0aGlzLmluY29taW5nID0gdGhpcy5pbmNvbWluZy5maWx0ZXIoKG11dCkgPT4gbXV0LnRpbWVzdGFtcCAmJiBtdXQudGltZXN0YW1wIDwgdXBkYXRlZEF0KSk7XG4gICAgfVxuICAgIGxldCBwcm90ZWN0ID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5IRUFEKSB7XG4gICAgICAgIGNvbnN0IEhFQUQgPSB0aGlzLkhFQUQ7XG4gICAgICAgIG5leHRNdXQgPSBIRUFELl9yZXYgPyB0aGlzLmluY29taW5nLmZpbmQoKG11dCkgPT4gbXV0LnByZXZpb3VzUmV2ID09PSBIRUFELl9yZXYpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5leHRNdXQgPSB0aGlzLmluY29taW5nLmZpbmQoKG11dCkgPT4gbXV0LmFwcGxpZXNUb01pc3NpbmdEb2N1bWVudCgpKTtcbiAgICAgIGlmIChuZXh0TXV0KSB7XG4gICAgICAgIGNvbnN0IGFwcGxpZWQgPSB0aGlzLmFwcGx5SW5jb21pbmcobmV4dE11dCk7XG4gICAgICAgIGlmIChtdXN0UmViYXNlID0gbXVzdFJlYmFzZSB8fCBhcHBsaWVkLCBtdXN0UmViYXNlICYmIHJlYmFzZU11dGF0aW9ucy5wdXNoKG5leHRNdXQpLCBwcm90ZWN0KysgPiAxMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTXV0YXRvciBzdHVjayBmbHVzaGluZyBpbmNvbWluZyBtdXRhdGlvbnMuIFByb2JhYmx5IHN0dWNrIGhlcmU6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIG5leHRNdXRcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAobmV4dE11dCk7XG4gICAgdGhpcy5pbmNvbWluZy5sZW5ndGggPiAwICYmIGRlYnVnLmVuYWJsZWQgJiYgZGVidWcoXG4gICAgICBcIlVuYWJsZSB0byBhcHBseSBtdXRhdGlvbnMgJXNcIixcbiAgICAgIHRoaXMuaW5jb21pbmcubWFwKChtdXQpID0+IG11dC50cmFuc2FjdGlvbklkKS5qb2luKFwiLCBcIilcbiAgICApLCBtdXN0UmViYXNlICYmIHRoaXMucmViYXNlKHJlYmFzZU11dGF0aW9ucyk7XG4gIH1cbiAgLy8gY2hlY2sgY3VycmVudCBjb25zaXN0ZW5jeSBzdGF0ZSwgdXBkYXRlIGZsYWcgYW5kIGludm9rZSBjYWxsYmFjayBpZiBuZWVkZWRcbiAgdXBkYXRlQ29uc2lzdGVuY3lGbGFnKCkge1xuICAgIGNvbnN0IHdhc0NvbnNpc3RlbnQgPSB0aGlzLmlzQ29uc2lzdGVudCgpLCBpc0NvbnNpc3RlbnQgPSB0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwICYmIHRoaXMuc3VibWl0dGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmluY29taW5nLmxlbmd0aCA9PT0gMDtcbiAgICBpc0NvbnNpc3RlbnQgPyB0aGlzLmluY29uc2lzdGVudEF0ID0gbnVsbCA6IHRoaXMuaW5jb25zaXN0ZW50QXQgfHwgKHRoaXMuaW5jb25zaXN0ZW50QXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSksIHdhc0NvbnNpc3RlbnQgIT0gaXNDb25zaXN0ZW50ICYmIHRoaXMub25Db25zaXN0ZW5jeUNoYW5nZWQgJiYgKGRlYnVnKGlzQ29uc2lzdGVudCA/IFwiQnVmZmVyZWQgZG9jdW1lbnQgaXMgaW5jb25zaXN0ZW50XCIgOiBcIkJ1ZmZlcmVkIGRvY3VtZW50IGlzIGNvbnNpc3RlbnRcIiksIHRoaXMub25Db25zaXN0ZW5jeUNoYW5nZWQoaXNDb25zaXN0ZW50KSk7XG4gIH1cbiAgLy8gYXBwbHkgYW4gaW5jb21pbmcgcGF0Y2ggdGhhdCBoYXMgYmVlbiBwcmVxdWFsaWZpZWQgYXMgdGhlIG5leHQgaW4gbGluZSBmb3IgdGhpcyBkb2N1bWVudFxuICBhcHBseUluY29taW5nKG11dCkge1xuICAgIGlmICghbXV0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghbXV0LnRyYW5zYWN0aW9uSWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlZCBpbmNvbWluZyBtdXRhdGlvbiB3aXRob3V0IGEgdHJhbnNhY3Rpb24gSURcIik7XG4gICAgaWYgKGRlYnVnKFxuICAgICAgXCJBcHBseWluZyBtdXRhdGlvbiAlcyAtPiAlcyB0byByZXYgJXNcIixcbiAgICAgIG11dC5wcmV2aW91c1JldixcbiAgICAgIG11dC5yZXN1bHRSZXYsXG4gICAgICB0aGlzLkhFQUQgJiYgdGhpcy5IRUFELl9yZXZcbiAgICApLCB0aGlzLkhFQUQgPSBtdXQuYXBwbHkodGhpcy5IRUFEKSwgdGhpcy5vblJlbW90ZU11dGF0aW9uICYmIHRoaXMub25SZW1vdGVNdXRhdGlvbihtdXQpLCB0aGlzLmluY29taW5nID0gdGhpcy5pbmNvbWluZy5maWx0ZXIoKG0pID0+IG0udHJhbnNhY3Rpb25JZCAhPT0gbXV0LnRyYW5zYWN0aW9uSWQpLCB0aGlzLmhhc1VucmVzb2x2ZWRNdXRhdGlvbnMoKSkge1xuICAgICAgY29uc3QgbmVlZFJlYmFzZSA9IHRoaXMuY29uc3VtZVVucmVzb2x2ZWQobXV0LnRyYW5zYWN0aW9uSWQpO1xuICAgICAgcmV0dXJuIGRlYnVnLmVuYWJsZWQgJiYgKGRlYnVnKFxuICAgICAgICBgSW5jb21pbmcgbXV0YXRpb24gJHttdXQudHJhbnNhY3Rpb25JZH0gYXBwZWFyZWQgd2hpbGUgdGhlcmUgd2VyZSBwZW5kaW5nIG9yIHN1Ym1pdHRlZCBsb2NhbCBtdXRhdGlvbnNgXG4gICAgICApLCBkZWJ1ZyhgU3VibWl0dGVkIHR4bklkczogJHt0aGlzLnN1Ym1pdHRlZC5tYXAoKG0pID0+IG0udHJhbnNhY3Rpb25JZCkuam9pbihcIiwgXCIpfWApLCBkZWJ1ZyhgUGVuZGluZyB0eG5JZHM6ICR7dGhpcy5wZW5kaW5nLm1hcCgobSkgPT4gbS50cmFuc2FjdGlvbklkKS5qb2luKFwiLCBcIil9YCksIGRlYnVnKFwibmVlZFJlYmFzZSA9PT0gJXNcIiwgbmVlZFJlYmFzZSkpLCBuZWVkUmViYXNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVidWcoXG4gICAgICBcIlJlbW90ZSBtdXRhdGlvbiAlcyBhcnJpdmVkIHcvbyBhbnkgcGVuZGluZyBvciBzdWJtaXR0ZWQgbG9jYWwgbXV0YXRpb25zXCIsXG4gICAgICBtdXQudHJhbnNhY3Rpb25JZFxuICAgICksIHRoaXMuRURHRSA9IHRoaXMuSEVBRCwgdGhpcy5vbk11dGF0aW9uICYmIHRoaXMub25NdXRhdGlvbih7XG4gICAgICBtdXRhdGlvbjogbXV0LFxuICAgICAgZG9jdW1lbnQ6IHRoaXMuRURHRSxcbiAgICAgIHJlbW90ZTogITBcbiAgICB9KSwgITE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgdW5yZXNvbHZlZCBtdXRhdGlvbnMgYmV0d2VlbiBIRUFEIGFuZCBFREdFLCBtZWFuaW5nIHdlIGhhdmVcbiAgICogbXV0YXRpb25zIHRoYXQgYXJlIHN0aWxsIHdhaXRpbmcgdG8gYmUgZWl0aGVyIHN1Ym1pdHRlZCwgb3IgdG8gYmUgY29uZmlybWVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIHVucmVzb2x2ZWQgbXV0YXRpb25zIGJldHdlZW4gSEVBRCBhbmQgRURHRSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBoYXNVbnJlc29sdmVkTXV0YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnN1Ym1pdHRlZC5sZW5ndGggPiAwIHx8IHRoaXMucGVuZGluZy5sZW5ndGggPiAwO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIGFuIGluY29taW5nIG11dGF0aW9uIGlzIGFwcGxpZWQgdG8gSEVBRCwgdGhpcyBpcyBjYWxsZWQgdG8gcmVtb3ZlIHRoZSBtdXRhdGlvbiBmcm9tXG4gICAqIHRoZSB1bnJlc29sdmVkIHN0YXRlLiBJZiB0aGUgbmV3bHkgYXBwbGllZCBwYXRjaCBpcyB0aGUgbmV4dCB1cGNvbWluZyB1bnJlc29sdmVkIG11dGF0aW9uLFxuICAgKiBubyByZWJhc2UgaXMgbmVlZGVkLCBidXQgd2UgbWlnaHQgaGF2ZSB0aGUgd3JvbmcgaWRlYSBhYm91dCB0aGUgb3JkZXJpbmcgb2YgbXV0YXRpb25zLCBzbyBpblxuICAgKiB0aGF0IGNhc2Ugd2UgYXJlIGdpdmVuIHRoZSBmbGFnIGBuZWVkUmViYXNlYCB0byB0ZWxsIHVzIHRoYXQgdGhpcyBtdXRhdGlvbiBhcnJpdmVkIG91dCBvZlxuICAgKiBvcmRlciBpbiB0ZXJtcyBvZiBvdXIgb3B0aW1pc3RpYyB2ZXJzaW9uLCBzbyBhIHJlYmFzZSBpcyBuZWVkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB0eG5JZCAtIFRyYW5zYWN0aW9uIElEIG9mIHRoZSByZW1vdGUgbXV0YXRpb25cbiAgICogQHJldHVybnMgdHJ1ZSBpZiByZWJhc2UgaXMgbmVlZGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGNvbnN1bWVVbnJlc29sdmVkKHR4bklkKSB7XG4gICAgaWYgKHRoaXMuc3VibWl0dGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICh0aGlzLnN1Ym1pdHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmICh0aGlzLnN1Ym1pdHRlZFswXS50cmFuc2FjdGlvbklkID09PSB0eG5JZClcbiAgICAgICAgcmV0dXJuIGRlYnVnKFxuICAgICAgICAgIFwiUmVtb3RlIG11dGF0aW9uICVzIG1hdGNoZXMgdXBjb21pbmcgc3VibWl0dGVkIG11dGF0aW9uLCBjb25zdW1lZCBmcm9tICdzdWJtaXR0ZWQnIGJ1ZmZlclwiLFxuICAgICAgICAgIHR4bklkXG4gICAgICAgICksIHRoaXMuc3VibWl0dGVkLnNoaWZ0KCksICExO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA+IDAgJiYgdGhpcy5wZW5kaW5nWzBdLnRyYW5zYWN0aW9uSWQgPT09IHR4bklkKVxuICAgICAgcmV0dXJuIGRlYnVnKFxuICAgICAgICBcIlJlbW90ZSBtdXRhdGlvbiAlcyBtYXRjaGVzIHVwY29taW5nIHBlbmRpbmcgbXV0YXRpb24sIGNvbnN1bWVkIGZyb20gJ3BlbmRpbmcnIGJ1ZmZlclwiLFxuICAgICAgICB0eG5JZFxuICAgICAgKSwgdGhpcy5wZW5kaW5nLnNoaWZ0KCksICExO1xuICAgIHJldHVybiBkZWJ1ZyhcbiAgICAgIFwiVGhlIG11dGF0aW9uIHdhcyBub3QgdGhlIHVwY29taW5nIG11dGF0aW9uLCBzY3J1YmJpbmcuIFBlbmRpbmc6ICVkLCBTdWJtaXR0ZWQ6ICVkXCIsXG4gICAgICB0aGlzLnBlbmRpbmcubGVuZ3RoLFxuICAgICAgdGhpcy5zdWJtaXR0ZWQubGVuZ3RoXG4gICAgKSwgdGhpcy5zdWJtaXR0ZWQgPSB0aGlzLnN1Ym1pdHRlZC5maWx0ZXIoKG11dCkgPT4gbXV0LnRyYW5zYWN0aW9uSWQgIT09IHR4bklkKSwgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmZpbHRlcigobXV0KSA9PiBtdXQudHJhbnNhY3Rpb25JZCAhPT0gdHhuSWQpLCBkZWJ1ZyhcIkFmdGVyIHNjcnViYmluZzogUGVuZGluZzogJWQsIFN1Ym1pdHRlZDogJWRcIiwgdGhpcy5wZW5kaW5nLmxlbmd0aCwgdGhpcy5zdWJtaXR0ZWQubGVuZ3RoKSwgITA7XG4gIH1cbiAgcGVuZGluZ1N1Y2Nlc3NmdWxseVN1Ym1pdHRlZChwZW5kaW5nVHhuSWQpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMucGVuZGluZ1swXTtcbiAgICBpZiAoZmlyc3QudHJhbnNhY3Rpb25JZCA9PT0gcGVuZGluZ1R4bklkKSB7XG4gICAgICB0aGlzLnBlbmRpbmcuc2hpZnQoKSwgdGhpcy5zdWJtaXR0ZWQucHVzaChmaXJzdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBqdXN0U3VibWl0dGVkO1xuICAgIGNvbnN0IHN0aWxsUGVuZGluZyA9IFtdO1xuICAgIHRoaXMucGVuZGluZy5mb3JFYWNoKChtdXRhdGlvbikgPT4ge1xuICAgICAgaWYgKG11dGF0aW9uLnRyYW5zYWN0aW9uSWQgPT09IHBlbmRpbmdUeG5JZCkge1xuICAgICAgICBqdXN0U3VibWl0dGVkID0gbXV0YXRpb247XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0aWxsUGVuZGluZy5wdXNoKG11dGF0aW9uKTtcbiAgICB9KSwganVzdFN1Ym1pdHRlZCAmJiB0aGlzLnN1Ym1pdHRlZC5wdXNoKGp1c3RTdWJtaXR0ZWQpLCB0aGlzLnBlbmRpbmcgPSBzdGlsbFBlbmRpbmcsIHRoaXMucmViYXNlKFtdKTtcbiAgfVxuICBwZW5kaW5nRmFpbGVkKHBlbmRpbmdUeG5JZCkge1xuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5maWx0ZXIoKG11dGF0aW9uKSA9PiBtdXRhdGlvbi50cmFuc2FjdGlvbklkICE9PSBwZW5kaW5nVHhuSWQpLCB0aGlzLnJlYmFzZShbXSk7XG4gIH1cbiAgcmViYXNlKGluY29taW5nTXV0YXRpb25zKSB7XG4gICAgY29uc3Qgb2xkRWRnZSA9IHRoaXMuRURHRTtcbiAgICB0aGlzLkVER0UgPSBNdXRhdGlvbi5hcHBseUFsbCh0aGlzLkhFQUQsIHRoaXMuc3VibWl0dGVkLmNvbmNhdCh0aGlzLnBlbmRpbmcpKSwgb2xkRWRnZSAhPT0gbnVsbCAmJiB0aGlzLkVER0UgIT09IG51bGwgJiYgKG9sZEVkZ2UuX3JldiA9IHRoaXMuRURHRS5fcmV2KSwgIWlzRXF1YWwodGhpcy5FREdFLCBvbGRFZGdlKSAmJiB0aGlzLm9uUmViYXNlICYmIHRoaXMub25SZWJhc2UodGhpcy5FREdFLCBpbmNvbWluZ011dGF0aW9ucywgdGhpcy5wZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgU3F1YXNoaW5nQnVmZmVyIHtcbiAgLyoqXG4gICAqIFRoZSBkb2N1bWVudCBmb3JtaW5nIHRoZSBiYXNpcyBvZiB0aGlzIHNxdWFzaFxuICAgKi9cbiAgQkFTSVM7XG4gIC8qKlxuICAgKiBUaGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIG91dC1NdXRhdGlvbiBoYXMgYmVlbiBhcHBsaWVkLCBidXQgYmVmb3JlIHRoZSBzdGFnZWRcbiAgICogb3BlcmF0aW9ucyBhcmUgY29tbWl0dGVkLlxuICAgKi9cbiAgUFJFU1RBR0U7XG4gIC8qKlxuICAgKiBzZXRPcGVyYXRpb25zIGNvbnRhaW4gdGhlIGxhdGVzdCBzZXQgb3BlcmF0aW9uIGJ5IHBhdGguIElmIHRoZSBzZXQtb3BlcmF0aW9ucyBhcmVcbiAgICogdXBkYXRpbmcgc3RyaW5ncyB0byBuZXcgc3RyaW5ncywgdGhleSBhcmUgcmV3cml0dGVuIGFzIGRpZmZNYXRjaFBhdGNoIG9wZXJhdGlvbnMsXG4gICAqIGFueSBuZXcgc2V0IG9wZXJhdGlvbnMgb24gdGhlIHNhbWUgcGF0aHMgb3ZlcndyaXRlcyBhbnkgb2xkZXIgc2V0IG9wZXJhdGlvbnMuXG4gICAqIE9ubHkgc2V0LW9wZXJhdGlvbnMgYXNzaWduaW5nIHBsYWluIHZhbHVlcyB0byBwbGFpbiB2YWx1ZXMgZ2V0cyBvcHRpbWl6ZWQgbGlrZSB0aGlzLlxuICAgKi9cbiAgc2V0T3BlcmF0aW9ucztcbiAgLyoqXG4gICAqIGBkb2N1bWVudFByZXNlbnRgIGlzIHRydWUgd2hlbmV2ZXIgd2Uga25vdyB0aGF0IHRoZSBkb2N1bWVudCBtdXN0IGJlIHByZXNlbnQgZHVlXG4gICAqIHRvIHByZWNlZWRpbmcgbXV0YXRpb25zLiBgZmFsc2VgIGltcGxpZXMgdGhhdCBpdCBtYXkgb3IgbWF5IG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgKi9cbiAgZG9jdW1lbnRQcmVzZW50O1xuICAvKipcbiAgICogVGhlIG9wZXJhdGlvbnMgaW4gdGhlIG91dC1NdXRhdGlvbiBhcmUgbm90IGFibGUgdG8gYmUgb3B0aW1pemVkIGFueSBmdXJ0aGVyXG4gICAqL1xuICBvdXQgPSBbXTtcbiAgLyoqXG4gICAqIFN0YWdlZCBtdXRhdGlvbiBvcGVyYXRpb25zXG4gICAqL1xuICBzdGFnZWQ7XG4gIGNvbnN0cnVjdG9yKGRvYykge1xuICAgIGRvYyA/IGRlYnVnKFwiUmVzZXQgbXV0YXRpb24gYnVmZmVyIHRvIHJldiAlc1wiLCBkb2MuX3JldikgOiBkZWJ1ZyhcIlJlc2V0IG11dGF0aW9uIGJ1ZmZlciBzdGF0ZSB0byBkb2N1bWVudCBiZWluZyBkZWxldGVkXCIpLCB0aGlzLnN0YWdlZCA9IFtdLCB0aGlzLnNldE9wZXJhdGlvbnMgPSB7fSwgdGhpcy5kb2N1bWVudFByZXNlbnQgPSAhMSwgdGhpcy5CQVNJUyA9IGRvYywgdGhpcy5QUkVTVEFHRSA9IGRvYztcbiAgfVxuICBhZGQobXV0KSB7XG4gICAgbXV0Lm11dGF0aW9ucy5mb3JFYWNoKChvcCkgPT4gdGhpcy5hZGRPcGVyYXRpb24ob3ApKTtcbiAgfVxuICBoYXNDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLm91dC5sZW5ndGggPiAwIHx8IE9iamVjdC5rZXlzKHRoaXMuc2V0T3BlcmF0aW9ucykubGVuZ3RoID4gMDtcbiAgfVxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIG11dGF0aW9ucyBpbiB0aGlzIGJ1ZmZlci5cbiAgICogQWZ0ZXIgdGhpcyBpcyBkb25lLCB0aGUgYnVmZmVyIGxpZmVjeWNsZSBpcyBvdmVyIGFuZCB0aGUgY2xpZW50IHNob3VsZFxuICAgKiBjcmVhdGUgYW4gbmV3IG9uZSB3aXRoIHRoZSBuZXcsIHVwZGF0ZWQgQkFTSVMuXG4gICAqXG4gICAqIEBwYXJhbSB0eG5JZCAtIFRyYW5zYWN0aW9uIElEXG4gICAqIEByZXR1cm5zIEEgYE11dGF0aW9uYCBpbnN0YW5jZSBpZiB3ZSBoYWQgb3V0Z29pbmcgbXV0YXRpb25zIHBlbmRpbmcsIG51bGwgb3RoZXJ3aXNlXG4gICAqL1xuICBwdXJnZSh0eG5JZCkge1xuICAgIHRoaXMuc3Rhc2hTdGFnZWRPcGVyYXRpb25zKCk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMub3V0Lmxlbmd0aCA+IDAgJiYgKGRlYnVnKFwiUHVyZ2VkIG11dGF0aW9uIGJ1ZmZlclwiKSwgcmVzdWx0ID0gbmV3IE11dGF0aW9uKHtcbiAgICAgIG11dGF0aW9uczogdGhpcy5vdXQsXG4gICAgICByZXN1bHRSZXY6IHR4bklkLFxuICAgICAgdHJhbnNhY3Rpb25JZDogdHhuSWRcbiAgICB9KSksIHRoaXMub3V0ID0gW10sIHRoaXMuZG9jdW1lbnRQcmVzZW50ID0gITEsIHJlc3VsdDtcbiAgfVxuICBhZGRPcGVyYXRpb24ob3ApIHtcbiAgICBpZiAob3AucGF0Y2ggJiYgb3AucGF0Y2guc2V0ICYmIFwiaWRcIiBpbiBvcC5wYXRjaCAmJiBvcC5wYXRjaC5pZCA9PT0gdGhpcy5QUkVTVEFHRT8uX2lkICYmIE9iamVjdC5rZXlzKG9wLnBhdGNoKS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IHNldFBhdGNoID0gb3AucGF0Y2guc2V0LCB1bm9wdGltaXphYmxlID0ge307XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2V0UGF0Y2gpKVxuICAgICAgICBzZXRQYXRjaC5oYXNPd25Qcm9wZXJ0eShwYXRoKSAmJiAodGhpcy5vcHRpbWlzZVNldE9wZXJhdGlvbihwYXRoLCBzZXRQYXRjaFtwYXRoXSkgfHwgKHVub3B0aW1pemFibGVbcGF0aF0gPSBzZXRQYXRjaFtwYXRoXSkpO1xuICAgICAgT2JqZWN0LmtleXModW5vcHRpbWl6YWJsZSkubGVuZ3RoID4gMCAmJiAoZGVidWcoXCJVbm9wdGltaXphYmxlIHNldC1vcGVyYXRpb24gZGV0ZWN0ZWQsIHB1cmdpbmcgb3B0aW1pemF0aW9uIGJ1ZmZlclwiKSwgdGhpcy5zdGFnZWQucHVzaCh7IHBhdGNoOiB7IGlkOiB0aGlzLlBSRVNUQUdFLl9pZCwgc2V0OiB1bm9wdGltaXphYmxlIH0gfSksIHRoaXMuc3Rhc2hTdGFnZWRPcGVyYXRpb25zKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3AuY3JlYXRlSWZOb3RFeGlzdHMgJiYgdGhpcy5QUkVTVEFHRSAmJiBvcC5jcmVhdGVJZk5vdEV4aXN0cy5faWQgPT09IHRoaXMuUFJFU1RBR0UuX2lkKSB7XG4gICAgICB0aGlzLmRvY3VtZW50UHJlc2VudCB8fCAodGhpcy5zdGFnZWQucHVzaChvcCksIHRoaXMuZG9jdW1lbnRQcmVzZW50ID0gITAsIHRoaXMuc3Rhc2hTdGFnZWRPcGVyYXRpb25zKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWJ1ZyhcIlVub3B0aW1pemFibGUgbXV0YXRpb24gZGV0ZWN0ZWQsIHB1cmdpbmcgb3B0aW1pemF0aW9uIGJ1ZmZlclwiKSwgdGhpcy5zdGFnZWQucHVzaChvcCksIHRoaXMuc3Rhc2hTdGFnZWRPcGVyYXRpb25zKCk7XG4gIH1cbiAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBwZXJmb3JtIG9uZSBzaW5nbGUgc2V0IG9wZXJhdGlvbiBpbiBhbiBvcHRpbWlzZWQgbWFubmVyLCByZXR1cm4gdmFsdWVcbiAgICAgKiByZWZsZWN0cyB3aGV0aGVyIG9yIG5vdCB0aGUgb3BlcmF0aW9uIGNvdWxkIGJlIHBlcmZvcm1lZC5cbiAgXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgSlNPTlBhdGggdG8gdGhlIHNldCBvcGVyYXRpb24gaW4gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0gbmV4dFZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHNldFxuICAgICAqIEByZXR1cm5zIFRydWUgb2Ygb3B0aW1pemVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgb3B0aW1pc2VTZXRPcGVyYXRpb24ocGF0aCwgbmV4dFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBtYXRjaGVzID0gZXh0cmFjdFdpdGhQYXRoKHBhdGgsIHRoaXMuUFJFU1RBR0UpO1xuICAgIGlmIChtYXRjaGVzLmxlbmd0aCAhPT0gMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbMF07XG4gICAgaWYgKHR5cGVvZiBtYXRjaC52YWx1ZSA9PSBcIm9iamVjdFwiIHx8ICF0aGlzLlBSRVNUQUdFKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBvcCA9IG51bGw7XG4gICAgaWYgKG1hdGNoLnZhbHVlID09PSBuZXh0VmFsdWUpXG4gICAgICBvcCA9IG51bGw7XG4gICAgZWxzZSBpZiAodHlwZW9mIG1hdGNoLnZhbHVlID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PSBcInN0cmluZ1wiKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF0Y2ggPSBzdHJpbmdpZnlQYXRjaGVzKG1ha2VQYXRjaGVzKG1hdGNoLnZhbHVlLCBuZXh0VmFsdWUpKTtcbiAgICAgICAgb3AgPSB7IHBhdGNoOiB7IGlkOiB0aGlzLlBSRVNUQUdFLl9pZCwgZGlmZk1hdGNoUGF0Y2g6IHsgW3BhdGhdOiBwYXRjaCB9IH0gfTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgb3AgPSB7IHBhdGNoOiB7IGlkOiB0aGlzLlBSRVNUQUdFLl9pZCwgc2V0OiB7IFtwYXRoXTogbmV4dFZhbHVlIH0gfSB9O1xuICAgIGNvbnN0IGNhbm9uaWNhbFBhdGggPSBhcnJheVRvSlNPTk1hdGNoUGF0aChtYXRjaC5wYXRoKTtcbiAgICByZXR1cm4gb3AgPyB0aGlzLnNldE9wZXJhdGlvbnNbY2Fub25pY2FsUGF0aF0gPSBvcCA6IGRlbGV0ZSB0aGlzLnNldE9wZXJhdGlvbnNbY2Fub25pY2FsUGF0aF0sICEwO1xuICB9XG4gIHN0YXNoU3RhZ2VkT3BlcmF0aW9ucygpIHtcbiAgICBjb25zdCBuZXh0T3BzID0gW107XG4gICAgT2JqZWN0LmtleXModGhpcy5zZXRPcGVyYXRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IG9wID0gdGhpcy5zZXRPcGVyYXRpb25zW2tleV07XG4gICAgICBvcCAmJiBuZXh0T3BzLnB1c2gob3ApO1xuICAgIH0pLCBuZXh0T3BzLnB1c2goLi4udGhpcy5zdGFnZWQpLCBuZXh0T3BzLmxlbmd0aCA+IDAgJiYgKHRoaXMuUFJFU1RBR0UgPSBuZXcgTXV0YXRpb24oeyBtdXRhdGlvbnM6IG5leHRPcHMgfSkuYXBwbHkodGhpcy5QUkVTVEFHRSksIHRoaXMuc3RhZ2VkID0gW10sIHRoaXMuc2V0T3BlcmF0aW9ucyA9IHt9KSwgdGhpcy5vdXQucHVzaCguLi5uZXh0T3BzKTtcbiAgfVxuICAvKipcbiAgICogUmViYXNlcyBnaXZlbiB0aGUgbmV3IGJhc2UtZG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIG5ld0Jhc2lzIC0gTmV3IGJhc2UgZG9jdW1lbnQgdG8gcmViYXNlIG9uXG4gICAqIEByZXR1cm5zIE5ldyBcImVkZ2VcIiBkb2N1bWVudCB3aXRoIGJ1ZmZlcmVkIGNoYW5nZXMgaW50ZWdyYXRlZFxuICAgKi9cbiAgcmViYXNlKG5ld0Jhc2lzKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Rhc2hTdGFnZWRPcGVyYXRpb25zKCksIG5ld0Jhc2lzID09PSBudWxsID8gKHRoaXMub3V0ID0gW10sIHRoaXMuQkFTSVMgPSBuZXdCYXNpcywgdGhpcy5QUkVTVEFHRSA9IG5ld0Jhc2lzLCB0aGlzLmRvY3VtZW50UHJlc2VudCA9ICExKSA6ICh0aGlzLkJBU0lTID0gbmV3QmFzaXMsIHRoaXMub3V0ID8gdGhpcy5QUkVTVEFHRSA9IG5ldyBNdXRhdGlvbih7IG11dGF0aW9uczogdGhpcy5vdXQgfSkuYXBwbHkodGhpcy5CQVNJUykgOiB0aGlzLlBSRVNUQUdFID0gdGhpcy5CQVNJUyksIHRoaXMuUFJFU1RBR0U7XG4gIH1cbn1cbmNvbnN0IE9ORV9NSU5VVEUgPSAxZTMgKiA2MDtcbmNsYXNzIENvbW1pdCB7XG4gIG11dGF0aW9ucztcbiAgdHJpZXM7XG4gIHJlc29sdmU7XG4gIHJlamVjdDtcbiAgY29uc3RydWN0b3IobXV0YXRpb25zLCB7IHJlc29sdmUsIHJlamVjdCB9KSB7XG4gICAgdGhpcy5tdXRhdGlvbnMgPSBtdXRhdGlvbnMsIHRoaXMudHJpZXMgPSAwLCB0aGlzLnJlc29sdmUgPSByZXNvbHZlLCB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgfVxuICBhcHBseShkb2MpIHtcbiAgICByZXR1cm4gTXV0YXRpb24uYXBwbHlBbGwoZG9jLCB0aGlzLm11dGF0aW9ucyk7XG4gIH1cbiAgc3F1YXNoKGRvYykge1xuICAgIGNvbnN0IHJlc3VsdCA9IE11dGF0aW9uLnNxdWFzaChkb2MsIHRoaXMubXV0YXRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0LmFzc2lnblJhbmRvbVRyYW5zYWN0aW9uSWQoKSwgcmVzdWx0O1xuICB9XG59XG5jb25zdCBtdXRSZWR1Y2VyRm4gPSAoYWNjLCBtdXQpID0+IGFjYy5jb25jYXQobXV0Lm11dGF0aW9ucyk7XG5jbGFzcyBCdWZmZXJlZERvY3VtZW50IHtcbiAgbXV0YXRpb25zO1xuICAvKipcbiAgICogVGhlIERvY3VtZW50IHdlIGFyZSB3cmFwcGluZ1xuICAgKi9cbiAgZG9jdW1lbnQ7XG4gIC8qKlxuICAgKiBUaGUgRG9jdW1lbnQgd2l0aCBsb2NhbCBjaGFuZ2VzIGFwcGxpZWRcbiAgICovXG4gIExPQ0FMO1xuICAvKipcbiAgICogQ29tbWl0cyB0aGF0IGFyZSB3YWl0aW5nIHRvIGJlIGRlbGl2ZXJlZCB0byB0aGUgc2VydmVyXG4gICAqL1xuICBjb21taXRzO1xuICAvKipcbiAgICogTG9jYWwgbXV0YXRpb25zIHRoYXQgYXJlIG5vdCBzY2hlZHVsZWQgdG8gYmUgY29tbWl0dGVkIHlldFxuICAgKi9cbiAgYnVmZmVyO1xuICAvKipcbiAgICogQXNzaWduYWJsZSBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBidWZmZXJlZCBkb2N1bWVudCBhcHBsaWVzIGEgbXV0YXRpb25cbiAgICovXG4gIG9uTXV0YXRpb247XG4gIC8qKlxuICAgKiBBc3NpZ25hYmxlIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gYSByZW1vdGUgbXV0YXRpb24gaGFwcGVuZWRcbiAgICovXG4gIG9uUmVtb3RlTXV0YXRpb247XG4gIC8qKlxuICAgKiBBc3NpZ25hYmxlIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGJ1ZmZlcmVkIGRvY3VtZW50IHJlYmFzZWRcbiAgICovXG4gIG9uUmViYXNlO1xuICAvKipcbiAgICogQXNzaWduYWJsZSBldmVudCBoYW5kbGVyIGZvciB3aGVuIHRoZSBkb2N1bWVudCBpcyBkZWxldGVkXG4gICAqL1xuICBvbkRlbGV0ZTtcbiAgLyoqXG4gICAqIEFzc2lnbmFibGUgZXZlbnQgaGFuZGxlciBmb3Igd2hlbiB0aGUgc3RhdGUgb2YgY29uc2lzdGVuY3kgY2hhbmdlZFxuICAgKi9cbiAgb25Db25zaXN0ZW5jeUNoYW5nZWQ7XG4gIC8qKlxuICAgKiBBc3NpZ25hYmxlIGV2ZW50IGhhbmRsZXIgZm9yIHdoZW4gdGhlIGJ1ZmZlcmVkIGRvY3VtZW50IHNob3VsZCBjb21taXQgY2hhbmdlc1xuICAgKi9cbiAgY29tbWl0SGFuZGxlcjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBjdXJyZW50bHkgY29tbWl0aW5nXG4gICAqL1xuICBjb21taXR0ZXJSdW5uaW5nID0gITE7XG4gIGNvbnN0cnVjdG9yKGRvYykge1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFNxdWFzaGluZ0J1ZmZlcihkb2MpLCB0aGlzLmRvY3VtZW50ID0gbmV3IERvY3VtZW50KGRvYyksIHRoaXMuZG9jdW1lbnQub25NdXRhdGlvbiA9IChtc2cpID0+IHRoaXMuaGFuZGxlRG9jTXV0YXRpb24obXNnKSwgdGhpcy5kb2N1bWVudC5vblJlbW90ZU11dGF0aW9uID0gKG11dCkgPT4gdGhpcy5vblJlbW90ZU11dGF0aW9uICYmIHRoaXMub25SZW1vdGVNdXRhdGlvbihtdXQpLCB0aGlzLmRvY3VtZW50Lm9uUmViYXNlID0gKGVkZ2UsIHJlbW90ZU11dGF0aW9ucywgbG9jYWxNdXRhdGlvbnMpID0+IHRoaXMuaGFuZGxlRG9jUmViYXNlKGVkZ2UsIHJlbW90ZU11dGF0aW9ucywgbG9jYWxNdXRhdGlvbnMpLCB0aGlzLmRvY3VtZW50Lm9uQ29uc2lzdGVuY3lDaGFuZ2VkID0gKG1zZykgPT4gdGhpcy5oYW5kbGVEb2NDb25zaXN0ZW5jeUNoYW5nZWQobXNnKSwgdGhpcy5MT0NBTCA9IGRvYywgdGhpcy5tdXRhdGlvbnMgPSBbXSwgdGhpcy5jb21taXRzID0gW107XG4gIH1cbiAgLy8gVXNlZCB0byByZXNldCB0aGUgc3RhdGUgb2YgdGhlIGxvY2FsIGRvY3VtZW50IG1vZGVsLiBJZiB0aGUgbW9kZWwgaGFzIGJlZW4gaW5jb25zaXN0ZW50XG4gIC8vIGZvciB0b28gbG9uZywgaXQgaGFzIHByb2JhYmx5IG1pc3NlZCBhIG5vdGlmaWNhdGlvbiwgYW5kIHNob3VsZCByZWxvYWQgdGhlIGRvY3VtZW50IGZyb20gdGhlIHNlcnZlclxuICByZXNldChkb2MpIHtcbiAgICBkb2MgPyBkZWJ1ZyhcIkRvY3VtZW50IHN0YXRlIHJlc2V0IHRvIHJldmlzaW9uICVzXCIsIGRvYy5fcmV2KSA6IGRlYnVnKFwiRG9jdW1lbnQgc3RhdGUgcmVzZXQgdG8gYmVpbmcgZGVsZXRlZFwiKSwgdGhpcy5kb2N1bWVudC5yZXNldChkb2MpLCB0aGlzLnJlYmFzZShbXSwgW10pLCB0aGlzLmhhbmRsZURvY0NvbnNpc3RlbmN5Q2hhbmdlZCh0aGlzLmRvY3VtZW50LmlzQ29uc2lzdGVudCgpKTtcbiAgfVxuICAvLyBBZGQgYSBjaGFuZ2UgdG8gdGhlIGJ1ZmZlclxuICBhZGQobXV0YXRpb24pIHtcbiAgICB0aGlzLm9uQ29uc2lzdGVuY3lDaGFuZ2VkICYmIHRoaXMub25Db25zaXN0ZW5jeUNoYW5nZWQoITEpLCBkZWJ1ZyhcIlN0YWdlZCBsb2NhbCBtdXRhdGlvblwiKSwgdGhpcy5idWZmZXIuYWRkKG11dGF0aW9uKTtcbiAgICBjb25zdCBvbGRMb2NhbCA9IHRoaXMuTE9DQUw7XG4gICAgdGhpcy5MT0NBTCA9IG11dGF0aW9uLmFwcGx5KHRoaXMuTE9DQUwpLCB0aGlzLm9uTXV0YXRpb24gJiYgb2xkTG9jYWwgIT09IHRoaXMuTE9DQUwgJiYgKGRlYnVnKFwib25NdXRhdGlvbiBmaXJlZFwiKSwgdGhpcy5vbk11dGF0aW9uKHtcbiAgICAgIG11dGF0aW9uLFxuICAgICAgZG9jdW1lbnQ6IHRoaXMuTE9DQUwsXG4gICAgICByZW1vdGU6ICExXG4gICAgfSksIHRoaXMuTE9DQUwgPT09IG51bGwgJiYgdGhpcy5vbkRlbGV0ZSAmJiB0aGlzLm9uRGVsZXRlKHRoaXMuTE9DQUwpKTtcbiAgfVxuICAvLyBDYWxsIHdoZW4gYSBtdXRhdGlvbiBhcnJpdmVzIGZyb20gU2FuaXR5XG4gIGFycml2ZShtdXRhdGlvbikge1xuICAgIGlmIChkZWJ1ZyhcIlJlbW90ZSBtdXRhdGlvbiBhcnJpdmVkICVzIC0+ICVzXCIsIG11dGF0aW9uLnByZXZpb3VzUmV2LCBtdXRhdGlvbi5yZXN1bHRSZXYpLCBtdXRhdGlvbi5wcmV2aW91c1JldiA9PT0gbXV0YXRpb24ucmVzdWx0UmV2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTXV0YXRpb24gJHttdXRhdGlvbi50cmFuc2FjdGlvbklkfSBoYXMgcHJldmlvdXNSZXYgPT09IHJlc3VsdFJldiAoJHttdXRhdGlvbi5wcmV2aW91c1Jldn0pYFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5hcnJpdmUobXV0YXRpb24pO1xuICB9XG4gIC8vIFN1Ym1pdCBhbGwgbXV0YXRpb25zIGluIHRoZSBidWZmZXIgdG8gYmUgY29tbWl0dGVkXG4gIGNvbW1pdCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1ZmZlci5oYXNDaGFuZ2VzKCkpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWJ1ZyhcIkNvbW1pdHRpbmcgbG9jYWwgY2hhbmdlc1wiKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdNdXRhdGlvbnMgPSB0aGlzLmJ1ZmZlci5wdXJnZSgpO1xuICAgICAgdGhpcy5jb21taXRzLnB1c2gobmV3IENvbW1pdChwZW5kaW5nTXV0YXRpb25zID8gW3BlbmRpbmdNdXRhdGlvbnNdIDogW10sIHsgcmVzb2x2ZSwgcmVqZWN0IH0pKSwgdGhpcy5idWZmZXIgPSBuZXcgU3F1YXNoaW5nQnVmZmVyKHRoaXMuTE9DQUwpLCB0aGlzLnBlcmZvcm1Db21taXRzKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhcnRzIHRoZSBjb21taXR0ZXIgdGhhdCB3aWxsIHRyeSB0byBjb21taXR0IGFsbCBzdGFnZWQgY29tbWl0cyB0byB0aGUgZGF0YWJhc2VcbiAgLy8gYnkgY2FsbGluZyB0aGUgY29tbWl0SGFuZGxlci4gV2lsbCBrZWVwIHJ1bm5pbmcgdW50aWwgYWxsIGNvbW1pdHMgYXJlIHN1Y2Nlc3NmdWxseVxuICAvLyBjb21taXR0ZWQuXG4gIHBlcmZvcm1Db21taXRzKCkge1xuICAgIGlmICghdGhpcy5jb21taXRIYW5kbGVyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29tbWl0SGFuZGxlciBjb25maWd1cmVkIGZvciB0aGlzIEJ1ZmZlcmVkRG9jdW1lbnRcIik7XG4gICAgdGhpcy5jb21taXR0ZXJSdW5uaW5nIHx8IHRoaXMuX2N5Y2xlQ29tbWl0dGVyKCk7XG4gIH1cbiAgLy8gVE9ETzogRXJyb3IgaGFuZGxpbmcsIHJpZ2h0IG5vdyByZXRyaWVzIGFmdGVyIGV2ZXJ5IGVycm9yXG4gIF9jeWNsZUNvbW1pdHRlcigpIHtcbiAgICBjb25zdCBjb21taXQgPSB0aGlzLmNvbW1pdHMuc2hpZnQoKTtcbiAgICBpZiAoIWNvbW1pdCkge1xuICAgICAgdGhpcy5jb21taXR0ZXJSdW5uaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29tbWl0dGVyUnVubmluZyA9ICEwO1xuICAgIGNvbnN0IHNxdWFzaGVkID0gY29tbWl0LnNxdWFzaCh0aGlzLkxPQ0FMKSwgZG9jUmVzcG9uZGVyID0gdGhpcy5kb2N1bWVudC5zdGFnZShzcXVhc2hlZCwgITApLCByZXNwb25kZXIgPSB7XG4gICAgICBzdWNjZXNzOiAoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiQ29tbWl0IHN1Y2NlZWRlZFwiKSwgZG9jUmVzcG9uZGVyLnN1Y2Nlc3MoKSwgY29tbWl0LnJlc29sdmUoKSwgdGhpcy5fY3ljbGVDb21taXR0ZXIoKTtcbiAgICAgIH0sXG4gICAgICBmYWlsdXJlOiAoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiQ29tbWl0IGZhaWxlZFwiKSwgY29tbWl0LnRyaWVzICs9IDEsIHRoaXMuTE9DQUwgIT09IG51bGwgJiYgdGhpcy5jb21taXRzLnVuc2hpZnQoY29tbWl0KSwgZG9jUmVzcG9uZGVyLmZhaWx1cmUoKSwgY29tbWl0LnRyaWVzIDwgMjAwICYmIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY3ljbGVDb21taXR0ZXIoKSwgTWF0aC5taW4oY29tbWl0LnRyaWVzICogMWUzLCBPTkVfTUlOVVRFKSk7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAoZXJyb3IpID0+IHtcbiAgICAgICAgdGhpcy5jb21taXRzLmZvckVhY2goKGNvbW0pID0+IGNvbW0ucmVqZWN0KGVycm9yKSksIHRoaXMuY29tbWl0cyA9IFtdLCB0aGlzLnJlc2V0KHRoaXMuZG9jdW1lbnQuSEVBRCksIHRoaXMuYnVmZmVyID0gbmV3IFNxdWFzaGluZ0J1ZmZlcih0aGlzLkxPQ0FMKSwgdGhpcy5jb21taXR0ZXJSdW5uaW5nID0gITE7XG4gICAgICB9XG4gICAgfTtcbiAgICBkZWJ1ZyhcIlBvc3RpbmcgY29tbWl0XCIpLCB0aGlzLmNvbW1pdEhhbmRsZXIgJiYgdGhpcy5jb21taXRIYW5kbGVyKHtcbiAgICAgIG11dGF0aW9uOiBzcXVhc2hlZCxcbiAgICAgIHN1Y2Nlc3M6IHJlc3BvbmRlci5zdWNjZXNzLFxuICAgICAgZmFpbHVyZTogcmVzcG9uZGVyLmZhaWx1cmUsXG4gICAgICBjYW5jZWw6IHJlc3BvbmRlci5jYW5jZWxcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVEb2NSZWJhc2UoZWRnZSwgcmVtb3RlTXV0YXRpb25zLCBsb2NhbE11dGF0aW9ucykge1xuICAgIHRoaXMucmViYXNlKHJlbW90ZU11dGF0aW9ucywgbG9jYWxNdXRhdGlvbnMpO1xuICB9XG4gIGhhbmRsZURvY3VtZW50RGVsZXRlZCgpIHtcbiAgICBkZWJ1ZyhcIkRvY3VtZW50IGRlbGV0ZWRcIiksIHRoaXMuTE9DQUwgIT09IG51bGwgJiYgdGhpcy5vbkRlbGV0ZSAmJiB0aGlzLm9uRGVsZXRlKHRoaXMuTE9DQUwpLCB0aGlzLmNvbW1pdHMgPSBbXSwgdGhpcy5tdXRhdGlvbnMgPSBbXTtcbiAgfVxuICBoYW5kbGVEb2NNdXRhdGlvbihtc2cpIHtcbiAgICBpZiAodGhpcy5jb21taXRzLmxlbmd0aCA9PT0gMCAmJiAhdGhpcy5idWZmZXIuaGFzQ2hhbmdlcygpKSB7XG4gICAgICBkZWJ1ZyhcIkRvY3VtZW50IG11dGF0ZWQgZnJvbSByZW1vdGUgd2l0aCBubyBsb2NhbCBjaGFuZ2VzXCIpLCB0aGlzLkxPQ0FMID0gdGhpcy5kb2N1bWVudC5FREdFLCB0aGlzLmJ1ZmZlciA9IG5ldyBTcXVhc2hpbmdCdWZmZXIodGhpcy5MT0NBTCksIHRoaXMub25NdXRhdGlvbiAmJiB0aGlzLm9uTXV0YXRpb24obXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVidWcoXCJEb2N1bWVudCBtdXRhdGVkIGZyb20gcmVtb3RlIHdpdGggbG9jYWwgY2hhbmdlc1wiKSwgdGhpcy5kb2N1bWVudC5FREdFID09PSBudWxsICYmIHRoaXMuaGFuZGxlRG9jdW1lbnREZWxldGVkKCksIHRoaXMucmViYXNlKFttc2cubXV0YXRpb25dLCBbXSk7XG4gIH1cbiAgcmViYXNlKHJlbW90ZU11dGF0aW9ucywgbG9jYWxNdXRhdGlvbnMpIHtcbiAgICBkZWJ1ZyhcIlJlYmFzaW5nIGRvY3VtZW50XCIpLCB0aGlzLmRvY3VtZW50LkVER0UgPT09IG51bGwgJiYgdGhpcy5oYW5kbGVEb2N1bWVudERlbGV0ZWQoKTtcbiAgICBjb25zdCBvbGRMb2NhbCA9IHRoaXMuTE9DQUw7XG4gICAgdGhpcy5MT0NBTCA9IHRoaXMuY29tbWl0cy5yZWR1Y2UoKGRvYywgY29tbWl0KSA9PiBjb21taXQuYXBwbHkoZG9jKSwgdGhpcy5kb2N1bWVudC5FREdFKSwgdGhpcy5MT0NBTCA9IHRoaXMuYnVmZmVyLnJlYmFzZSh0aGlzLkxPQ0FMKSwgb2xkTG9jYWwgIT09IG51bGwgJiYgdGhpcy5MT0NBTCAhPT0gbnVsbCAmJiAob2xkTG9jYWwuX3JldiA9IHRoaXMuTE9DQUwuX3JldiksICFpc0VxdWFsKHRoaXMuTE9DQUwsIG9sZExvY2FsKSAmJiB0aGlzLm9uUmViYXNlICYmIHRoaXMub25SZWJhc2UoXG4gICAgICB0aGlzLkxPQ0FMLFxuICAgICAgcmVtb3RlTXV0YXRpb25zLnJlZHVjZShtdXRSZWR1Y2VyRm4sIFtdKSxcbiAgICAgIGxvY2FsTXV0YXRpb25zLnJlZHVjZShtdXRSZWR1Y2VyRm4sIFtdKVxuICAgICk7XG4gIH1cbiAgaGFuZGxlRG9jQ29uc2lzdGVuY3lDaGFuZ2VkKGlzQ29uc2lzdGVudCkge1xuICAgIGlmICghdGhpcy5vbkNvbnNpc3RlbmN5Q2hhbmdlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoYXNMb2NhbENoYW5nZXMgPSB0aGlzLmNvbW1pdHMubGVuZ3RoID4gMCB8fCB0aGlzLmJ1ZmZlci5oYXNDaGFuZ2VzKCk7XG4gICAgaXNDb25zaXN0ZW50ICYmICFoYXNMb2NhbENoYW5nZXMgJiYgdGhpcy5vbkNvbnNpc3RlbmN5Q2hhbmdlZCghMCksIGlzQ29uc2lzdGVudCB8fCB0aGlzLm9uQ29uc2lzdGVuY3lDaGFuZ2VkKCExKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQnVmZmVyZWREb2N1bWVudCxcbiAgTXV0YXRpb24sXG4gIGFycmF5VG9KU09OTWF0Y2hQYXRoLFxuICBleHRyYWN0LFxuICBleHRyYWN0V2l0aFBhdGhcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+mutator@3.99.0_@types+react@18.3.24/node_modules/@sanity/mutator/lib/index.mjs\n");

/***/ })

};
;