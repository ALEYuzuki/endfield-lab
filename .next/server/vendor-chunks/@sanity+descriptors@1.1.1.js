"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity+descriptors@1.1.1";
exports.ids = ["vendor-chunks/@sanity+descriptors@1.1.1"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@sanity+descriptors@1.1.1/node_modules/@sanity/descriptors/dist/index.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+descriptors@1.1.1/node_modules/@sanity/descriptors/dist/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SetBuilder: () => (/* binding */ SetBuilder),\n/* harmony export */   SetSketch: () => (/* binding */ SetSketch),\n/* harmony export */   decodeBase64: () => (/* binding */ decodeBase64),\n/* harmony export */   encodeBase64: () => (/* binding */ encodeBase64),\n/* harmony export */   encodeBase64Sha256: () => (/* binding */ encodeBase64Sha256),\n/* harmony export */   processSetSynchronization: () => (/* binding */ processSetSynchronization)\n/* harmony export */ });\n/* harmony import */ var sha256_uint8array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sha256-uint8array */ \"(ssr)/../node_modules/.pnpm/sha256-uint8array@0.10.7/node_modules/sha256-uint8array/dist/sha256-uint8array.mjs\");\n\nfunction arrayEquals(arr1, arr2) {\n  for (let i = 0; i < arr1.length; i++)\n    if (arr1[i] != arr2[i]) return !1;\n  return !0;\n}\nfunction arrayCompare(arr1, arr2) {\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] < arr2[i]) return -1;\n    if (arr1[i] > arr2[i]) return 1;\n  }\n  return 0;\n}\nfunction arrayZero(arr) {\n  for (let i = 0; i < arr.length; i++)\n    if (arr[i] != 0) return !1;\n  return !0;\n}\nconst MULTIHASH_SHA256 = \"\u0012 \";\nclass IDEncoder {\n  hash = new sha256_uint8array__WEBPACK_IMPORTED_MODULE_0__.Hash();\n  buffer = new ArrayBuffer(4);\n  uint8 = new Uint8Array(this.buffer);\n  uint8_byte = new Uint8Array(this.buffer, 0, 1);\n  int32 = new Int32Array(this.buffer);\n  encodeByte(byte) {\n    this.uint8_byte[0] = byte, this.hash.update(this.uint8_byte);\n  }\n  encodeString(val) {\n    this.hash.update(val, \"utf8\");\n  }\n  encodeInt32(val) {\n    if (this.int32[0] = val, this.int32[0] !== val) throw new Error(\"Only 32-bit numbers can be encoded as descriptors\");\n    this.hash.update(this.uint8);\n  }\n  encodeValue(val) {\n    if (val === null)\n      this.encodeByte(\n        110\n        /* NULL */\n      );\n    else if (val === !0)\n      this.encodeByte(\n        116\n        /* TRUE */\n      );\n    else if (val === !1)\n      this.encodeByte(\n        102\n        /* FALSE */\n      );\n    else if (typeof val == \"string\")\n      this.encodeByte(\n        115\n        /* STRING */\n      ), this.encodeString(val);\n    else if (Array.isArray(val)) {\n      this.encodeByte(\n        97\n        /* ARRAY_START */\n      );\n      for (const elem of val)\n        this.encodeValue(elem);\n      this.encodeByte(\n        65\n        /* ARRAY_END */\n      );\n    } else {\n      const digests = [];\n      for (const [key, field] of Object.entries(val)) {\n        if (field === void 0)\n          continue;\n        const fieldEncoder = new IDEncoder();\n        fieldEncoder.encodeString(key), fieldEncoder.encodeValue(field), digests.push(fieldEncoder.getDigest());\n      }\n      digests.sort((a, b) => arrayCompare(a, b)), this.encodeByte(\n        111\n        /* OBJECT_START */\n      );\n      for (const digest of digests)\n        this.hash.update(digest);\n      this.encodeByte(\n        79\n        /* OBJECT_END */\n      );\n    }\n  }\n  encodeObjectWithType(type, val) {\n    const digests = [];\n    for (const [key, field] of Object.entries(val)) {\n      if (field === void 0)\n        continue;\n      const fieldEncoder = new IDEncoder();\n      fieldEncoder.encodeString(key), fieldEncoder.encodeValue(field), digests.push(fieldEncoder.getDigest());\n    }\n    const typeEncoder = new IDEncoder();\n    typeEncoder.encodeString(\"type\"), typeEncoder.encodeValue(type), digests.push(typeEncoder.getDigest()), digests.sort((a, b) => arrayCompare(a, b)), this.encodeByte(\n      111\n      /* OBJECT_START */\n    );\n    for (const digest of digests)\n      this.hash.update(digest);\n    this.encodeByte(\n      79\n      /* OBJECT_END */\n    );\n  }\n  getDigest() {\n    return this.hash.digest();\n  }\n}\nfunction encodeBase64(data, prefix = \"\") {\n  let binary = prefix;\n  for (let i = 0; i < data.length; i++)\n    binary += String.fromCharCode(data[i]);\n  return \"u\" + globalThis.btoa(binary).replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replaceAll(\"=\", \"\");\n}\nfunction encodeBase64Sha256(data) {\n  return encodeBase64(data, MULTIHASH_SHA256);\n}\nfunction decodeBase64(input, into) {\n  if (input[0] !== \"u\") throw new Error(\"Invalid base64\");\n  const binary = globalThis.atob(input.slice(1).replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\"));\n  for (let i = 0; i < binary.length; i++)\n    into[i] = binary.charCodeAt(i);\n}\nfunction encode(type, props, options) {\n  const idEncoder = new IDEncoder();\n  idEncoder.encodeObjectWithType(type, props);\n  const digest = idEncoder.getDigest();\n  return options?.withDigest && options.withDigest(digest), { id: encodeBase64(digest, MULTIHASH_SHA256), type, ...props };\n}\nconst NUM_HASH = 3;\nclass SetSketch {\n  arr;\n  byteSize;\n  numBuckets;\n  constructor(byteSize, numBuckets) {\n    if (numBuckets >= 31) throw new Error(\"numBuckets must be less than 31\");\n    this.byteSize = byteSize, this.numBuckets = numBuckets, this.arr = new Uint8Array(this.byteSize * this.numBuckets);\n  }\n  toggle(val, yieldBucket) {\n    for (let k = 0; k < NUM_HASH; k++) {\n      const bucket = val[k] % this.numBuckets;\n      yieldBucket && yieldBucket(bucket);\n      const offset = bucket * this.byteSize;\n      for (let idx = 0; idx < this.byteSize; idx++)\n        this.arr[offset + idx] ^= val[idx];\n    }\n  }\n  toggleAll(other) {\n    for (let i = 0; i < this.arr.length; i++)\n      this.arr[i] ^= other.arr[i];\n  }\n  copy() {\n    const result = new SetSketch(this.byteSize, this.numBuckets);\n    for (let idx = 0; idx < this.arr.length; idx++)\n      result.arr[idx] = this.arr[idx];\n    return result;\n  }\n  decode() {\n    const max = this.numBuckets * 2, set = new BufferSet(this.byteSize, max), queue = new BitQueue(this.numBuckets);\n    let t = 0;\n    for (; !queue.isEmpty(); ) {\n      const bucket = queue.pop();\n      if (this.looksPure(bucket)) {\n        if (t >= max)\n          return null;\n        const offset = bucket * this.byteSize, slice = this.arr.slice(offset, offset + this.byteSize);\n        set.toggle(slice), this.toggle(slice, (otherBuckets) => {\n          otherBuckets !== bucket && queue.set(otherBuckets);\n        }), t++;\n      }\n    }\n    return arrayZero(this.arr) ? set : null;\n  }\n  looksPure(bucket) {\n    const offset = bucket * this.byteSize, val = this.arr.subarray(offset, offset + this.byteSize);\n    if (arrayZero(val)) return !1;\n    let hashedToBucketCount = 0;\n    for (let k = 0; k < NUM_HASH; k++)\n      val[k] % this.numBuckets === bucket && hashedToBucketCount++;\n    return hashedToBucketCount % 2 == 1;\n  }\n}\nclass BufferSet {\n  arr;\n  byteSize;\n  length;\n  capacity;\n  constructor(byteSize, capacity) {\n    this.arr = new Uint8Array(byteSize * capacity), this.byteSize = byteSize, this.length = 0, this.capacity = capacity;\n  }\n  toggle(val) {\n    for (let i = 0; i < this.length; i++) {\n      const start = i * this.byteSize, slice = this.arr.subarray(start, start + this.byteSize);\n      if (arrayEquals(val, slice)) {\n        if (i != this.length - 1) {\n          const lastEntryByteIdx = (this.length - 1) * this.byteSize;\n          for (let j = 0; j < this.byteSize; j++)\n            slice[j] = this.arr[lastEntryByteIdx + j];\n        }\n        this.length--;\n        return;\n      }\n    }\n    if (this.length === this.capacity) throw new Error(\"BufferSet is full\");\n    const byteIdx = this.length * this.byteSize;\n    for (let i = 0; i < this.byteSize; i++)\n      this.arr[byteIdx + i] = val[i];\n    this.length++;\n  }\n  forEach(fn) {\n    for (let i = 0; i < this.length; i++) {\n      const start = i * this.byteSize;\n      fn(this.arr.subarray(start, start + this.byteSize));\n    }\n  }\n  /**\n   * Returns a normalized JSON representation.\n   *\n   * This is not optimized and should mainly be used for debugging.\n   */\n  toJSON() {\n    const result = [];\n    return this.forEach((entry) => {\n      result.push(Array.from(entry));\n    }), result.sort((a, b) => arrayCompare(a, b)), result;\n  }\n}\nclass BitQueue {\n  bitset;\n  queue;\n  constructor(size) {\n    this.bitset = (1 << size) - 1, this.queue = Array.from({ length: size }, (_, i) => i);\n  }\n  set(idx) {\n    const mask = 1 << idx;\n    this.bitset & mask || (this.queue.push(idx), this.bitset |= mask);\n  }\n  isEmpty() {\n    return this.bitset === 0;\n  }\n  pop() {\n    const idx = this.queue.shift(), mask = 1 << idx;\n    return this.bitset &= ~mask, idx;\n  }\n}\nclass SetBuilder {\n  objectValues = {};\n  setValues = {};\n  keys = [];\n  sketch = new SetSketch(32, 8);\n  /**\n   * Add an object to the set.\n   */\n  addObject(type, obj) {\n    const value = encode(type, obj, {\n      withDigest: (digest) => {\n        this.sketch.toggle(digest);\n      }\n    });\n    this.objectValues[value.id] = value, this.keys.push(value.id);\n  }\n  /**\n   * Add another set to the set.\n   */\n  addSet(sync) {\n    this.setValues[sync.set.id] = sync, this.sketch.toggle(sync.digest), this.keys.push(sync.set.id);\n  }\n  build(type) {\n    this.keys.sort();\n    let digest;\n    return {\n      set: encode(\n        type,\n        { keys: this.keys },\n        {\n          withDigest: (d) => {\n            digest = d;\n          }\n        }\n      ),\n      digest,\n      objectValues: this.objectValues,\n      setValues: this.setValues,\n      sketch: this.sketch\n    };\n  }\n}\nfunction processSetSynchronization(sync, prevResult) {\n  const id = sync.set.id;\n  if (!prevResult) return { id };\n  if (prevResult.type === \"complete\") return null;\n  const descriptors = [];\n  for (const missingId of prevResult.missingIds) {\n    const descriptor = findDescriptor(sync, missingId);\n    if (!descriptor) throw new Error(\"Synchronization server is requested an unknonwn descriptor\");\n    descriptors.push(descriptor);\n  }\n  return { id, descriptors };\n}\nfunction findDescriptor(sync, id) {\n  if (sync.set.id === id) return sync.set;\n  const desc = sync.objectValues[id];\n  if (desc) return desc;\n  for (const child of Object.values(sync.setValues)) {\n    const childDesc = findDescriptor(child, id);\n    if (childDesc) return childDesc;\n  }\n  return null;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrZGVzY3JpcHRvcnNAMS4xLjEvbm9kZV9tb2R1bGVzL0BzYW5pdHkvZGVzY3JpcHRvcnMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlDO0FBQ3pDO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsiRDpcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBzYW5pdHkrZGVzY3JpcHRvcnNAMS4xLjFcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcZGVzY3JpcHRvcnNcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2ggfSBmcm9tIFwic2hhMjU2LXVpbnQ4YXJyYXlcIjtcbmZ1bmN0aW9uIGFycmF5RXF1YWxzKGFycjEsIGFycjIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKVxuICAgIGlmIChhcnIxW2ldICE9IGFycjJbaV0pIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gYXJyYXlDb21wYXJlKGFycjEsIGFycjIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gPCBhcnIyW2ldKSByZXR1cm4gLTE7XG4gICAgaWYgKGFycjFbaV0gPiBhcnIyW2ldKSByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFycmF5WmVybyhhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgaWYgKGFycltpXSAhPSAwKSByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IE1VTFRJSEFTSF9TSEEyNTYgPSBcIlx1MDAxMiBcIjtcbmNsYXNzIElERW5jb2RlciB7XG4gIGhhc2ggPSBuZXcgSGFzaCgpO1xuICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIHVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIpO1xuICB1aW50OF9ieXRlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIDAsIDEpO1xuICBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYnVmZmVyKTtcbiAgZW5jb2RlQnl0ZShieXRlKSB7XG4gICAgdGhpcy51aW50OF9ieXRlWzBdID0gYnl0ZSwgdGhpcy5oYXNoLnVwZGF0ZSh0aGlzLnVpbnQ4X2J5dGUpO1xuICB9XG4gIGVuY29kZVN0cmluZyh2YWwpIHtcbiAgICB0aGlzLmhhc2gudXBkYXRlKHZhbCwgXCJ1dGY4XCIpO1xuICB9XG4gIGVuY29kZUludDMyKHZhbCkge1xuICAgIGlmICh0aGlzLmludDMyWzBdID0gdmFsLCB0aGlzLmludDMyWzBdICE9PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk9ubHkgMzItYml0IG51bWJlcnMgY2FuIGJlIGVuY29kZWQgYXMgZGVzY3JpcHRvcnNcIik7XG4gICAgdGhpcy5oYXNoLnVwZGF0ZSh0aGlzLnVpbnQ4KTtcbiAgfVxuICBlbmNvZGVWYWx1ZSh2YWwpIHtcbiAgICBpZiAodmFsID09PSBudWxsKVxuICAgICAgdGhpcy5lbmNvZGVCeXRlKFxuICAgICAgICAxMTBcbiAgICAgICAgLyogTlVMTCAqL1xuICAgICAgKTtcbiAgICBlbHNlIGlmICh2YWwgPT09ICEwKVxuICAgICAgdGhpcy5lbmNvZGVCeXRlKFxuICAgICAgICAxMTZcbiAgICAgICAgLyogVFJVRSAqL1xuICAgICAgKTtcbiAgICBlbHNlIGlmICh2YWwgPT09ICExKVxuICAgICAgdGhpcy5lbmNvZGVCeXRlKFxuICAgICAgICAxMDJcbiAgICAgICAgLyogRkFMU0UgKi9cbiAgICAgICk7XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiKVxuICAgICAgdGhpcy5lbmNvZGVCeXRlKFxuICAgICAgICAxMTVcbiAgICAgICAgLyogU1RSSU5HICovXG4gICAgICApLCB0aGlzLmVuY29kZVN0cmluZyh2YWwpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdGhpcy5lbmNvZGVCeXRlKFxuICAgICAgICA5N1xuICAgICAgICAvKiBBUlJBWV9TVEFSVCAqL1xuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiB2YWwpXG4gICAgICAgIHRoaXMuZW5jb2RlVmFsdWUoZWxlbSk7XG4gICAgICB0aGlzLmVuY29kZUJ5dGUoXG4gICAgICAgIDY1XG4gICAgICAgIC8qIEFSUkFZX0VORCAqL1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGlnZXN0cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBmaWVsZF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICBpZiAoZmllbGQgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZmllbGRFbmNvZGVyID0gbmV3IElERW5jb2RlcigpO1xuICAgICAgICBmaWVsZEVuY29kZXIuZW5jb2RlU3RyaW5nKGtleSksIGZpZWxkRW5jb2Rlci5lbmNvZGVWYWx1ZShmaWVsZCksIGRpZ2VzdHMucHVzaChmaWVsZEVuY29kZXIuZ2V0RGlnZXN0KCkpO1xuICAgICAgfVxuICAgICAgZGlnZXN0cy5zb3J0KChhLCBiKSA9PiBhcnJheUNvbXBhcmUoYSwgYikpLCB0aGlzLmVuY29kZUJ5dGUoXG4gICAgICAgIDExMVxuICAgICAgICAvKiBPQkpFQ1RfU1RBUlQgKi9cbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IGRpZ2VzdCBvZiBkaWdlc3RzKVxuICAgICAgICB0aGlzLmhhc2gudXBkYXRlKGRpZ2VzdCk7XG4gICAgICB0aGlzLmVuY29kZUJ5dGUoXG4gICAgICAgIDc5XG4gICAgICAgIC8qIE9CSkVDVF9FTkQgKi9cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGVuY29kZU9iamVjdFdpdGhUeXBlKHR5cGUsIHZhbCkge1xuICAgIGNvbnN0IGRpZ2VzdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGZpZWxkXSBvZiBPYmplY3QuZW50cmllcyh2YWwpKSB7XG4gICAgICBpZiAoZmllbGQgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBmaWVsZEVuY29kZXIgPSBuZXcgSURFbmNvZGVyKCk7XG4gICAgICBmaWVsZEVuY29kZXIuZW5jb2RlU3RyaW5nKGtleSksIGZpZWxkRW5jb2Rlci5lbmNvZGVWYWx1ZShmaWVsZCksIGRpZ2VzdHMucHVzaChmaWVsZEVuY29kZXIuZ2V0RGlnZXN0KCkpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlRW5jb2RlciA9IG5ldyBJREVuY29kZXIoKTtcbiAgICB0eXBlRW5jb2Rlci5lbmNvZGVTdHJpbmcoXCJ0eXBlXCIpLCB0eXBlRW5jb2Rlci5lbmNvZGVWYWx1ZSh0eXBlKSwgZGlnZXN0cy5wdXNoKHR5cGVFbmNvZGVyLmdldERpZ2VzdCgpKSwgZGlnZXN0cy5zb3J0KChhLCBiKSA9PiBhcnJheUNvbXBhcmUoYSwgYikpLCB0aGlzLmVuY29kZUJ5dGUoXG4gICAgICAxMTFcbiAgICAgIC8qIE9CSkVDVF9TVEFSVCAqL1xuICAgICk7XG4gICAgZm9yIChjb25zdCBkaWdlc3Qgb2YgZGlnZXN0cylcbiAgICAgIHRoaXMuaGFzaC51cGRhdGUoZGlnZXN0KTtcbiAgICB0aGlzLmVuY29kZUJ5dGUoXG4gICAgICA3OVxuICAgICAgLyogT0JKRUNUX0VORCAqL1xuICAgICk7XG4gIH1cbiAgZ2V0RGlnZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmhhc2guZGlnZXN0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NChkYXRhLCBwcmVmaXggPSBcIlwiKSB7XG4gIGxldCBiaW5hcnkgPSBwcmVmaXg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgcmV0dXJuIFwidVwiICsgZ2xvYmFsVGhpcy5idG9hKGJpbmFyeSkucmVwbGFjZUFsbChcIitcIiwgXCItXCIpLnJlcGxhY2VBbGwoXCIvXCIsIFwiX1wiKS5yZXBsYWNlQWxsKFwiPVwiLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFNoYTI1NihkYXRhKSB7XG4gIHJldHVybiBlbmNvZGVCYXNlNjQoZGF0YSwgTVVMVElIQVNIX1NIQTI1Nik7XG59XG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQoaW5wdXQsIGludG8pIHtcbiAgaWYgKGlucHV0WzBdICE9PSBcInVcIikgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjRcIik7XG4gIGNvbnN0IGJpbmFyeSA9IGdsb2JhbFRoaXMuYXRvYihpbnB1dC5zbGljZSgxKS5yZXBsYWNlQWxsKFwiLVwiLCBcIitcIikucmVwbGFjZUFsbChcIl9cIiwgXCIvXCIpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnkubGVuZ3RoOyBpKyspXG4gICAgaW50b1tpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xufVxuZnVuY3Rpb24gZW5jb2RlKHR5cGUsIHByb3BzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGlkRW5jb2RlciA9IG5ldyBJREVuY29kZXIoKTtcbiAgaWRFbmNvZGVyLmVuY29kZU9iamVjdFdpdGhUeXBlKHR5cGUsIHByb3BzKTtcbiAgY29uc3QgZGlnZXN0ID0gaWRFbmNvZGVyLmdldERpZ2VzdCgpO1xuICByZXR1cm4gb3B0aW9ucz8ud2l0aERpZ2VzdCAmJiBvcHRpb25zLndpdGhEaWdlc3QoZGlnZXN0KSwgeyBpZDogZW5jb2RlQmFzZTY0KGRpZ2VzdCwgTVVMVElIQVNIX1NIQTI1NiksIHR5cGUsIC4uLnByb3BzIH07XG59XG5jb25zdCBOVU1fSEFTSCA9IDM7XG5jbGFzcyBTZXRTa2V0Y2gge1xuICBhcnI7XG4gIGJ5dGVTaXplO1xuICBudW1CdWNrZXRzO1xuICBjb25zdHJ1Y3RvcihieXRlU2l6ZSwgbnVtQnVja2V0cykge1xuICAgIGlmIChudW1CdWNrZXRzID49IDMxKSB0aHJvdyBuZXcgRXJyb3IoXCJudW1CdWNrZXRzIG11c3QgYmUgbGVzcyB0aGFuIDMxXCIpO1xuICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZSwgdGhpcy5udW1CdWNrZXRzID0gbnVtQnVja2V0cywgdGhpcy5hcnIgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ5dGVTaXplICogdGhpcy5udW1CdWNrZXRzKTtcbiAgfVxuICB0b2dnbGUodmFsLCB5aWVsZEJ1Y2tldCkge1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTlVNX0hBU0g7IGsrKykge1xuICAgICAgY29uc3QgYnVja2V0ID0gdmFsW2tdICUgdGhpcy5udW1CdWNrZXRzO1xuICAgICAgeWllbGRCdWNrZXQgJiYgeWllbGRCdWNrZXQoYnVja2V0KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGJ1Y2tldCAqIHRoaXMuYnl0ZVNpemU7XG4gICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmJ5dGVTaXplOyBpZHgrKylcbiAgICAgICAgdGhpcy5hcnJbb2Zmc2V0ICsgaWR4XSBePSB2YWxbaWR4XTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlQWxsKG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyci5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYXJyW2ldIF49IG90aGVyLmFycltpXTtcbiAgfVxuICBjb3B5KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXRTa2V0Y2godGhpcy5ieXRlU2l6ZSwgdGhpcy5udW1CdWNrZXRzKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLmFyci5sZW5ndGg7IGlkeCsrKVxuICAgICAgcmVzdWx0LmFycltpZHhdID0gdGhpcy5hcnJbaWR4XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlY29kZSgpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLm51bUJ1Y2tldHMgKiAyLCBzZXQgPSBuZXcgQnVmZmVyU2V0KHRoaXMuYnl0ZVNpemUsIG1heCksIHF1ZXVlID0gbmV3IEJpdFF1ZXVlKHRoaXMubnVtQnVja2V0cyk7XG4gICAgbGV0IHQgPSAwO1xuICAgIGZvciAoOyAhcXVldWUuaXNFbXB0eSgpOyApIHtcbiAgICAgIGNvbnN0IGJ1Y2tldCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgaWYgKHRoaXMubG9va3NQdXJlKGJ1Y2tldCkpIHtcbiAgICAgICAgaWYgKHQgPj0gbWF4KVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBidWNrZXQgKiB0aGlzLmJ5dGVTaXplLCBzbGljZSA9IHRoaXMuYXJyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5ieXRlU2l6ZSk7XG4gICAgICAgIHNldC50b2dnbGUoc2xpY2UpLCB0aGlzLnRvZ2dsZShzbGljZSwgKG90aGVyQnVja2V0cykgPT4ge1xuICAgICAgICAgIG90aGVyQnVja2V0cyAhPT0gYnVja2V0ICYmIHF1ZXVlLnNldChvdGhlckJ1Y2tldHMpO1xuICAgICAgICB9KSwgdCsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlaZXJvKHRoaXMuYXJyKSA/IHNldCA6IG51bGw7XG4gIH1cbiAgbG9va3NQdXJlKGJ1Y2tldCkge1xuICAgIGNvbnN0IG9mZnNldCA9IGJ1Y2tldCAqIHRoaXMuYnl0ZVNpemUsIHZhbCA9IHRoaXMuYXJyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5ieXRlU2l6ZSk7XG4gICAgaWYgKGFycmF5WmVybyh2YWwpKSByZXR1cm4gITE7XG4gICAgbGV0IGhhc2hlZFRvQnVja2V0Q291bnQgPSAwO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgTlVNX0hBU0g7IGsrKylcbiAgICAgIHZhbFtrXSAlIHRoaXMubnVtQnVja2V0cyA9PT0gYnVja2V0ICYmIGhhc2hlZFRvQnVja2V0Q291bnQrKztcbiAgICByZXR1cm4gaGFzaGVkVG9CdWNrZXRDb3VudCAlIDIgPT0gMTtcbiAgfVxufVxuY2xhc3MgQnVmZmVyU2V0IHtcbiAgYXJyO1xuICBieXRlU2l6ZTtcbiAgbGVuZ3RoO1xuICBjYXBhY2l0eTtcbiAgY29uc3RydWN0b3IoYnl0ZVNpemUsIGNhcGFjaXR5KSB7XG4gICAgdGhpcy5hcnIgPSBuZXcgVWludDhBcnJheShieXRlU2l6ZSAqIGNhcGFjaXR5KSwgdGhpcy5ieXRlU2l6ZSA9IGJ5dGVTaXplLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgfVxuICB0b2dnbGUodmFsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGFydCA9IGkgKiB0aGlzLmJ5dGVTaXplLCBzbGljZSA9IHRoaXMuYXJyLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIHRoaXMuYnl0ZVNpemUpO1xuICAgICAgaWYgKGFycmF5RXF1YWxzKHZhbCwgc2xpY2UpKSB7XG4gICAgICAgIGlmIChpICE9IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbnN0IGxhc3RFbnRyeUJ5dGVJZHggPSAodGhpcy5sZW5ndGggLSAxKSAqIHRoaXMuYnl0ZVNpemU7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmJ5dGVTaXplOyBqKyspXG4gICAgICAgICAgICBzbGljZVtqXSA9IHRoaXMuYXJyW2xhc3RFbnRyeUJ5dGVJZHggKyBqXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdGhpcy5jYXBhY2l0eSkgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyU2V0IGlzIGZ1bGxcIik7XG4gICAgY29uc3QgYnl0ZUlkeCA9IHRoaXMubGVuZ3RoICogdGhpcy5ieXRlU2l6ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZVNpemU7IGkrKylcbiAgICAgIHRoaXMuYXJyW2J5dGVJZHggKyBpXSA9IHZhbFtpXTtcbiAgICB0aGlzLmxlbmd0aCsrO1xuICB9XG4gIGZvckVhY2goZm4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gaSAqIHRoaXMuYnl0ZVNpemU7XG4gICAgICBmbih0aGlzLmFyci5zdWJhcnJheShzdGFydCwgc3RhcnQgKyB0aGlzLmJ5dGVTaXplKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9ybWFsaXplZCBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIG5vdCBvcHRpbWl6ZWQgYW5kIHNob3VsZCBtYWlubHkgYmUgdXNlZCBmb3IgZGVidWdnaW5nLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiB0aGlzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICByZXN1bHQucHVzaChBcnJheS5mcm9tKGVudHJ5KSk7XG4gICAgfSksIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhcnJheUNvbXBhcmUoYSwgYikpLCByZXN1bHQ7XG4gIH1cbn1cbmNsYXNzIEJpdFF1ZXVlIHtcbiAgYml0c2V0O1xuICBxdWV1ZTtcbiAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgIHRoaXMuYml0c2V0ID0gKDEgPDwgc2l6ZSkgLSAxLCB0aGlzLnF1ZXVlID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogc2l6ZSB9LCAoXywgaSkgPT4gaSk7XG4gIH1cbiAgc2V0KGlkeCkge1xuICAgIGNvbnN0IG1hc2sgPSAxIDw8IGlkeDtcbiAgICB0aGlzLmJpdHNldCAmIG1hc2sgfHwgKHRoaXMucXVldWUucHVzaChpZHgpLCB0aGlzLmJpdHNldCB8PSBtYXNrKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmJpdHNldCA9PT0gMDtcbiAgfVxuICBwb3AoKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy5xdWV1ZS5zaGlmdCgpLCBtYXNrID0gMSA8PCBpZHg7XG4gICAgcmV0dXJuIHRoaXMuYml0c2V0ICY9IH5tYXNrLCBpZHg7XG4gIH1cbn1cbmNsYXNzIFNldEJ1aWxkZXIge1xuICBvYmplY3RWYWx1ZXMgPSB7fTtcbiAgc2V0VmFsdWVzID0ge307XG4gIGtleXMgPSBbXTtcbiAgc2tldGNoID0gbmV3IFNldFNrZXRjaCgzMiwgOCk7XG4gIC8qKlxuICAgKiBBZGQgYW4gb2JqZWN0IHRvIHRoZSBzZXQuXG4gICAqL1xuICBhZGRPYmplY3QodHlwZSwgb2JqKSB7XG4gICAgY29uc3QgdmFsdWUgPSBlbmNvZGUodHlwZSwgb2JqLCB7XG4gICAgICB3aXRoRGlnZXN0OiAoZGlnZXN0KSA9PiB7XG4gICAgICAgIHRoaXMuc2tldGNoLnRvZ2dsZShkaWdlc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMub2JqZWN0VmFsdWVzW3ZhbHVlLmlkXSA9IHZhbHVlLCB0aGlzLmtleXMucHVzaCh2YWx1ZS5pZCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbm90aGVyIHNldCB0byB0aGUgc2V0LlxuICAgKi9cbiAgYWRkU2V0KHN5bmMpIHtcbiAgICB0aGlzLnNldFZhbHVlc1tzeW5jLnNldC5pZF0gPSBzeW5jLCB0aGlzLnNrZXRjaC50b2dnbGUoc3luYy5kaWdlc3QpLCB0aGlzLmtleXMucHVzaChzeW5jLnNldC5pZCk7XG4gIH1cbiAgYnVpbGQodHlwZSkge1xuICAgIHRoaXMua2V5cy5zb3J0KCk7XG4gICAgbGV0IGRpZ2VzdDtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0OiBlbmNvZGUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHsga2V5czogdGhpcy5rZXlzIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB3aXRoRGlnZXN0OiAoZCkgPT4ge1xuICAgICAgICAgICAgZGlnZXN0ID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBkaWdlc3QsXG4gICAgICBvYmplY3RWYWx1ZXM6IHRoaXMub2JqZWN0VmFsdWVzLFxuICAgICAgc2V0VmFsdWVzOiB0aGlzLnNldFZhbHVlcyxcbiAgICAgIHNrZXRjaDogdGhpcy5za2V0Y2hcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzU2V0U3luY2hyb25pemF0aW9uKHN5bmMsIHByZXZSZXN1bHQpIHtcbiAgY29uc3QgaWQgPSBzeW5jLnNldC5pZDtcbiAgaWYgKCFwcmV2UmVzdWx0KSByZXR1cm4geyBpZCB9O1xuICBpZiAocHJldlJlc3VsdC50eXBlID09PSBcImNvbXBsZXRlXCIpIHJldHVybiBudWxsO1xuICBjb25zdCBkZXNjcmlwdG9ycyA9IFtdO1xuICBmb3IgKGNvbnN0IG1pc3NpbmdJZCBvZiBwcmV2UmVzdWx0Lm1pc3NpbmdJZHMpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gZmluZERlc2NyaXB0b3Ioc3luYywgbWlzc2luZ0lkKTtcbiAgICBpZiAoIWRlc2NyaXB0b3IpIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9uaXphdGlvbiBzZXJ2ZXIgaXMgcmVxdWVzdGVkIGFuIHVua25vbnduIGRlc2NyaXB0b3JcIik7XG4gICAgZGVzY3JpcHRvcnMucHVzaChkZXNjcmlwdG9yKTtcbiAgfVxuICByZXR1cm4geyBpZCwgZGVzY3JpcHRvcnMgfTtcbn1cbmZ1bmN0aW9uIGZpbmREZXNjcmlwdG9yKHN5bmMsIGlkKSB7XG4gIGlmIChzeW5jLnNldC5pZCA9PT0gaWQpIHJldHVybiBzeW5jLnNldDtcbiAgY29uc3QgZGVzYyA9IHN5bmMub2JqZWN0VmFsdWVzW2lkXTtcbiAgaWYgKGRlc2MpIHJldHVybiBkZXNjO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIE9iamVjdC52YWx1ZXMoc3luYy5zZXRWYWx1ZXMpKSB7XG4gICAgY29uc3QgY2hpbGREZXNjID0gZmluZERlc2NyaXB0b3IoY2hpbGQsIGlkKTtcbiAgICBpZiAoY2hpbGREZXNjKSByZXR1cm4gY2hpbGREZXNjO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZXhwb3J0IHtcbiAgU2V0QnVpbGRlcixcbiAgU2V0U2tldGNoLFxuICBkZWNvZGVCYXNlNjQsXG4gIGVuY29kZUJhc2U2NCxcbiAgZW5jb2RlQmFzZTY0U2hhMjU2LFxuICBwcm9jZXNzU2V0U3luY2hyb25pemF0aW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+descriptors@1.1.1/node_modules/@sanity/descriptors/dist/index.js\n");

/***/ })

};
;