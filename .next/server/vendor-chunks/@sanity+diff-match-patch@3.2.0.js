"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity+diff-match-patch@3.2.0";
exports.ids = ["vendor-chunks/@sanity+diff-match-patch@3.2.0"];
exports.modules = {

/***/ "(ssr)/../node_modules/.pnpm/@sanity+diff-match-patch@3.2.0/node_modules/@sanity/diff-match-patch/dist/index.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@sanity+diff-match-patch@3.2.0/node_modules/@sanity/diff-match-patch/dist/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIFF_DELETE: () => (/* binding */ DIFF_DELETE),\n/* harmony export */   DIFF_EQUAL: () => (/* binding */ DIFF_EQUAL),\n/* harmony export */   DIFF_INSERT: () => (/* binding */ DIFF_INSERT),\n/* harmony export */   adjustIndiciesToUcs2: () => (/* binding */ adjustIndiciesToUcs2),\n/* harmony export */   applyPatches: () => (/* binding */ apply),\n/* harmony export */   cleanupEfficiency: () => (/* binding */ cleanupEfficiency),\n/* harmony export */   cleanupSemantic: () => (/* binding */ cleanupSemantic),\n/* harmony export */   makeDiff: () => (/* binding */ diff),\n/* harmony export */   makePatches: () => (/* binding */ make),\n/* harmony export */   match: () => (/* binding */ match),\n/* harmony export */   parsePatch: () => (/* binding */ parse),\n/* harmony export */   stringifyPatch: () => (/* binding */ stringifyPatch),\n/* harmony export */   stringifyPatches: () => (/* binding */ stringify),\n/* harmony export */   xIndex: () => (/* binding */ xIndex)\n/* harmony export */ });\nfunction cloneDiff(diff2) {\n  const [type, patch] = diff2;\n  return [type, patch];\n}\nfunction getCommonOverlap(textA, textB) {\n  let text1 = textA, text2 = textB;\n  const text1Length = text1.length, text2Length = text2.length;\n  if (text1Length === 0 || text2Length === 0)\n    return 0;\n  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));\n  const textLength = Math.min(text1Length, text2Length);\n  if (text1 === text2)\n    return textLength;\n  let best = 0, length = 1;\n  for (let found = 0; found !== -1; ) {\n    const pattern = text1.substring(textLength - length);\n    if (found = text2.indexOf(pattern), found === -1)\n      return best;\n    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);\n  }\n  return best;\n}\nfunction getCommonPrefix(text1, text2) {\n  if (!text1 || !text2 || text1[0] !== text2[0])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction getCommonSuffix(text1, text2) {\n  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1])\n    return 0;\n  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;\n  for (; pointerMin < pointerMid; )\n    text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);\n  return pointerMid;\n}\nfunction isHighSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 55296 && charCode <= 56319;\n}\nfunction isLowSurrogate(char) {\n  const charCode = char.charCodeAt(0);\n  return charCode >= 56320 && charCode <= 57343;\n}\nfunction bisect(text1, text2, deadline) {\n  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);\n  for (let x = 0; x < vLength; x++)\n    v1[x] = -1, v2[x] = -1;\n  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;\n  const delta = text1Length - text2Length, front = delta % 2 !== 0;\n  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;\n  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {\n    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      const k1Offset = vOffset + k1;\n      let x1;\n      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;\n      let y1 = x1 - k1;\n      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); )\n        x1++, y1++;\n      if (v1[k1Offset] = x1, x1 > text1Length)\n        k1end += 2;\n      else if (y1 > text2Length)\n        k1start += 2;\n      else if (front) {\n        const k2Offset = vOffset + delta - k1;\n        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {\n          const x2 = text1Length - v2[k2Offset];\n          if (x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      const k2Offset = vOffset + k2;\n      let x2;\n      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;\n      let y2 = x2 - k2;\n      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); )\n        x2++, y2++;\n      if (v2[k2Offset] = x2, x2 > text1Length)\n        k2end += 2;\n      else if (y2 > text2Length)\n        k2start += 2;\n      else if (!front) {\n        const k1Offset = vOffset + delta - k2;\n        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {\n          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;\n          if (x2 = text1Length - x2, x1 >= x2)\n            return bisectSplit(text1, text2, x1, y1, deadline);\n        }\n      }\n    }\n  }\n  return [\n    [DIFF_DELETE, text1],\n    [DIFF_INSERT, text2]\n  ];\n}\nfunction bisectSplit(text1, text2, x, y, deadline) {\n  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, { checkLines: !1, deadline }), diffsb = doDiff(text1b, text2b, { checkLines: !1, deadline });\n  return diffs.concat(diffsb);\n}\nfunction findHalfMatch(text1, text2, timeout = 1) {\n  if (timeout <= 0)\n    return null;\n  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;\n  if (longText.length < 4 || shortText.length * 2 < longText.length)\n    return null;\n  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));\n  let halfMatch;\n  if (halfMatch1 && halfMatch2)\n    halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;\n  else {\n    if (!halfMatch1 && !halfMatch2)\n      return null;\n    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;\n  }\n  if (!halfMatch)\n    throw new Error(\"Unable to find a half match.\");\n  let text1A, text1B, text2A, text2B;\n  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);\n  const midCommon = halfMatch[4];\n  return [text1A, text1B, text2A, text2B, midCommon];\n}\nfunction halfMatchI(longText, shortText, i) {\n  const seed = longText.slice(i, i + Math.floor(longText.length / 4));\n  let j = -1, bestCommon = \"\", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;\n  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {\n    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));\n    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));\n  }\n  return bestCommon.length * 2 >= longText.length ? [\n    bestLongTextA || \"\",\n    bestLongTextB || \"\",\n    bestShortTextA || \"\",\n    bestShortTextB || \"\",\n    bestCommon || \"\"\n  ] : null;\n}\nfunction charsToLines(diffs, lineArray) {\n  for (let x = 0; x < diffs.length; x++) {\n    const chars = diffs[x][1], text = [];\n    for (let y = 0; y < chars.length; y++)\n      text[y] = lineArray[chars.charCodeAt(y)];\n    diffs[x][1] = text.join(\"\");\n  }\n}\nfunction linesToChars(textA, textB) {\n  const lineArray = [], lineHash = {};\n  lineArray[0] = \"\";\n  function diffLinesToMunge(text) {\n    let chars = \"\", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;\n    for (; lineEnd < text.length - 1; ) {\n      lineEnd = text.indexOf(`\n`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);\n      let line = text.slice(lineStart, lineEnd + 1);\n      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  let maxLines = 4e4;\n  const chars1 = diffLinesToMunge(textA);\n  maxLines = 65535;\n  const chars2 = diffLinesToMunge(textB);\n  return { chars1, chars2, lineArray };\n}\nfunction doLineModeDiff(textA, textB, opts) {\n  let text1 = textA, text2 = textB;\n  const a = linesToChars(text1, text2);\n  text1 = a.chars1, text2 = a.chars2;\n  const linearray = a.lineArray;\n  let diffs = doDiff(text1, text2, {\n    checkLines: !1,\n    deadline: opts.deadline\n  });\n  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\";\n  for (; pointer < diffs.length; ) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        if (countDelete >= 1 && countInsert >= 1) {\n          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;\n          const aa = doDiff(textDelete, textInsert, {\n            checkLines: !1,\n            deadline: opts.deadline\n          });\n          for (let j = aa.length - 1; j >= 0; j--)\n            diffs.splice(pointer, 0, aa[j]);\n          pointer += aa.length;\n        }\n        countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n    pointer++;\n  }\n  return diffs.pop(), diffs;\n}\nfunction computeDiff(text1, text2, opts) {\n  let diffs;\n  if (!text1)\n    return [[DIFF_INSERT, text2]];\n  if (!text2)\n    return [[DIFF_DELETE, text1]];\n  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);\n  if (i !== -1)\n    return diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;\n  if (shorttext.length === 1)\n    return [\n      [DIFF_DELETE, text1],\n      [DIFF_INSERT, text2]\n    ];\n  const halfMatch = findHalfMatch(text1, text2);\n  if (halfMatch) {\n    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);\n    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);\n  }\n  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);\n}\nvar __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b))\n      __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);\n  return a;\n};\nconst DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;\nfunction diff(textA, textB, opts) {\n  if (textA === null || textB === null)\n    throw new Error(\"Null input. (diff)\");\n  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));\n  return adjustDiffForSurrogatePairs(diffs), diffs;\n}\nfunction doDiff(textA, textB, options) {\n  let text1 = textA, text2 = textB;\n  if (text1 === text2)\n    return text1 ? [[DIFF_EQUAL, text1]] : [];\n  let commonlength = getCommonPrefix(text1, text2);\n  const commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);\n  const commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);\n  let diffs = computeDiff(text1, text2, options);\n  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;\n}\nfunction createDeadLine(timeout) {\n  let t = 1;\n  return typeof timeout < \"u\" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;\n}\nfunction createInternalOpts(opts) {\n  return __spreadValues$2({\n    checkLines: !0,\n    deadline: createDeadLine(opts.timeout || 1)\n  }, opts);\n}\nfunction combineChar(data, char, dir) {\n  return dir === 1 ? data + char : char + data;\n}\nfunction splitChar(data, dir) {\n  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];\n}\nfunction hasSharedChar(diffs, i, j, dir) {\n  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];\n}\nfunction deisolateChar(diffs, i, dir) {\n  const inv = dir === 1 ? -1 : 1;\n  let insertIdx = null, deleteIdx = null, j = i + dir;\n  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {\n    const [op, text2] = diffs[j];\n    if (text2.length !== 0) {\n      if (op === DIFF_INSERT) {\n        insertIdx === null && (insertIdx = j);\n        continue;\n      } else if (op === DIFF_DELETE) {\n        deleteIdx === null && (deleteIdx = j);\n        continue;\n      } else if (op === DIFF_EQUAL) {\n        if (insertIdx === null && deleteIdx === null) {\n          const [rest, char2] = splitChar(diffs[i][1], dir);\n          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);\n          return;\n        }\n        break;\n      }\n    }\n  }\n  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {\n    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText] = splitChar(diffs[deleteIdx][1], inv);\n    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);\n    return;\n  }\n  const [text, char] = splitChar(diffs[i][1], dir);\n  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);\n}\nfunction adjustDiffForSurrogatePairs(diffs) {\n  for (let i = 0; i < diffs.length; i++) {\n    const [diffType, diffText] = diffs[i];\n    if (diffText.length === 0) continue;\n    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];\n    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);\n  }\n  for (let i = 0; i < diffs.length; i++)\n    diffs[i][1].length === 0 && diffs.splice(i, 1);\n}\nfunction cleanupSemantic(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;\n  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {\n    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {\n      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);\n      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;\n    }\n    pointer++;\n  }\n  return diffs;\n}\nconst nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\\s/, linebreakRegex = /[\\r\\n]/, blanklineEndRegex = /\\n\\r?\\n$/, blanklineStartRegex = /^\\r?\\n\\r?\\n/;\nfunction cleanupSemanticLossless(rawDiffs) {\n  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  function diffCleanupSemanticScore(one, two) {\n    if (!one || !two)\n      return 6;\n    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);\n    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;\n  }\n  let pointer = 1;\n  for (; pointer < diffs.length - 1; ) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {\n      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];\n      const commonOffset = getCommonSuffix(equality1, edit);\n      if (commonOffset) {\n        const commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;\n      }\n      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n      for (; edit.charAt(0) === equality2.charAt(0); ) {\n        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);\n        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);\n        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);\n      }\n      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));\n    }\n    pointer++;\n  }\n  return diffs;\n}\nfunction cleanupMerge(rawDiffs) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));\n  diffs.push([DIFF_EQUAL, \"\"]);\n  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = \"\", textInsert = \"\", commonlength;\n  for (; pointer < diffs.length; )\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        countInsert++, textInsert += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_DELETE:\n        countDelete++, textDelete += diffs[pointer][1], pointer++;\n        break;\n      case DIFF_EQUAL:\n        countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(\n          0,\n          commonlength\n        ) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = \"\", textInsert = \"\";\n        break;\n      default:\n        throw new Error(\"Unknown diff operation\");\n    }\n  diffs[diffs.length - 1][1] === \"\" && diffs.pop();\n  let hasChanges = !1;\n  for (pointer = 1; pointer < diffs.length - 1; )\n    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nfunction trueCount(...args) {\n  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);\n}\nfunction cleanupEfficiency(rawDiffs, editCost = 4) {\n  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;\n  const equalities = [];\n  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;\n  for (; pointer < diffs.length; )\n    diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;\n  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;\n}\nvar __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b))\n      __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  /**\n   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n   */\n  threshold: 0.5,\n  /**\n   * How far to search for a match (0 = exact location, 1000+ = broad match).\n   * A match this many characters away from the expected location will add\n   * 1.0 to the score (0.0 is a perfect match).\n   */\n  distance: 1e3\n};\nfunction applyDefaults(options) {\n  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);\n}\nconst MAX_BITS$1 = 32;\nfunction bitap(text, pattern, loc, opts = {}) {\n  if (pattern.length > MAX_BITS$1)\n    throw new Error(\"Pattern too long for this browser.\");\n  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);\n  function getBitapScore(e, x) {\n    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);\n    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;\n  }\n  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);\n  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));\n  const matchmask = 1 << pattern.length - 1;\n  bestLoc = -1;\n  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];\n  for (let d = 0; d < pattern.length; d++) {\n    for (binMin = 0, binMid = binMax; binMin < binMid; )\n      getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    binMax = binMid;\n    let start = Math.max(1, loc - binMid + 1);\n    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (let j = finish; j >= start; j--) {\n      const charMatch = s[text.charAt(j - 1)];\n      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {\n        const score = getBitapScore(d, j - 1);\n        if (score <= scoreThreshold)\n          if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc)\n            start = Math.max(1, 2 * loc - bestLoc);\n          else\n            break;\n      }\n    }\n    if (getBitapScore(d + 1, loc) > scoreThreshold)\n      break;\n    lastRd = rd;\n  }\n  return bestLoc;\n}\nfunction getAlphabetFromPattern(pattern) {\n  const s = {};\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] = 0;\n  for (let i = 0; i < pattern.length; i++)\n    s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;\n  return s;\n}\nfunction match(text, pattern, searchLocation, options = {}) {\n  if (text === null || pattern === null || searchLocation === null)\n    throw new Error(\"Null input. (match())\");\n  const loc = Math.max(0, Math.min(searchLocation, text.length));\n  if (text === pattern)\n    return 0;\n  if (text.length) {\n    if (text.substring(loc, loc + pattern.length) === pattern)\n      return loc;\n  } else return -1;\n  return bitap(text, pattern, loc, options);\n}\nfunction diffText1(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction diffText2(diffs) {\n  const text = [];\n  for (let x = 0; x < diffs.length; x++)\n    diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);\n  return text.join(\"\");\n}\nfunction levenshtein(diffs) {\n  let leven = 0, insertions = 0, deletions = 0;\n  for (let x = 0; x < diffs.length; x++) {\n    const op = diffs[x][0], data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;\n        break;\n      default:\n        throw new Error(\"Unknown diff operation.\");\n    }\n  }\n  return leven += Math.max(insertions, deletions), leven;\n}\nfunction xIndex(diffs, location) {\n  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;\n  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++)\n    lastChars1 = chars1, lastChars2 = chars2;\n  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);\n}\nfunction countUtf8Bytes(str) {\n  let bytes = 0;\n  for (let i = 0; i < str.length; i++) {\n    const codePoint = str.codePointAt(i);\n    if (typeof codePoint > \"u\")\n      throw new Error(\"Failed to get codepoint\");\n    bytes += utf8len(codePoint);\n  }\n  return bytes;\n}\nfunction adjustIndiciesToUcs2(patches, base, options = {}) {\n  let byteOffset = 0, idx = 0;\n  function advanceTo(target) {\n    for (; byteOffset < target; ) {\n      const codePoint = base.codePointAt(idx);\n      if (typeof codePoint > \"u\")\n        return idx;\n      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;\n    }\n    if (!options.allowExceedingIndices && byteOffset !== target)\n      throw new Error(\"Failed to determine byte offset\");\n    return idx;\n  }\n  const adjusted = [];\n  for (const patch of patches)\n    adjusted.push({\n      diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),\n      start1: advanceTo(patch.start1),\n      start2: advanceTo(patch.start2),\n      utf8Start1: patch.utf8Start1,\n      utf8Start2: patch.utf8Start2,\n      length1: patch.length1,\n      length2: patch.length2,\n      utf8Length1: patch.utf8Length1,\n      utf8Length2: patch.utf8Length2\n    });\n  return adjusted;\n}\nfunction utf8len(codePoint) {\n  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;\n}\nconst MAX_BITS = 32, DEFAULT_MARGIN = 4;\nfunction addPadding(patches, margin = DEFAULT_MARGIN) {\n  const paddingLength = margin;\n  let nullPadding = \"\";\n  for (let x = 1; x <= paddingLength; x++)\n    nullPadding += String.fromCharCode(x);\n  for (const p of patches)\n    p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;\n  let patch = patches[0], diffs = patch.diffs;\n  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL)\n    diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[0][1].length) {\n    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;\n    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL)\n    diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;\n  else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;\n  }\n  return nullPadding;\n}\nfunction createPatchObject(start1, start2) {\n  return {\n    diffs: [],\n    start1,\n    start2,\n    utf8Start1: start1,\n    utf8Start2: start2,\n    length1: 0,\n    length2: 0,\n    utf8Length1: 0,\n    utf8Length2: 0\n  };\n}\nfunction splitMax(patches, margin = DEFAULT_MARGIN) {\n  const patchSize = MAX_BITS;\n  for (let x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patchSize)\n      continue;\n    const bigpatch = patches[x];\n    patches.splice(x--, 1);\n    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = \"\";\n    for (; bigpatch.diffs.length !== 0; ) {\n      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);\n      let empty = !0;\n      if (preContext !== \"\") {\n        const precontextByteCount = countUtf8Bytes(preContext);\n        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);\n      }\n      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {\n        const diffType = bigpatch.diffs[0][0];\n        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);\n        if (diffType === DIFF_INSERT) {\n          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;\n          const diff2 = bigpatch.diffs.shift();\n          diff2 && patch.diffs.push(diff2), empty = !1;\n        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));\n      }\n      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);\n      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);\n      postContext !== \"\" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);\n    }\n  }\n}\nfunction apply(patches, originalText, opts = {}) {\n  if (typeof patches == \"string\")\n    throw new Error(\"Patches must be an array - pass the patch to `parsePatch()` first\");\n  let text = originalText;\n  if (patches.length === 0)\n    return [text, []];\n  const parsed = adjustIndiciesToUcs2(patches, text, {\n    allowExceedingIndices: opts.allowExceedingIndices\n  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);\n  text = nullPadding + text + nullPadding, splitMax(parsed, margin);\n  let delta = 0;\n  const results = [];\n  for (let x = 0; x < parsed.length; x++) {\n    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);\n    let startLoc, endLoc = -1;\n    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(\n      text,\n      text1.substring(text1.length - MAX_BITS),\n      expectedLoc + text1.length - MAX_BITS\n    ), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1)\n      results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;\n    else {\n      results[x] = !0, delta = startLoc - expectedLoc;\n      let text2;\n      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2)\n        text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);\n      else {\n        let diffs = diff(text1, text2, { checkLines: !1 });\n        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold)\n          results[x] = !1;\n        else {\n          diffs = cleanupSemanticLossless(diffs);\n          let index1 = 0, index2 = 0;\n          for (let y = 0; y < parsed[x].diffs.length; y++) {\n            const mod = parsed[x].diffs[y];\n            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);\n          }\n        }\n      }\n    }\n  }\n  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];\n}\nvar __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b))\n      __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);\n  return a;\n};\nconst DEFAULT_OPTS = {\n  margin: 4\n};\nfunction getDefaultOpts(opts = {}) {\n  return __spreadValues(__spreadValues({}, DEFAULT_OPTS), opts);\n}\nfunction make(a, b, options) {\n  if (typeof a == \"string\" && typeof b == \"string\") {\n    let diffs = diff(a, b, { checkLines: !0 });\n    return diffs.length > 2 && (diffs = cleanupSemantic(diffs), diffs = cleanupEfficiency(diffs)), _make(a, diffs, getDefaultOpts(options));\n  }\n  if (a && Array.isArray(a) && typeof b > \"u\")\n    return _make(diffText1(a), a, getDefaultOpts(options));\n  if (typeof a == \"string\" && b && Array.isArray(b))\n    return _make(a, b, getDefaultOpts(options));\n  throw new Error(\"Unknown call format to make()\");\n}\nfunction _make(textA, diffs, options) {\n  if (diffs.length === 0)\n    return [];\n  const patches = [];\n  let patch = createPatchObject(0, 0), patchDiffLength = 0, charCount1 = 0, charCount2 = 0, utf8Count1 = 0, utf8Count2 = 0, prepatchText = textA, postpatchText = textA;\n  for (let x = 0; x < diffs.length; x++) {\n    const currentDiff = diffs[x], [diffType, diffText] = currentDiff, diffTextLength = diffText.length, diffByteLength = countUtf8Bytes(diffText);\n    switch (!patchDiffLength && diffType !== DIFF_EQUAL && (patch.start1 = charCount1, patch.start2 = charCount2, patch.utf8Start1 = utf8Count1, patch.utf8Start2 = utf8Count2), diffType) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = currentDiff, patch.length2 += diffTextLength, patch.utf8Length2 += diffByteLength, postpatchText = postpatchText.substring(0, charCount2) + diffText + postpatchText.substring(charCount2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.diffs[patchDiffLength++] = currentDiff, postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + diffTextLength);\n        break;\n      case DIFF_EQUAL:\n        diffTextLength <= 2 * options.margin && patchDiffLength && diffs.length !== x + 1 ? (patch.diffs[patchDiffLength++] = currentDiff, patch.length1 += diffTextLength, patch.length2 += diffTextLength, patch.utf8Length1 += diffByteLength, patch.utf8Length2 += diffByteLength) : diffTextLength >= 2 * options.margin && patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch), patch = createPatchObject(-1, -1), patchDiffLength = 0, prepatchText = postpatchText, charCount1 = charCount2, utf8Count1 = utf8Count2);\n        break;\n      default:\n        throw new Error(\"Unknown diff type\");\n    }\n    diffType !== DIFF_INSERT && (charCount1 += diffTextLength, utf8Count1 += diffByteLength), diffType !== DIFF_DELETE && (charCount2 += diffTextLength, utf8Count2 += diffByteLength);\n  }\n  return patchDiffLength && (addContext(patch, prepatchText, options), patches.push(patch)), patches;\n}\nfunction addContext(patch, text, opts) {\n  if (text.length === 0)\n    return;\n  let pattern = text.substring(patch.start2, patch.start2 + patch.length1), padding = 0;\n  for (; text.indexOf(pattern) !== text.lastIndexOf(pattern) && pattern.length < MAX_BITS - opts.margin - opts.margin; )\n    padding += opts.margin, pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);\n  padding += opts.margin;\n  let prefixStart = patch.start2 - padding;\n  prefixStart >= 1 && isLowSurrogate(text[prefixStart]) && prefixStart--;\n  const prefix = text.substring(prefixStart, patch.start2);\n  prefix && patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  const prefixLength = prefix.length, prefixUtf8Length = countUtf8Bytes(prefix);\n  let suffixEnd = patch.start2 + patch.length1 + padding;\n  suffixEnd < text.length && isLowSurrogate(text[suffixEnd]) && suffixEnd++;\n  const suffix = text.substring(patch.start2 + patch.length1, suffixEnd);\n  suffix && patch.diffs.push([DIFF_EQUAL, suffix]);\n  const suffixLength = suffix.length, suffixUtf8Length = countUtf8Bytes(suffix);\n  patch.start1 -= prefixLength, patch.start2 -= prefixLength, patch.utf8Start1 -= prefixUtf8Length, patch.utf8Start2 -= prefixUtf8Length, patch.length1 += prefixLength + suffixLength, patch.length2 += prefixLength + suffixLength, patch.utf8Length1 += prefixUtf8Length + suffixUtf8Length, patch.utf8Length2 += prefixUtf8Length + suffixUtf8Length;\n}\nconst patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\nfunction parse(textline) {\n  if (!textline)\n    return [];\n  const patches = [], lines = textline.split(`\n`);\n  let textPointer = 0;\n  for (; textPointer < lines.length; ) {\n    const m = lines[textPointer].match(patchHeader);\n    if (!m)\n      throw new Error(`Invalid patch string: ${lines[textPointer]}`);\n    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));\n    for (patches.push(patch), m[2] === \"\" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === \"0\" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === \"\" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === \"0\" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {\n      const currentLine = lines[textPointer], sign = currentLine.charAt(0);\n      if (sign === \"@\")\n        break;\n      if (sign === \"\") {\n        textPointer++;\n        continue;\n      }\n      let line;\n      try {\n        line = decodeURI(currentLine.slice(1));\n      } catch (ex) {\n        throw new Error(`Illegal escape in parse: ${currentLine}`);\n      }\n      const utf8Diff = countUtf8Bytes(line) - line.length;\n      if (sign === \"-\")\n        patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;\n      else if (sign === \"+\")\n        patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;\n      else if (sign === \" \")\n        patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;\n      else\n        throw new Error(`Invalid patch mode \"${sign}\" in: ${line}`);\n      textPointer++;\n    }\n  }\n  return patches;\n}\nfunction toInt(num) {\n  return parseInt(num, 10);\n}\nfunction stringify(patches) {\n  return patches.map(stringifyPatch).join(\"\");\n}\nfunction stringifyPatch(patch) {\n  const { utf8Length1, utf8Length2, utf8Start1, utf8Start2, diffs } = patch;\n  let coords1;\n  utf8Length1 === 0 ? coords1 = `${utf8Start1},0` : utf8Length1 === 1 ? coords1 = `${utf8Start1 + 1}` : coords1 = `${utf8Start1 + 1},${utf8Length1}`;\n  let coords2;\n  utf8Length2 === 0 ? coords2 = `${utf8Start2},0` : utf8Length2 === 1 ? coords2 = `${utf8Start2 + 1}` : coords2 = `${utf8Start2 + 1},${utf8Length2}`;\n  const text = [`@@ -${coords1} +${coords2} @@\n`];\n  let op;\n  for (let x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        op = \"+\";\n        break;\n      case DIFF_DELETE:\n        op = \"-\";\n        break;\n      case DIFF_EQUAL:\n        op = \" \";\n        break;\n      default:\n        throw new Error(\"Unknown patch operation.\");\n    }\n    text[x + 1] = `${op + encodeURI(diffs[x][1])}\n`;\n  }\n  return text.join(\"\").replace(/%20/g, \" \");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzYW5pdHkrZGlmZi1tYXRjaC1wYXRjaEAzLjIuMC9ub2RlX21vZHVsZXMvQHNhbml0eS9kaWZmLW1hdGNoLXBhdGNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0M7QUFDeEQsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0VBQStFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtSEFBbUg7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLDBCQUEwQixxQ0FBcUMsMEJBQTBCO0FBQzVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQTZDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVSQUF1Uix1REFBdUQ7QUFDOVUsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwRUFBMEU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQSx5R0FBeUcsd0JBQXdCO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUF3QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHVSQUF1Uix1REFBdUQ7QUFDOVUsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBLQUEwSztBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtRUFBbUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMlFBQTJRLHVEQUF1RDtBQUNsVSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEdBQThHO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNEJBQTRCO0FBQ3JDO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFO0FBQ0EsdWpCQUF1akIsNEJBQTRCO0FBQ25sQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSyxRQUFRLEtBQUs7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBMEQ7QUFDcEU7QUFDQSxtQ0FBbUMsV0FBVyx1Q0FBdUMsZUFBZSxpQkFBaUIsZUFBZSxHQUFHLFlBQVk7QUFDbko7QUFDQSxtQ0FBbUMsV0FBVyx1Q0FBdUMsZUFBZSxpQkFBaUIsZUFBZSxHQUFHLFlBQVk7QUFDbkosdUJBQXVCLFNBQVMsR0FBRyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBZ0JFO0FBQ0YiLCJzb3VyY2VzIjpbIkQ6XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAc2FuaXR5K2RpZmYtbWF0Y2gtcGF0Y2hAMy4yLjBcXG5vZGVfbW9kdWxlc1xcQHNhbml0eVxcZGlmZi1tYXRjaC1wYXRjaFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2xvbmVEaWZmKGRpZmYyKSB7XG4gIGNvbnN0IFt0eXBlLCBwYXRjaF0gPSBkaWZmMjtcbiAgcmV0dXJuIFt0eXBlLCBwYXRjaF07XG59XG5mdW5jdGlvbiBnZXRDb21tb25PdmVybGFwKHRleHRBLCB0ZXh0Qikge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgY29uc3QgdGV4dDFMZW5ndGggPSB0ZXh0MS5sZW5ndGgsIHRleHQyTGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICBpZiAodGV4dDFMZW5ndGggPT09IDAgfHwgdGV4dDJMZW5ndGggPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIHRleHQxTGVuZ3RoID4gdGV4dDJMZW5ndGggPyB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoKSA6IHRleHQxTGVuZ3RoIDwgdGV4dDJMZW5ndGggJiYgKHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxTGVuZ3RoKSk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSBNYXRoLm1pbih0ZXh0MUxlbmd0aCwgdGV4dDJMZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKVxuICAgIHJldHVybiB0ZXh0TGVuZ3RoO1xuICBsZXQgYmVzdCA9IDAsIGxlbmd0aCA9IDE7XG4gIGZvciAobGV0IGZvdW5kID0gMDsgZm91bmQgIT09IC0xOyApIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRMZW5ndGggLSBsZW5ndGgpO1xuICAgIGlmIChmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybiksIGZvdW5kID09PSAtMSlcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZCwgKGZvdW5kID09PSAwIHx8IHRleHQxLnN1YnN0cmluZyh0ZXh0TGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpICYmIChiZXN0ID0gbGVuZ3RoLCBsZW5ndGgrKyk7XG4gIH1cbiAgcmV0dXJuIGJlc3Q7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxWzBdICE9PSB0ZXh0MlswXSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJNaW4gPSAwLCBwb2ludGVyTWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpLCBwb2ludGVyTWlkID0gcG9pbnRlck1heCwgcG9pbnRlclN0YXJ0ID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApXG4gICAgdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJTdGFydCwgcG9pbnRlck1pZCkgPT09IHRleHQyLnN1YnN0cmluZyhwb2ludGVyU3RhcnQsIHBvaW50ZXJNaWQpID8gKHBvaW50ZXJNaW4gPSBwb2ludGVyTWlkLCBwb2ludGVyU3RhcnQgPSBwb2ludGVyTWluKSA6IHBvaW50ZXJNYXggPSBwb2ludGVyTWlkLCBwb2ludGVyTWlkID0gTWF0aC5mbG9vcigocG9pbnRlck1heCAtIHBvaW50ZXJNaW4pIC8gMiArIHBvaW50ZXJNaW4pO1xuICByZXR1cm4gcG9pbnRlck1pZDtcbn1cbmZ1bmN0aW9uIGdldENvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDFbdGV4dDEubGVuZ3RoIC0gMV0gIT09IHRleHQyW3RleHQyLmxlbmd0aCAtIDFdKVxuICAgIHJldHVybiAwO1xuICBsZXQgcG9pbnRlck1pbiA9IDAsIHBvaW50ZXJNYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCksIHBvaW50ZXJNaWQgPSBwb2ludGVyTWF4LCBwb2ludGVyRW5kID0gMDtcbiAgZm9yICg7IHBvaW50ZXJNaW4gPCBwb2ludGVyTWlkOyApXG4gICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJNaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJFbmQpID09PSB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlck1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlckVuZCkgPyAocG9pbnRlck1pbiA9IHBvaW50ZXJNaWQsIHBvaW50ZXJFbmQgPSBwb2ludGVyTWluKSA6IHBvaW50ZXJNYXggPSBwb2ludGVyTWlkLCBwb2ludGVyTWlkID0gTWF0aC5mbG9vcigocG9pbnRlck1heCAtIHBvaW50ZXJNaW4pIC8gMiArIHBvaW50ZXJNaW4pO1xuICByZXR1cm4gcG9pbnRlck1pZDtcbn1cbmZ1bmN0aW9uIGlzSGlnaFN1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTUyOTYgJiYgY2hhckNvZGUgPD0gNTYzMTk7XG59XG5mdW5jdGlvbiBpc0xvd1N1cnJvZ2F0ZShjaGFyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY2hhckNvZGUgPj0gNTYzMjAgJiYgY2hhckNvZGUgPD0gNTczNDM7XG59XG5mdW5jdGlvbiBiaXNlY3QodGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MUxlbmd0aCA9IHRleHQxLmxlbmd0aCwgdGV4dDJMZW5ndGggPSB0ZXh0Mi5sZW5ndGgsIG1heEQgPSBNYXRoLmNlaWwoKHRleHQxTGVuZ3RoICsgdGV4dDJMZW5ndGgpIC8gMiksIHZPZmZzZXQgPSBtYXhELCB2TGVuZ3RoID0gMiAqIG1heEQsIHYxID0gbmV3IEFycmF5KHZMZW5ndGgpLCB2MiA9IG5ldyBBcnJheSh2TGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB2TGVuZ3RoOyB4KyspXG4gICAgdjFbeF0gPSAtMSwgdjJbeF0gPSAtMTtcbiAgdjFbdk9mZnNldCArIDFdID0gMCwgdjJbdk9mZnNldCArIDFdID0gMDtcbiAgY29uc3QgZGVsdGEgPSB0ZXh0MUxlbmd0aCAtIHRleHQyTGVuZ3RoLCBmcm9udCA9IGRlbHRhICUgMiAhPT0gMDtcbiAgbGV0IGsxc3RhcnQgPSAwLCBrMWVuZCA9IDAsIGsyc3RhcnQgPSAwLCBrMmVuZCA9IDA7XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgbWF4RCAmJiAhKERhdGUubm93KCkgPiBkZWFkbGluZSk7IGQrKykge1xuICAgIGZvciAobGV0IGsxID0gLWQgKyBrMXN0YXJ0OyBrMSA8PSBkIC0gazFlbmQ7IGsxICs9IDIpIHtcbiAgICAgIGNvbnN0IGsxT2Zmc2V0ID0gdk9mZnNldCArIGsxO1xuICAgICAgbGV0IHgxO1xuICAgICAgazEgPT09IC1kIHx8IGsxICE9PSBkICYmIHYxW2sxT2Zmc2V0IC0gMV0gPCB2MVtrMU9mZnNldCArIDFdID8geDEgPSB2MVtrMU9mZnNldCArIDFdIDogeDEgPSB2MVtrMU9mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MSA9IHgxIC0gazE7XG4gICAgICBmb3IgKDsgeDEgPCB0ZXh0MUxlbmd0aCAmJiB5MSA8IHRleHQyTGVuZ3RoICYmIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSk7IClcbiAgICAgICAgeDErKywgeTErKztcbiAgICAgIGlmICh2MVtrMU9mZnNldF0gPSB4MSwgeDEgPiB0ZXh0MUxlbmd0aClcbiAgICAgICAgazFlbmQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKHkxID4gdGV4dDJMZW5ndGgpXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcbiAgICAgIGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgIGNvbnN0IGsyT2Zmc2V0ID0gdk9mZnNldCArIGRlbHRhIC0gazE7XG4gICAgICAgIGlmIChrMk9mZnNldCA+PSAwICYmIGsyT2Zmc2V0IDwgdkxlbmd0aCAmJiB2MltrMk9mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDIgPSB0ZXh0MUxlbmd0aCAtIHYyW2syT2Zmc2V0XTtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpXG4gICAgICAgICAgICByZXR1cm4gYmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMk9mZnNldCA9IHZPZmZzZXQgKyBrMjtcbiAgICAgIGxldCB4MjtcbiAgICAgIGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMk9mZnNldCAtIDFdIDwgdjJbazJPZmZzZXQgKyAxXSA/IHgyID0gdjJbazJPZmZzZXQgKyAxXSA6IHgyID0gdjJbazJPZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTIgPSB4MiAtIGsyO1xuICAgICAgZm9yICg7IHgyIDwgdGV4dDFMZW5ndGggJiYgeTIgPCB0ZXh0Mkxlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFMZW5ndGggLSB4MiAtIDEpID09PSB0ZXh0Mi5jaGFyQXQodGV4dDJMZW5ndGggLSB5MiAtIDEpOyApXG4gICAgICAgIHgyKyssIHkyKys7XG4gICAgICBpZiAodjJbazJPZmZzZXRdID0geDIsIHgyID4gdGV4dDFMZW5ndGgpXG4gICAgICAgIGsyZW5kICs9IDI7XG4gICAgICBlbHNlIGlmICh5MiA+IHRleHQyTGVuZ3RoKVxuICAgICAgICBrMnN0YXJ0ICs9IDI7XG4gICAgICBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFPZmZzZXQgPSB2T2Zmc2V0ICsgZGVsdGEgLSBrMjtcbiAgICAgICAgaWYgKGsxT2Zmc2V0ID49IDAgJiYgazFPZmZzZXQgPCB2TGVuZ3RoICYmIHYxW2sxT2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxT2Zmc2V0XSwgeTEgPSB2T2Zmc2V0ICsgeDEgLSBrMU9mZnNldDtcbiAgICAgICAgICBpZiAoeDIgPSB0ZXh0MUxlbmd0aCAtIHgyLCB4MSA+PSB4MilcbiAgICAgICAgICAgIHJldHVybiBiaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbXG4gICAgW0RJRkZfREVMRVRFLCB0ZXh0MV0sXG4gICAgW0RJRkZfSU5TRVJULCB0ZXh0Ml1cbiAgXTtcbn1cbmZ1bmN0aW9uIGJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0MiwgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpLCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSksIHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KSwgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpLCBkaWZmcyA9IGRvRGlmZih0ZXh0MWEsIHRleHQyYSwgeyBjaGVja0xpbmVzOiAhMSwgZGVhZGxpbmUgfSksIGRpZmZzYiA9IGRvRGlmZih0ZXh0MWIsIHRleHQyYiwgeyBjaGVja0xpbmVzOiAhMSwgZGVhZGxpbmUgfSk7XG4gIHJldHVybiBkaWZmcy5jb25jYXQoZGlmZnNiKTtcbn1cbmZ1bmN0aW9uIGZpbmRIYWxmTWF0Y2godGV4dDEsIHRleHQyLCB0aW1lb3V0ID0gMSkge1xuICBpZiAodGltZW91dCA8PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBsb25nVGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDIsIHNob3J0VGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25nVGV4dC5sZW5ndGggPCA0IHx8IHNob3J0VGV4dC5sZW5ndGggKiAyIDwgbG9uZ1RleHQubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBoYWxmTWF0Y2gxID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gNCkpLCBoYWxmTWF0Y2gyID0gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBNYXRoLmNlaWwobG9uZ1RleHQubGVuZ3RoIC8gMikpO1xuICBsZXQgaGFsZk1hdGNoO1xuICBpZiAoaGFsZk1hdGNoMSAmJiBoYWxmTWF0Y2gyKVxuICAgIGhhbGZNYXRjaCA9IGhhbGZNYXRjaDFbNF0ubGVuZ3RoID4gaGFsZk1hdGNoMls0XS5sZW5ndGggPyBoYWxmTWF0Y2gxIDogaGFsZk1hdGNoMjtcbiAgZWxzZSB7XG4gICAgaWYgKCFoYWxmTWF0Y2gxICYmICFoYWxmTWF0Y2gyKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaGFsZk1hdGNoMiA/IGhhbGZNYXRjaDEgfHwgKGhhbGZNYXRjaCA9IGhhbGZNYXRjaDIpIDogaGFsZk1hdGNoID0gaGFsZk1hdGNoMTtcbiAgfVxuICBpZiAoIWhhbGZNYXRjaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhIGhhbGYgbWF0Y2guXCIpO1xuICBsZXQgdGV4dDFBLCB0ZXh0MUIsIHRleHQyQSwgdGV4dDJCO1xuICB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyAodGV4dDFBID0gaGFsZk1hdGNoWzBdLCB0ZXh0MUIgPSBoYWxmTWF0Y2hbMV0sIHRleHQyQSA9IGhhbGZNYXRjaFsyXSwgdGV4dDJCID0gaGFsZk1hdGNoWzNdKSA6ICh0ZXh0MkEgPSBoYWxmTWF0Y2hbMF0sIHRleHQyQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDFBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MUIgPSBoYWxmTWF0Y2hbM10pO1xuICBjb25zdCBtaWRDb21tb24gPSBoYWxmTWF0Y2hbNF07XG4gIHJldHVybiBbdGV4dDFBLCB0ZXh0MUIsIHRleHQyQSwgdGV4dDJCLCBtaWRDb21tb25dO1xufVxuZnVuY3Rpb24gaGFsZk1hdGNoSShsb25nVGV4dCwgc2hvcnRUZXh0LCBpKSB7XG4gIGNvbnN0IHNlZWQgPSBsb25nVGV4dC5zbGljZShpLCBpICsgTWF0aC5mbG9vcihsb25nVGV4dC5sZW5ndGggLyA0KSk7XG4gIGxldCBqID0gLTEsIGJlc3RDb21tb24gPSBcIlwiLCBiZXN0TG9uZ1RleHRBLCBiZXN0TG9uZ1RleHRCLCBiZXN0U2hvcnRUZXh0QSwgYmVzdFNob3J0VGV4dEI7XG4gIGZvciAoOyAoaiA9IHNob3J0VGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT09IC0xOyApIHtcbiAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBnZXRDb21tb25QcmVmaXgobG9uZ1RleHQuc2xpY2UoaSksIHNob3J0VGV4dC5zbGljZShqKSksIHN1ZmZpeExlbmd0aCA9IGdldENvbW1vblN1ZmZpeChsb25nVGV4dC5zbGljZSgwLCBpKSwgc2hvcnRUZXh0LnNsaWNlKDAsIGopKTtcbiAgICBiZXN0Q29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCAmJiAoYmVzdENvbW1vbiA9IHNob3J0VGV4dC5zbGljZShqIC0gc3VmZml4TGVuZ3RoLCBqKSArIHNob3J0VGV4dC5zbGljZShqLCBqICsgcHJlZml4TGVuZ3RoKSwgYmVzdExvbmdUZXh0QSA9IGxvbmdUZXh0LnNsaWNlKDAsIGkgLSBzdWZmaXhMZW5ndGgpLCBiZXN0TG9uZ1RleHRCID0gbG9uZ1RleHQuc2xpY2UoaSArIHByZWZpeExlbmd0aCksIGJlc3RTaG9ydFRleHRBID0gc2hvcnRUZXh0LnNsaWNlKDAsIGogLSBzdWZmaXhMZW5ndGgpLCBiZXN0U2hvcnRUZXh0QiA9IHNob3J0VGV4dC5zbGljZShqICsgcHJlZml4TGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIGJlc3RDb21tb24ubGVuZ3RoICogMiA+PSBsb25nVGV4dC5sZW5ndGggPyBbXG4gICAgYmVzdExvbmdUZXh0QSB8fCBcIlwiLFxuICAgIGJlc3RMb25nVGV4dEIgfHwgXCJcIixcbiAgICBiZXN0U2hvcnRUZXh0QSB8fCBcIlwiLFxuICAgIGJlc3RTaG9ydFRleHRCIHx8IFwiXCIsXG4gICAgYmVzdENvbW1vbiB8fCBcIlwiXG4gIF0gOiBudWxsO1xufVxuZnVuY3Rpb24gY2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IGNoYXJzID0gZGlmZnNbeF1bMV0sIHRleHQgPSBbXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGNoYXJzLmxlbmd0aDsgeSsrKVxuICAgICAgdGV4dFt5XSA9IGxpbmVBcnJheVtjaGFycy5jaGFyQ29kZUF0KHkpXTtcbiAgICBkaWZmc1t4XVsxXSA9IHRleHQuam9pbihcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gbGluZXNUb0NoYXJzKHRleHRBLCB0ZXh0Qikge1xuICBjb25zdCBsaW5lQXJyYXkgPSBbXSwgbGluZUhhc2ggPSB7fTtcbiAgbGluZUFycmF5WzBdID0gXCJcIjtcbiAgZnVuY3Rpb24gZGlmZkxpbmVzVG9NdW5nZSh0ZXh0KSB7XG4gICAgbGV0IGNoYXJzID0gXCJcIiwgbGluZVN0YXJ0ID0gMCwgbGluZUVuZCA9IC0xLCBsaW5lQXJyYXlMZW5ndGggPSBsaW5lQXJyYXkubGVuZ3RoO1xuICAgIGZvciAoOyBsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxOyApIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoYFxuYCwgbGluZVN0YXJ0KSwgbGluZUVuZCA9PT0gLTEgJiYgKGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuICAgICAgKGxpbmVIYXNoLmhhc093blByb3BlcnR5ID8gbGluZUhhc2guaGFzT3duUHJvcGVydHkobGluZSkgOiBsaW5lSGFzaFtsaW5lXSAhPT0gdm9pZCAwKSA/IGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pIDogKGxpbmVBcnJheUxlbmd0aCA9PT0gbWF4TGluZXMgJiYgKGxpbmUgPSB0ZXh0LnNsaWNlKGxpbmVTdGFydCksIGxpbmVFbmQgPSB0ZXh0Lmxlbmd0aCksIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKSwgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGgsIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lKSwgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuICBsZXQgbWF4TGluZXMgPSA0ZTQ7XG4gIGNvbnN0IGNoYXJzMSA9IGRpZmZMaW5lc1RvTXVuZ2UodGV4dEEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICBjb25zdCBjaGFyczIgPSBkaWZmTGluZXNUb011bmdlKHRleHRCKTtcbiAgcmV0dXJuIHsgY2hhcnMxLCBjaGFyczIsIGxpbmVBcnJheSB9O1xufVxuZnVuY3Rpb24gZG9MaW5lTW9kZURpZmYodGV4dEEsIHRleHRCLCBvcHRzKSB7XG4gIGxldCB0ZXh0MSA9IHRleHRBLCB0ZXh0MiA9IHRleHRCO1xuICBjb25zdCBhID0gbGluZXNUb0NoYXJzKHRleHQxLCB0ZXh0Mik7XG4gIHRleHQxID0gYS5jaGFyczEsIHRleHQyID0gYS5jaGFyczI7XG4gIGNvbnN0IGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xuICBsZXQgZGlmZnMgPSBkb0RpZmYodGV4dDEsIHRleHQyLCB7XG4gICAgY2hlY2tMaW5lczogITEsXG4gICAgZGVhZGxpbmU6IG9wdHMuZGVhZGxpbmVcbiAgfSk7XG4gIGNoYXJzVG9MaW5lcyhkaWZmcywgbGluZWFycmF5KSwgZGlmZnMgPSBjbGVhbnVwU2VtYW50aWMoZGlmZnMpLCBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGg7ICkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnREZWxldGUrKywgdGV4dERlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChjb3VudERlbGV0ZSA+PSAxICYmIGNvdW50SW5zZXJ0ID49IDEpIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQsIGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQpLCBwb2ludGVyID0gcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQ7XG4gICAgICAgICAgY29uc3QgYWEgPSBkb0RpZmYodGV4dERlbGV0ZSwgdGV4dEluc2VydCwge1xuICAgICAgICAgICAgY2hlY2tMaW5lczogITEsXG4gICAgICAgICAgICBkZWFkbGluZTogb3B0cy5kZWFkbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAobGV0IGogPSBhYS5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhYVtqXSk7XG4gICAgICAgICAgcG9pbnRlciArPSBhYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uLlwiKTtcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIHJldHVybiBkaWZmcy5wb3AoKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdHMpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKVxuICAgIHJldHVybiBbW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xuICBpZiAoIXRleHQyKVxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV1dO1xuICBjb25zdCBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDIsIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDEsIGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XG4gIGlmIChpICE9PSAtMSlcbiAgICByZXR1cm4gZGlmZnMgPSBbXG4gICAgICBbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXG4gICAgICBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSxcbiAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1cbiAgICBdLCB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggJiYgKGRpZmZzWzBdWzBdID0gRElGRl9ERUxFVEUsIGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEUpLCBkaWZmcztcbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIFtcbiAgICAgIFtESUZGX0RFTEVURSwgdGV4dDFdLFxuICAgICAgW0RJRkZfSU5TRVJULCB0ZXh0Ml1cbiAgICBdO1xuICBjb25zdCBoYWxmTWF0Y2ggPSBmaW5kSGFsZk1hdGNoKHRleHQxLCB0ZXh0Mik7XG4gIGlmIChoYWxmTWF0Y2gpIHtcbiAgICBjb25zdCB0ZXh0MUEgPSBoYWxmTWF0Y2hbMF0sIHRleHQxQiA9IGhhbGZNYXRjaFsxXSwgdGV4dDJBID0gaGFsZk1hdGNoWzJdLCB0ZXh0MkIgPSBoYWxmTWF0Y2hbM10sIG1pZENvbW1vbiA9IGhhbGZNYXRjaFs0XSwgZGlmZnNBID0gZG9EaWZmKHRleHQxQSwgdGV4dDJBLCBvcHRzKSwgZGlmZnNCID0gZG9EaWZmKHRleHQxQiwgdGV4dDJCLCBvcHRzKTtcbiAgICByZXR1cm4gZGlmZnNBLmNvbmNhdChbW0RJRkZfRVFVQUwsIG1pZENvbW1vbl1dLCBkaWZmc0IpO1xuICB9XG4gIHJldHVybiBvcHRzLmNoZWNrTGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCA/IGRvTGluZU1vZGVEaWZmKHRleHQxLCB0ZXh0Miwgb3B0cykgOiBiaXNlY3QodGV4dDEsIHRleHQyLCBvcHRzLmRlYWRsaW5lKTtcbn1cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQyID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMiA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMiA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AkMi5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQyKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQyKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQyKGIpKVxuICAgICAgX19wcm9wSXNFbnVtJDIuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMihhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgRElGRl9ERUxFVEUgPSAtMSwgRElGRl9JTlNFUlQgPSAxLCBESUZGX0VRVUFMID0gMDtcbmZ1bmN0aW9uIGRpZmYodGV4dEEsIHRleHRCLCBvcHRzKSB7XG4gIGlmICh0ZXh0QSA9PT0gbnVsbCB8fCB0ZXh0QiA9PT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZilcIik7XG4gIGNvbnN0IGRpZmZzID0gZG9EaWZmKHRleHRBLCB0ZXh0QiwgY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMgfHwge30pKTtcbiAgcmV0dXJuIGFkanVzdERpZmZGb3JTdXJyb2dhdGVQYWlycyhkaWZmcyksIGRpZmZzO1xufVxuZnVuY3Rpb24gZG9EaWZmKHRleHRBLCB0ZXh0Qiwgb3B0aW9ucykge1xuICBsZXQgdGV4dDEgPSB0ZXh0QSwgdGV4dDIgPSB0ZXh0QjtcbiAgaWYgKHRleHQxID09PSB0ZXh0MilcbiAgICByZXR1cm4gdGV4dDEgPyBbW0RJRkZfRVFVQUwsIHRleHQxXV0gOiBbXTtcbiAgbGV0IGNvbW1vbmxlbmd0aCA9IGdldENvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpLCB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICBsZXQgZGlmZnMgPSBjb21wdXRlRGlmZih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpO1xuICByZXR1cm4gY29tbW9ucHJlZml4ICYmIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIGNvbW1vbnByZWZpeF0pLCBjb21tb25zdWZmaXggJiYgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgY29tbW9uc3VmZml4XSksIGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSwgZGlmZnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWFkTGluZSh0aW1lb3V0KSB7XG4gIGxldCB0ID0gMTtcbiAgcmV0dXJuIHR5cGVvZiB0aW1lb3V0IDwgXCJ1XCIgJiYgKHQgPSB0aW1lb3V0IDw9IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogdGltZW91dCksIERhdGUubm93KCkgKyB0ICogMWUzO1xufVxuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxPcHRzKG9wdHMpIHtcbiAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzJDIoe1xuICAgIGNoZWNrTGluZXM6ICEwLFxuICAgIGRlYWRsaW5lOiBjcmVhdGVEZWFkTGluZShvcHRzLnRpbWVvdXQgfHwgMSlcbiAgfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBjb21iaW5lQ2hhcihkYXRhLCBjaGFyLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRhdGEgKyBjaGFyIDogY2hhciArIGRhdGE7XG59XG5mdW5jdGlvbiBzcGxpdENoYXIoZGF0YSwgZGlyKSB7XG4gIHJldHVybiBkaXIgPT09IDEgPyBbZGF0YS5zdWJzdHJpbmcoMCwgZGF0YS5sZW5ndGggLSAxKSwgZGF0YVtkYXRhLmxlbmd0aCAtIDFdXSA6IFtkYXRhLnN1YnN0cmluZygxKSwgZGF0YVswXV07XG59XG5mdW5jdGlvbiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpLCBqLCBkaXIpIHtcbiAgcmV0dXJuIGRpciA9PT0gMSA/IGRpZmZzW2ldWzFdW2RpZmZzW2ldWzFdLmxlbmd0aCAtIDFdID09PSBkaWZmc1tqXVsxXVtkaWZmc1tqXVsxXS5sZW5ndGggLSAxXSA6IGRpZmZzW2ldWzFdWzBdID09PSBkaWZmc1tqXVsxXVswXTtcbn1cbmZ1bmN0aW9uIGRlaXNvbGF0ZUNoYXIoZGlmZnMsIGksIGRpcikge1xuICBjb25zdCBpbnYgPSBkaXIgPT09IDEgPyAtMSA6IDE7XG4gIGxldCBpbnNlcnRJZHggPSBudWxsLCBkZWxldGVJZHggPSBudWxsLCBqID0gaSArIGRpcjtcbiAgZm9yICg7IGogPj0gMCAmJiBqIDwgZGlmZnMubGVuZ3RoICYmIChpbnNlcnRJZHggPT09IG51bGwgfHwgZGVsZXRlSWR4ID09PSBudWxsKTsgaiArPSBkaXIpIHtcbiAgICBjb25zdCBbb3AsIHRleHQyXSA9IGRpZmZzW2pdO1xuICAgIGlmICh0ZXh0Mi5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChvcCA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgaW5zZXJ0SWR4ID09PSBudWxsICYmIChpbnNlcnRJZHggPSBqKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG9wID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICBkZWxldGVJZHggPT09IG51bGwgJiYgKGRlbGV0ZUlkeCA9IGopO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAob3AgPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgaWYgKGluc2VydElkeCA9PT0gbnVsbCAmJiBkZWxldGVJZHggPT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBbcmVzdCwgY2hhcjJdID0gc3BsaXRDaGFyKGRpZmZzW2ldWzFdLCBkaXIpO1xuICAgICAgICAgIGRpZmZzW2ldWzFdID0gcmVzdCwgZGlmZnNbal1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tqXVsxXSwgY2hhcjIsIGludik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5zZXJ0SWR4ICE9PSBudWxsICYmIGRlbGV0ZUlkeCAhPT0gbnVsbCAmJiBoYXNTaGFyZWRDaGFyKGRpZmZzLCBpbnNlcnRJZHgsIGRlbGV0ZUlkeCwgZGlyKSkge1xuICAgIGNvbnN0IFtpbnNlcnRUZXh0LCBpbnNlcnRDaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpbnNlcnRJZHhdWzFdLCBpbnYpLCBbZGVsZXRlVGV4dF0gPSBzcGxpdENoYXIoZGlmZnNbZGVsZXRlSWR4XVsxXSwgaW52KTtcbiAgICBkaWZmc1tpbnNlcnRJZHhdWzFdID0gaW5zZXJ0VGV4dCwgZGlmZnNbZGVsZXRlSWR4XVsxXSA9IGRlbGV0ZVRleHQsIGRpZmZzW2ldWzFdID0gY29tYmluZUNoYXIoZGlmZnNbaV1bMV0sIGluc2VydENoYXIsIGRpcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IFt0ZXh0LCBjaGFyXSA9IHNwbGl0Q2hhcihkaWZmc1tpXVsxXSwgZGlyKTtcbiAgZGlmZnNbaV1bMV0gPSB0ZXh0LCBpbnNlcnRJZHggPT09IG51bGwgPyAoZGlmZnMuc3BsaWNlKGosIDAsIFtESUZGX0lOU0VSVCwgY2hhcl0pLCBkZWxldGVJZHggIT09IG51bGwgJiYgZGVsZXRlSWR4ID49IGogJiYgZGVsZXRlSWR4KyspIDogZGlmZnNbaW5zZXJ0SWR4XVsxXSA9IGNvbWJpbmVDaGFyKGRpZmZzW2luc2VydElkeF1bMV0sIGNoYXIsIGludiksIGRlbGV0ZUlkeCA9PT0gbnVsbCA/IGRpZmZzLnNwbGljZShqLCAwLCBbRElGRl9ERUxFVEUsIGNoYXJdKSA6IGRpZmZzW2RlbGV0ZUlkeF1bMV0gPSBjb21iaW5lQ2hhcihkaWZmc1tkZWxldGVJZHhdWzFdLCBjaGFyLCBpbnYpO1xufVxuZnVuY3Rpb24gYWRqdXN0RGlmZkZvclN1cnJvZ2F0ZVBhaXJzKGRpZmZzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGRpZmZzW2ldO1xuICAgIGlmIChkaWZmVGV4dC5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZpcnN0Q2hhciA9IGRpZmZUZXh0WzBdLCBsYXN0Q2hhciA9IGRpZmZUZXh0W2RpZmZUZXh0Lmxlbmd0aCAtIDFdO1xuICAgIGlzSGlnaFN1cnJvZ2F0ZShsYXN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgMSksIGlzTG93U3Vycm9nYXRlKGZpcnN0Q2hhcikgJiYgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgJiYgZGVpc29sYXRlQ2hhcihkaWZmcywgaSwgLTEpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZnMubGVuZ3RoOyBpKyspXG4gICAgZGlmZnNbaV1bMV0ubGVuZ3RoID09PSAwICYmIGRpZmZzLnNwbGljZShpLCAxKTtcbn1cbmZ1bmN0aW9uIGNsZWFudXBTZW1hbnRpYyhyYXdEaWZmcykge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIGxlbmd0aEluc2VydGlvbnMxID0gMCwgbGVuZ3RoRGVsZXRpb25zMSA9IDAsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDA7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApXG4gICAgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgbGVuZ3RoSW5zZXJ0aW9uczEgPSBsZW5ndGhJbnNlcnRpb25zMiwgbGVuZ3RoRGVsZXRpb25zMSA9IGxlbmd0aERlbGV0aW9uczIsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDAsIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdKSA6IChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQgPyBsZW5ndGhJbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggOiBsZW5ndGhEZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCwgbGFzdEVxdWFsaXR5ICYmIGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoSW5zZXJ0aW9uczEsIGxlbmd0aERlbGV0aW9uczEpICYmIGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoSW5zZXJ0aW9uczIsIGxlbmd0aERlbGV0aW9uczIpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBlcXVhbGl0aWVzTGVuZ3RoLS0sIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTEsIGxlbmd0aEluc2VydGlvbnMxID0gMCwgbGVuZ3RoRGVsZXRpb25zMSA9IDAsIGxlbmd0aEluc2VydGlvbnMyID0gMCwgbGVuZ3RoRGVsZXRpb25zMiA9IDAsIGxhc3RFcXVhbGl0eSA9IG51bGwsIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIGZvciAoaGFzQ2hhbmdlcyAmJiAoZGlmZnMgPSBjbGVhbnVwTWVyZ2UoZGlmZnMpKSwgZGlmZnMgPSBjbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyksIHBvaW50ZXIgPSAxOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0RFTEVURSAmJiBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLCBpbnNlcnRpb24gPSBkaWZmc1twb2ludGVyXVsxXSwgb3ZlcmxhcExlbmd0aDEgPSBnZXRDb21tb25PdmVybGFwKGRlbGV0aW9uLCBpbnNlcnRpb24pLCBvdmVybGFwTGVuZ3RoMiA9IGdldENvbW1vbk92ZXJsYXAoaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBvdmVybGFwTGVuZ3RoMSA+PSBvdmVybGFwTGVuZ3RoMiA/IChvdmVybGFwTGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBMZW5ndGgxID49IGluc2VydGlvbi5sZW5ndGggLyAyKSAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0VRVUFMLCBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIG92ZXJsYXBMZW5ndGgxKV0pLCBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcoMCwgZGVsZXRpb24ubGVuZ3RoIC0gb3ZlcmxhcExlbmd0aDEpLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKG92ZXJsYXBMZW5ndGgxKSwgcG9pbnRlcisrKSA6IChvdmVybGFwTGVuZ3RoMiA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBMZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSAmJiAoZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIFtESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcExlbmd0aDIpXSksIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJULCBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBpbnNlcnRpb24uc3Vic3RyaW5nKDAsIGluc2VydGlvbi5sZW5ndGggLSBvdmVybGFwTGVuZ3RoMiksIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFLCBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcExlbmd0aDIpLCBwb2ludGVyKyspLCBwb2ludGVyKys7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICByZXR1cm4gZGlmZnM7XG59XG5jb25zdCBub25BbHBoYU51bWVyaWNSZWdleCA9IC9bXmEtekEtWjAtOV0vLCB3aGl0ZXNwYWNlUmVnZXggPSAvXFxzLywgbGluZWJyZWFrUmVnZXggPSAvW1xcclxcbl0vLCBibGFua2xpbmVFbmRSZWdleCA9IC9cXG5cXHI/XFxuJC8sIGJsYW5rbGluZVN0YXJ0UmVnZXggPSAvXlxccj9cXG5cXHI/XFxuLztcbmZ1bmN0aW9uIGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKHJhd0RpZmZzKSB7XG4gIGNvbnN0IGRpZmZzID0gcmF3RGlmZnMubWFwKChkaWZmMikgPT4gY2xvbmVEaWZmKGRpZmYyKSk7XG4gIGZ1bmN0aW9uIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShvbmUsIHR3bykge1xuICAgIGlmICghb25lIHx8ICF0d28pXG4gICAgICByZXR1cm4gNjtcbiAgICBjb25zdCBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpLCBjaGFyMiA9IHR3by5jaGFyQXQoMCksIG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleCksIHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJiBjaGFyMS5tYXRjaCh3aGl0ZXNwYWNlUmVnZXgpLCB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2god2hpdGVzcGFjZVJlZ2V4KSwgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmIGNoYXIyLm1hdGNoKGxpbmVicmVha1JlZ2V4KSwgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKGJsYW5rbGluZUVuZFJlZ2V4KSwgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXgpO1xuICAgIHJldHVybiBibGFua0xpbmUxIHx8IGJsYW5rTGluZTIgPyA1IDogbGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyID8gNCA6IG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyID8gMyA6IHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyID8gMiA6IG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMiA/IDEgOiAwO1xuICB9XG4gIGxldCBwb2ludGVyID0gMTtcbiAgZm9yICg7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxOyApIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgbGV0IGVxdWFsaXR5MSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSwgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdLCBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICBjb25zdCBjb21tb25PZmZzZXQgPSBnZXRDb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpLCBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG4gICAgICBsZXQgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MSwgYmVzdEVkaXQgPSBlZGl0LCBiZXN0RXF1YWxpdHkyID0gZXF1YWxpdHkyLCBiZXN0U2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgZm9yICg7IGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApOyApIHtcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApLCBlZGl0ID0gZWRpdC5zdWJzdHJpbmcoMSkgKyBlcXVhbGl0eTIuY2hhckF0KDApLCBlcXVhbGl0eTIgPSBlcXVhbGl0eTIuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBzY29yZSA9IGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlcXVhbGl0eTEsIGVkaXQpICsgZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVkaXQsIGVxdWFsaXR5Mik7XG4gICAgICAgIHNjb3JlID49IGJlc3RTY29yZSAmJiAoYmVzdFNjb3JlID0gc2NvcmUsIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTEsIGJlc3RFZGl0ID0gZWRpdCwgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5Mik7XG4gICAgICB9XG4gICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEgJiYgKGJlc3RFcXVhbGl0eTEgPyBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxIDogKGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSksIHBvaW50ZXItLSksIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQsIGJlc3RFcXVhbGl0eTIgPyBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyIDogKGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSksIHBvaW50ZXItLSkpO1xuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gY2xlYW51cE1lcmdlKHJhd0RpZmZzKSB7XG4gIGxldCBkaWZmcyA9IHJhd0RpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpO1xuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBcIlwiXSk7XG4gIGxldCBwb2ludGVyID0gMCwgY291bnREZWxldGUgPSAwLCBjb3VudEluc2VydCA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIiwgY29tbW9ubGVuZ3RoO1xuICBmb3IgKDsgcG9pbnRlciA8IGRpZmZzLmxlbmd0aDsgKVxuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50SW5zZXJ0KyssIHRleHRJbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV0sIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBjb3VudERlbGV0ZSsrLCB0ZXh0RGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdLCBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0ID4gMSA/IChjb3VudERlbGV0ZSAhPT0gMCAmJiBjb3VudEluc2VydCAhPT0gMCAmJiAoY29tbW9ubGVuZ3RoID0gZ2V0Q29tbW9uUHJlZml4KHRleHRJbnNlcnQsIHRleHREZWxldGUpLCBjb21tb25sZW5ndGggIT09IDAgJiYgKHBvaW50ZXIgLSBjb3VudERlbGV0ZSAtIGNvdW50SW5zZXJ0ID4gMCAmJiBkaWZmc1twb2ludGVyIC0gY291bnREZWxldGUgLSBjb3VudEluc2VydCAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gZGlmZnNbcG9pbnRlciAtIGNvdW50RGVsZXRlIC0gY291bnRJbnNlcnQgLSAxXVsxXSArPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyhcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNvbW1vbmxlbmd0aFxuICAgICAgICApIDogKGRpZmZzLnNwbGljZSgwLCAwLCBbRElGRl9FUVVBTCwgdGV4dEluc2VydC5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKV0pLCBwb2ludGVyKyspLCB0ZXh0SW5zZXJ0ID0gdGV4dEluc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCkpLCBjb21tb25sZW5ndGggPSBnZXRDb21tb25TdWZmaXgodGV4dEluc2VydCwgdGV4dERlbGV0ZSksIGNvbW1vbmxlbmd0aCAhPT0gMCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0SW5zZXJ0LnN1YnN0cmluZyh0ZXh0SW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXSwgdGV4dEluc2VydCA9IHRleHRJbnNlcnQuc3Vic3RyaW5nKDAsIHRleHRJbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSwgdGV4dERlbGV0ZSA9IHRleHREZWxldGUuc3Vic3RyaW5nKDAsIHRleHREZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSkpLCBwb2ludGVyIC09IGNvdW50RGVsZXRlICsgY291bnRJbnNlcnQsIGRpZmZzLnNwbGljZShwb2ludGVyLCBjb3VudERlbGV0ZSArIGNvdW50SW5zZXJ0KSwgdGV4dERlbGV0ZS5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9ERUxFVEUsIHRleHREZWxldGVdKSwgcG9pbnRlcisrKSwgdGV4dEluc2VydC5sZW5ndGggJiYgKGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBbRElGRl9JTlNFUlQsIHRleHRJbnNlcnRdKSwgcG9pbnRlcisrKSwgcG9pbnRlcisrKSA6IHBvaW50ZXIgIT09IDAgJiYgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMID8gKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpKSA6IHBvaW50ZXIrKywgY291bnRJbnNlcnQgPSAwLCBjb3VudERlbGV0ZSA9IDAsIHRleHREZWxldGUgPSBcIlwiLCB0ZXh0SW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgb3BlcmF0aW9uXCIpO1xuICAgIH1cbiAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09IFwiXCIgJiYgZGlmZnMucG9wKCk7XG4gIGxldCBoYXNDaGFuZ2VzID0gITE7XG4gIGZvciAocG9pbnRlciA9IDE7IHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxOyApXG4gICAgZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0VRVUFMICYmIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0gPyAoZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCksIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSA6IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdICYmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlciArIDFdWzFdLCBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZyhkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSwgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKSwgaGFzQ2hhbmdlcyA9ICEwKSksIHBvaW50ZXIrKztcbiAgcmV0dXJuIGhhc0NoYW5nZXMgJiYgKGRpZmZzID0gY2xlYW51cE1lcmdlKGRpZmZzKSksIGRpZmZzO1xufVxuZnVuY3Rpb24gdHJ1ZUNvdW50KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKChuLCBib29sKSA9PiBuICsgKGJvb2wgPyAxIDogMCksIDApO1xufVxuZnVuY3Rpb24gY2xlYW51cEVmZmljaWVuY3kocmF3RGlmZnMsIGVkaXRDb3N0ID0gNCkge1xuICBsZXQgZGlmZnMgPSByYXdEaWZmcy5tYXAoKGRpZmYyKSA9PiBjbG9uZURpZmYoZGlmZjIpKSwgaGFzQ2hhbmdlcyA9ICExO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMCwgbGFzdEVxdWFsaXR5ID0gbnVsbCwgcG9pbnRlciA9IDAsIHByZUlucyA9ICExLCBwcmVEZWwgPSAhMSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITE7XG4gIGZvciAoOyBwb2ludGVyIDwgZGlmZnMubGVuZ3RoOyApXG4gICAgZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwgPyAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZWRpdENvc3QgJiYgKHBvc3RJbnMgfHwgcG9zdERlbCkgPyAoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlciwgcHJlSW5zID0gcG9zdElucywgcHJlRGVsID0gcG9zdERlbCwgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV0pIDogKGVxdWFsaXRpZXNMZW5ndGggPSAwLCBsYXN0RXF1YWxpdHkgPSBudWxsKSwgcG9zdElucyA9ICExLCBwb3N0RGVsID0gITEpIDogKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSA/IHBvc3REZWwgPSAhMCA6IHBvc3RJbnMgPSAhMCwgbGFzdEVxdWFsaXR5ICYmIChwcmVJbnMgJiYgcHJlRGVsICYmIHBvc3RJbnMgJiYgcG9zdERlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZWRpdENvc3QgLyAyICYmIHRydWVDb3VudChwcmVJbnMsIHByZURlbCwgcG9zdElucywgcG9zdERlbCkgPT09IDMpICYmIChkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsIFtESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5XSksIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVCwgZXF1YWxpdGllc0xlbmd0aC0tLCBsYXN0RXF1YWxpdHkgPSBudWxsLCBwcmVJbnMgJiYgcHJlRGVsID8gKHBvc3RJbnMgPSAhMCwgcG9zdERlbCA9ICEwLCBlcXVhbGl0aWVzTGVuZ3RoID0gMCkgOiAoZXF1YWxpdGllc0xlbmd0aC0tLCBwb2ludGVyID0gZXF1YWxpdGllc0xlbmd0aCA+IDAgPyBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xLCBwb3N0SW5zID0gITEsIHBvc3REZWwgPSAhMSksIGhhc0NoYW5nZXMgPSAhMCkpLCBwb2ludGVyKys7XG4gIHJldHVybiBoYXNDaGFuZ2VzICYmIChkaWZmcyA9IGNsZWFudXBNZXJnZShkaWZmcykpLCBkaWZmcztcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wU3ltYm9scyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX3Byb3BJc0VudW0kMSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUsIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19zcHJlYWRWYWx1ZXMkMSA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBfX2hhc093blByb3AkMS5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcCQxKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scyQxKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyQxKGIpKVxuICAgICAgX19wcm9wSXNFbnVtJDEuY2FsbChiLCBwcm9wKSAmJiBfX2RlZk5vcm1hbFByb3AkMShhLCBwcm9wLCBiW3Byb3BdKTtcbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvKipcbiAgICogQXQgd2hhdCBwb2ludCBpcyBubyBtYXRjaCBkZWNsYXJlZCAoMC4wID0gcGVyZmVjdGlvbiwgMS4wID0gdmVyeSBsb29zZSkuXG4gICAqL1xuICB0aHJlc2hvbGQ6IDAuNSxcbiAgLyoqXG4gICAqIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxuICAgKiBBIG1hdGNoIHRoaXMgbWFueSBjaGFyYWN0ZXJzIGF3YXkgZnJvbSB0aGUgZXhwZWN0ZWQgbG9jYXRpb24gd2lsbCBhZGRcbiAgICogMS4wIHRvIHRoZSBzY29yZSAoMC4wIGlzIGEgcGVyZmVjdCBtYXRjaCkuXG4gICAqL1xuICBkaXN0YW5jZTogMWUzXG59O1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhvcHRpb25zKSB7XG4gIHJldHVybiBfX3NwcmVhZFZhbHVlcyQxKF9fc3ByZWFkVmFsdWVzJDEoe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xufVxuY29uc3QgTUFYX0JJVFMkMSA9IDMyO1xuZnVuY3Rpb24gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRzID0ge30pIHtcbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX0JJVFMkMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuXCIpO1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0cyhvcHRzKSwgcyA9IGdldEFscGhhYmV0RnJvbVBhdHRlcm4ocGF0dGVybik7XG4gIGZ1bmN0aW9uIGdldEJpdGFwU2NvcmUoZSwgeCkge1xuICAgIGNvbnN0IGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoLCBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICByZXR1cm4gb3B0aW9ucy5kaXN0YW5jZSA/IGFjY3VyYWN5ICsgcHJveGltaXR5IC8gb3B0aW9ucy5kaXN0YW5jZSA6IHByb3hpbWl0eSA/IDEgOiBhY2N1cmFjeTtcbiAgfVxuICBsZXQgc2NvcmVUaHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCwgYmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xuICBiZXN0TG9jICE9PSAtMSAmJiAoc2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihnZXRCaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCksIGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSwgYmVzdExvYyAhPT0gLTEgJiYgKHNjb3JlVGhyZXNob2xkID0gTWF0aC5taW4oZ2V0Qml0YXBTY29yZSgwLCBiZXN0TG9jKSwgc2NvcmVUaHJlc2hvbGQpKSk7XG4gIGNvbnN0IG1hdGNobWFzayA9IDEgPDwgcGF0dGVybi5sZW5ndGggLSAxO1xuICBiZXN0TG9jID0gLTE7XG4gIGxldCBiaW5NaW4sIGJpbk1pZCwgYmluTWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aCwgbGFzdFJkID0gW107XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIGZvciAoYmluTWluID0gMCwgYmluTWlkID0gYmluTWF4OyBiaW5NaW4gPCBiaW5NaWQ7IClcbiAgICAgIGdldEJpdGFwU2NvcmUoZCwgbG9jICsgYmluTWlkKSA8PSBzY29yZVRocmVzaG9sZCA/IGJpbk1pbiA9IGJpbk1pZCA6IGJpbk1heCA9IGJpbk1pZCwgYmluTWlkID0gTWF0aC5mbG9vcigoYmluTWF4IC0gYmluTWluKSAvIDIgKyBiaW5NaW4pO1xuICAgIGJpbk1heCA9IGJpbk1pZDtcbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5NaWQgKyAxKTtcbiAgICBjb25zdCBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5NaWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoLCByZCA9IG5ldyBBcnJheShmaW5pc2ggKyAyKTtcbiAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcbiAgICBmb3IgKGxldCBqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgIGNvbnN0IGNoYXJNYXRjaCA9IHNbdGV4dC5jaGFyQXQoaiAtIDEpXTtcbiAgICAgIGlmIChkID09PSAwID8gcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCA6IHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RSZFtqICsgMV0gfCBsYXN0UmRbal0pIDw8IDEgfCAxKSB8IGxhc3RSZFtqICsgMV0sIHJkW2pdICYgbWF0Y2htYXNrKSB7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZ2V0Qml0YXBTY29yZShkLCBqIC0gMSk7XG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZClcbiAgICAgICAgICBpZiAoc2NvcmVUaHJlc2hvbGQgPSBzY29yZSwgYmVzdExvYyA9IGogLSAxLCBiZXN0TG9jID4gbG9jKVxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdExvYyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChnZXRCaXRhcFNjb3JlKGQgKyAxLCBsb2MpID4gc2NvcmVUaHJlc2hvbGQpXG4gICAgICBicmVhaztcbiAgICBsYXN0UmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdExvYztcbn1cbmZ1bmN0aW9uIGdldEFscGhhYmV0RnJvbVBhdHRlcm4ocGF0dGVybikge1xuICBjb25zdCBzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKylcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKylcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSB8PSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gaSAtIDE7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gbWF0Y2godGV4dCwgcGF0dGVybiwgc2VhcmNoTG9jYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICBpZiAodGV4dCA9PT0gbnVsbCB8fCBwYXR0ZXJuID09PSBudWxsIHx8IHNlYXJjaExvY2F0aW9uID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk51bGwgaW5wdXQuIChtYXRjaCgpKVwiKTtcbiAgY29uc3QgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VhcmNoTG9jYXRpb24sIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKVxuICAgIHJldHVybiAwO1xuICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pXG4gICAgICByZXR1cm4gbG9jO1xuICB9IGVsc2UgcmV0dXJuIC0xO1xuICByZXR1cm4gYml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspXG4gICAgZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUICYmICh0ZXh0W3hdID0gZGlmZnNbeF1bMV0pO1xuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQyKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKylcbiAgICBkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUgJiYgKHRleHRbeF0gPSBkaWZmc1t4XVsxXSk7XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBsZXZlbnNodGVpbihkaWZmcykge1xuICBsZXQgbGV2ZW4gPSAwLCBpbnNlcnRpb25zID0gMCwgZGVsZXRpb25zID0gMDtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IG9wID0gZGlmZnNbeF1bMF0sIGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGxldmVuICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyksIGluc2VydGlvbnMgPSAwLCBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGlmZiBvcGVyYXRpb24uXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV2ZW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKSwgbGV2ZW47XG59XG5mdW5jdGlvbiB4SW5kZXgoZGlmZnMsIGxvY2F0aW9uKSB7XG4gIGxldCBjaGFyczEgPSAwLCBjaGFyczIgPSAwLCBsYXN0Q2hhcnMxID0gMCwgbGFzdENoYXJzMiA9IDAsIHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGggJiYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCAmJiAoY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aCksIGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSAmJiAoY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aCksICEoY2hhcnMxID4gbG9jYXRpb24pKTsgeCsrKVxuICAgIGxhc3RDaGFyczEgPSBjaGFyczEsIGxhc3RDaGFyczIgPSBjaGFyczI7XG4gIHJldHVybiBkaWZmcy5sZW5ndGggIT09IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFID8gbGFzdENoYXJzMiA6IGxhc3RDaGFyczIgKyAobG9jYXRpb24gLSBsYXN0Q2hhcnMxKTtcbn1cbmZ1bmN0aW9uIGNvdW50VXRmOEJ5dGVzKHN0cikge1xuICBsZXQgYnl0ZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcbiAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBjb2RlcG9pbnRcIik7XG4gICAgYnl0ZXMgKz0gdXRmOGxlbihjb2RlUG9pbnQpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGFkanVzdEluZGljaWVzVG9VY3MyKHBhdGNoZXMsIGJhc2UsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgYnl0ZU9mZnNldCA9IDAsIGlkeCA9IDA7XG4gIGZ1bmN0aW9uIGFkdmFuY2VUbyh0YXJnZXQpIHtcbiAgICBmb3IgKDsgYnl0ZU9mZnNldCA8IHRhcmdldDsgKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBiYXNlLmNvZGVQb2ludEF0KGlkeCk7XG4gICAgICBpZiAodHlwZW9mIGNvZGVQb2ludCA+IFwidVwiKVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgYnl0ZU9mZnNldCArPSB1dGY4bGVuKGNvZGVQb2ludCksIGNvZGVQb2ludCA+IDY1NTM1ID8gaWR4ICs9IDIgOiBpZHggKz0gMTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmFsbG93RXhjZWVkaW5nSW5kaWNlcyAmJiBieXRlT2Zmc2V0ICE9PSB0YXJnZXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGV0ZXJtaW5lIGJ5dGUgb2Zmc2V0XCIpO1xuICAgIHJldHVybiBpZHg7XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXRjaCBvZiBwYXRjaGVzKVxuICAgIGFkanVzdGVkLnB1c2goe1xuICAgICAgZGlmZnM6IHBhdGNoLmRpZmZzLm1hcCgoZGlmZjIpID0+IGNsb25lRGlmZihkaWZmMikpLFxuICAgICAgc3RhcnQxOiBhZHZhbmNlVG8ocGF0Y2guc3RhcnQxKSxcbiAgICAgIHN0YXJ0MjogYWR2YW5jZVRvKHBhdGNoLnN0YXJ0MiksXG4gICAgICB1dGY4U3RhcnQxOiBwYXRjaC51dGY4U3RhcnQxLFxuICAgICAgdXRmOFN0YXJ0MjogcGF0Y2gudXRmOFN0YXJ0MixcbiAgICAgIGxlbmd0aDE6IHBhdGNoLmxlbmd0aDEsXG4gICAgICBsZW5ndGgyOiBwYXRjaC5sZW5ndGgyLFxuICAgICAgdXRmOExlbmd0aDE6IHBhdGNoLnV0ZjhMZW5ndGgxLFxuICAgICAgdXRmOExlbmd0aDI6IHBhdGNoLnV0ZjhMZW5ndGgyXG4gICAgfSk7XG4gIHJldHVybiBhZGp1c3RlZDtcbn1cbmZ1bmN0aW9uIHV0ZjhsZW4oY29kZVBvaW50KSB7XG4gIHJldHVybiBjb2RlUG9pbnQgPD0gMTI3ID8gMSA6IGNvZGVQb2ludCA8PSAyMDQ3ID8gMiA6IGNvZGVQb2ludCA8PSA2NTUzNSA/IDMgOiA0O1xufVxuY29uc3QgTUFYX0JJVFMgPSAzMiwgREVGQVVMVF9NQVJHSU4gPSA0O1xuZnVuY3Rpb24gYWRkUGFkZGluZyhwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gbWFyZ2luO1xuICBsZXQgbnVsbFBhZGRpbmcgPSBcIlwiO1xuICBmb3IgKGxldCB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspXG4gICAgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGNoZXMpXG4gICAgcC5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aCwgcC5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aCwgcC51dGY4U3RhcnQxICs9IHBhZGRpbmdMZW5ndGgsIHAudXRmOFN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xuICBsZXQgcGF0Y2ggPSBwYXRjaGVzWzBdLCBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwIHx8IGRpZmZzWzBdWzBdICE9PSBESUZGX0VRVUFMKVxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLnN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC5zdGFydDIgLT0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4U3RhcnQyIC09IHBhZGRpbmdMZW5ndGgsIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlyc3REaWZmTGVuZ3RoID0gZGlmZnNbMF1bMV0ubGVuZ3RoLCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBmaXJzdERpZmZMZW5ndGg7XG4gICAgZGlmZnNbMF1bMV0gPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoZmlyc3REaWZmTGVuZ3RoKSArIGRpZmZzWzBdWzFdLCBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MSAtPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MiAtPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGV4dHJhTGVuZ3RoO1xuICB9XG4gIGlmIChwYXRjaCA9IHBhdGNoZXNbcGF0Y2hlcy5sZW5ndGggLSAxXSwgZGlmZnMgPSBwYXRjaC5kaWZmcywgZGlmZnMubGVuZ3RoID09PSAwIHx8IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzBdICE9PSBESUZGX0VRVUFMKVxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSksIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdICs9IG51bGxQYWRkaW5nLnN1YnN0cmluZygwLCBleHRyYUxlbmd0aCksIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGV4dHJhTGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEsIHN0YXJ0Mikge1xuICByZXR1cm4ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDEsXG4gICAgc3RhcnQyLFxuICAgIHV0ZjhTdGFydDE6IHN0YXJ0MSxcbiAgICB1dGY4U3RhcnQyOiBzdGFydDIsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwLFxuICAgIHV0ZjhMZW5ndGgxOiAwLFxuICAgIHV0ZjhMZW5ndGgyOiAwXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdE1heChwYXRjaGVzLCBtYXJnaW4gPSBERUZBVUxUX01BUkdJTikge1xuICBjb25zdCBwYXRjaFNpemUgPSBNQVhfQklUUztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaFNpemUpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgcGF0Y2hlcy5zcGxpY2UoeC0tLCAxKTtcbiAgICBsZXQgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxLCBzdGFydDIgPSBiaWdwYXRjaC5zdGFydDIsIHByZUNvbnRleHQgPSBcIlwiO1xuICAgIGZvciAoOyBiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDA7ICkge1xuICAgICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdChzdGFydDEgLSBwcmVDb250ZXh0Lmxlbmd0aCwgc3RhcnQyIC0gcHJlQ29udGV4dC5sZW5ndGgpO1xuICAgICAgbGV0IGVtcHR5ID0gITA7XG4gICAgICBpZiAocHJlQ29udGV4dCAhPT0gXCJcIikge1xuICAgICAgICBjb25zdCBwcmVjb250ZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMocHJlQ29udGV4dCk7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwcmVDb250ZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgPSBwcmVjb250ZXh0Qnl0ZUNvdW50LCBwYXRjaC5sZW5ndGgyID0gcHJlQ29udGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyID0gcHJlY29udGV4dEJ5dGVDb3VudCwgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlQ29udGV4dF0pO1xuICAgICAgfVxuICAgICAgZm9yICg7IGJpZ3BhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJiBwYXRjaC5sZW5ndGgxIDwgcGF0Y2hTaXplIC0gbWFyZ2luOyApIHtcbiAgICAgICAgY29uc3QgZGlmZlR5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgbGV0IGRpZmZUZXh0ID0gYmlncGF0Y2guZGlmZnNbMF1bMV0sIGRpZmZUZXh0Qnl0ZUNvdW50ID0gY291bnRVdGY4Qnl0ZXMoZGlmZlRleHQpO1xuICAgICAgICBpZiAoZGlmZlR5cGUgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDIgKz0gZGlmZlRleHQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGRpZmYyID0gYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcbiAgICAgICAgICBkaWZmMiAmJiBwYXRjaC5kaWZmcy5wdXNoKGRpZmYyKSwgZW1wdHkgPSAhMTtcbiAgICAgICAgfSBlbHNlIGRpZmZUeXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT09IDEgJiYgcGF0Y2guZGlmZnNbMF1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZlRleHQubGVuZ3RoID4gMiAqIHBhdGNoU2l6ZSA/IChwYXRjaC5sZW5ndGgxICs9IGRpZmZUZXh0Lmxlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZGlmZlRleHRCeXRlQ291bnQsIHN0YXJ0MSArPSBkaWZmVGV4dC5sZW5ndGgsIGVtcHR5ID0gITEsIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZUeXBlLCBkaWZmVGV4dF0pLCBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKSA6IChkaWZmVGV4dCA9IGRpZmZUZXh0LnN1YnN0cmluZygwLCBwYXRjaFNpemUgLSBwYXRjaC5sZW5ndGgxIC0gbWFyZ2luKSwgZGlmZlRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCksIHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBkaWZmVGV4dEJ5dGVDb3VudCwgc3RhcnQxICs9IGRpZmZUZXh0Lmxlbmd0aCwgZGlmZlR5cGUgPT09IERJRkZfRVFVQUwgPyAocGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dC5sZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZUZXh0Qnl0ZUNvdW50LCBzdGFydDIgKz0gZGlmZlRleHQubGVuZ3RoKSA6IGVtcHR5ID0gITEsIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZUeXBlLCBkaWZmVGV4dF0pLCBkaWZmVGV4dCA9PT0gYmlncGF0Y2guZGlmZnNbMF1bMV0gPyBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpIDogYmlncGF0Y2guZGlmZnNbMF1bMV0gPSBiaWdwYXRjaC5kaWZmc1swXVsxXS5zdWJzdHJpbmcoZGlmZlRleHQubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBwcmVDb250ZXh0ID0gZGlmZlRleHQyKHBhdGNoLmRpZmZzKSwgcHJlQ29udGV4dCA9IHByZUNvbnRleHQuc3Vic3RyaW5nKHByZUNvbnRleHQubGVuZ3RoIC0gbWFyZ2luKTtcbiAgICAgIGNvbnN0IHBvc3RDb250ZXh0ID0gZGlmZlRleHQxKGJpZ3BhdGNoLmRpZmZzKS5zdWJzdHJpbmcoMCwgbWFyZ2luKSwgcG9zdENvbnRleHRCeXRlQ291bnQgPSBjb3VudFV0ZjhCeXRlcyhwb3N0Q29udGV4dCk7XG4gICAgICBwb3N0Q29udGV4dCAhPT0gXCJcIiAmJiAocGF0Y2gubGVuZ3RoMSArPSBwb3N0Q29udGV4dC5sZW5ndGgsIHBhdGNoLmxlbmd0aDIgKz0gcG9zdENvbnRleHQubGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMSArPSBwb3N0Q29udGV4dEJ5dGVDb3VudCwgcGF0Y2gudXRmOExlbmd0aDIgKz0gcG9zdENvbnRleHRCeXRlQ291bnQsIHBhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJiBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCA/IHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3RDb250ZXh0IDogcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcG9zdENvbnRleHRdKSksIGVtcHR5IHx8IHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwbHkocGF0Y2hlcywgb3JpZ2luYWxUZXh0LCBvcHRzID0ge30pIHtcbiAgaWYgKHR5cGVvZiBwYXRjaGVzID09IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0Y2hlcyBtdXN0IGJlIGFuIGFycmF5IC0gcGFzcyB0aGUgcGF0Y2ggdG8gYHBhcnNlUGF0Y2goKWAgZmlyc3RcIik7XG4gIGxldCB0ZXh0ID0gb3JpZ2luYWxUZXh0O1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIGNvbnN0IHBhcnNlZCA9IGFkanVzdEluZGljaWVzVG9VY3MyKHBhdGNoZXMsIHRleHQsIHtcbiAgICBhbGxvd0V4Y2VlZGluZ0luZGljZXM6IG9wdHMuYWxsb3dFeGNlZWRpbmdJbmRpY2VzXG4gIH0pLCBtYXJnaW4gPSBvcHRzLm1hcmdpbiB8fCBERUZBVUxUX01BUkdJTiwgZGVsZXRlVGhyZXNob2xkID0gb3B0cy5kZWxldGVUaHJlc2hvbGQgfHwgMC40LCBudWxsUGFkZGluZyA9IGFkZFBhZGRpbmcocGFyc2VkLCBtYXJnaW4pO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmcsIHNwbGl0TWF4KHBhcnNlZCwgbWFyZ2luKTtcbiAgbGV0IGRlbHRhID0gMDtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhcnNlZC5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IGV4cGVjdGVkTG9jID0gcGFyc2VkW3hdLnN0YXJ0MiArIGRlbHRhLCB0ZXh0MSA9IGRpZmZUZXh0MShwYXJzZWRbeF0uZGlmZnMpO1xuICAgIGxldCBzdGFydExvYywgZW5kTG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IE1BWF9CSVRTID8gKHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEuc3Vic3RyaW5nKDAsIE1BWF9CSVRTKSwgZXhwZWN0ZWRMb2MpLCBzdGFydExvYyAhPT0gLTEgJiYgKGVuZExvYyA9IG1hdGNoKFxuICAgICAgdGV4dCxcbiAgICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBNQVhfQklUUyksXG4gICAgICBleHBlY3RlZExvYyArIHRleHQxLmxlbmd0aCAtIE1BWF9CSVRTXG4gICAgKSwgKGVuZExvYyA9PT0gLTEgfHwgc3RhcnRMb2MgPj0gZW5kTG9jKSAmJiAoc3RhcnRMb2MgPSAtMSkpKSA6IHN0YXJ0TG9jID0gbWF0Y2godGV4dCwgdGV4dDEsIGV4cGVjdGVkTG9jKSwgc3RhcnRMb2MgPT09IC0xKVxuICAgICAgcmVzdWx0c1t4XSA9ICExLCBkZWx0YSAtPSBwYXJzZWRbeF0ubGVuZ3RoMiAtIHBhcnNlZFt4XS5sZW5ndGgxO1xuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0c1t4XSA9ICEwLCBkZWx0YSA9IHN0YXJ0TG9jIC0gZXhwZWN0ZWRMb2M7XG4gICAgICBsZXQgdGV4dDI7XG4gICAgICBpZiAoZW5kTG9jID09PSAtMSA/IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIHN0YXJ0TG9jICsgdGV4dDEubGVuZ3RoKSA6IHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRMb2MsIGVuZExvYyArIE1BWF9CSVRTKSwgdGV4dDEgPT09IHRleHQyKVxuICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRMb2MpICsgZGlmZlRleHQyKHBhcnNlZFt4XS5kaWZmcykgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZzID0gZGlmZih0ZXh0MSwgdGV4dDIsIHsgY2hlY2tMaW5lczogITEgfSk7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiBNQVhfQklUUyAmJiBsZXZlbnNodGVpbihkaWZmcykgLyB0ZXh0MS5sZW5ndGggPiBkZWxldGVUaHJlc2hvbGQpXG4gICAgICAgICAgcmVzdWx0c1t4XSA9ICExO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkaWZmcyA9IGNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICBsZXQgaW5kZXgxID0gMCwgaW5kZXgyID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhcnNlZFt4XS5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgY29uc3QgbW9kID0gcGFyc2VkW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgbW9kWzBdICE9PSBESUZGX0VRVUFMICYmIChpbmRleDIgPSB4SW5kZXgoZGlmZnMsIGluZGV4MSkpLCBtb2RbMF0gPT09IERJRkZfSU5TRVJUID8gdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0TG9jICsgaW5kZXgyKSArIG1vZFsxXSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0TG9jICsgaW5kZXgyKSA6IG1vZFswXSA9PT0gRElGRl9ERUxFVEUgJiYgKHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydExvYyArIGluZGV4MikgKyB0ZXh0LnN1YnN0cmluZyhzdGFydExvYyArIHhJbmRleChkaWZmcywgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpKSwgbW9kWzBdICE9PSBESUZGX0RFTEVURSAmJiAoaW5kZXgxICs9IG1vZFsxXS5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpLCBbdGV4dCwgcmVzdWx0c107XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scywgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApICYmIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKVxuICAgICAgX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkgJiYgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICByZXR1cm4gYTtcbn07XG5jb25zdCBERUZBVUxUX09QVFMgPSB7XG4gIG1hcmdpbjogNFxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRPcHRzKG9wdHMgPSB7fSkge1xuICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIERFRkFVTFRfT1BUUyksIG9wdHMpO1xufVxuZnVuY3Rpb24gbWFrZShhLCBiLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBiID09IFwic3RyaW5nXCIpIHtcbiAgICBsZXQgZGlmZnMgPSBkaWZmKGEsIGIsIHsgY2hlY2tMaW5lczogITAgfSk7XG4gICAgcmV0dXJuIGRpZmZzLmxlbmd0aCA+IDIgJiYgKGRpZmZzID0gY2xlYW51cFNlbWFudGljKGRpZmZzKSwgZGlmZnMgPSBjbGVhbnVwRWZmaWNpZW5jeShkaWZmcykpLCBfbWFrZShhLCBkaWZmcywgZ2V0RGVmYXVsdE9wdHMob3B0aW9ucykpO1xuICB9XG4gIGlmIChhICYmIEFycmF5LmlzQXJyYXkoYSkgJiYgdHlwZW9mIGIgPiBcInVcIilcbiAgICByZXR1cm4gX21ha2UoZGlmZlRleHQxKGEpLCBhLCBnZXREZWZhdWx0T3B0cyhvcHRpb25zKSk7XG4gIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIGIgJiYgQXJyYXkuaXNBcnJheShiKSlcbiAgICByZXR1cm4gX21ha2UoYSwgYiwgZ2V0RGVmYXVsdE9wdHMob3B0aW9ucykpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNhbGwgZm9ybWF0IHRvIG1ha2UoKVwiKTtcbn1cbmZ1bmN0aW9uIF9tYWtlKHRleHRBLCBkaWZmcywgb3B0aW9ucykge1xuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdO1xuICBsZXQgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCgwLCAwKSwgcGF0Y2hEaWZmTGVuZ3RoID0gMCwgY2hhckNvdW50MSA9IDAsIGNoYXJDb3VudDIgPSAwLCB1dGY4Q291bnQxID0gMCwgdXRmOENvdW50MiA9IDAsIHByZXBhdGNoVGV4dCA9IHRleHRBLCBwb3N0cGF0Y2hUZXh0ID0gdGV4dEE7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBjdXJyZW50RGlmZiA9IGRpZmZzW3hdLCBbZGlmZlR5cGUsIGRpZmZUZXh0XSA9IGN1cnJlbnREaWZmLCBkaWZmVGV4dExlbmd0aCA9IGRpZmZUZXh0Lmxlbmd0aCwgZGlmZkJ5dGVMZW5ndGggPSBjb3VudFV0ZjhCeXRlcyhkaWZmVGV4dCk7XG4gICAgc3dpdGNoICghcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZUeXBlICE9PSBESUZGX0VRVUFMICYmIChwYXRjaC5zdGFydDEgPSBjaGFyQ291bnQxLCBwYXRjaC5zdGFydDIgPSBjaGFyQ291bnQyLCBwYXRjaC51dGY4U3RhcnQxID0gdXRmOENvdW50MSwgcGF0Y2gudXRmOFN0YXJ0MiA9IHV0ZjhDb3VudDIpLCBkaWZmVHlwZSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gY3VycmVudERpZmYsIHBhdGNoLmxlbmd0aDIgKz0gZGlmZlRleHRMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZCeXRlTGVuZ3RoLCBwb3N0cGF0Y2hUZXh0ID0gcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoMCwgY2hhckNvdW50MikgKyBkaWZmVGV4dCArIHBvc3RwYXRjaFRleHQuc3Vic3RyaW5nKGNoYXJDb3VudDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZlRleHRMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IGRpZmZCeXRlTGVuZ3RoLCBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBjdXJyZW50RGlmZiwgcG9zdHBhdGNoVGV4dCA9IHBvc3RwYXRjaFRleHQuc3Vic3RyaW5nKDAsIGNoYXJDb3VudDIpICsgcG9zdHBhdGNoVGV4dC5zdWJzdHJpbmcoY2hhckNvdW50MiArIGRpZmZUZXh0TGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGRpZmZUZXh0TGVuZ3RoIDw9IDIgKiBvcHRpb25zLm1hcmdpbiAmJiBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9PSB4ICsgMSA/IChwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBjdXJyZW50RGlmZiwgcGF0Y2gubGVuZ3RoMSArPSBkaWZmVGV4dExlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBkaWZmVGV4dExlbmd0aCwgcGF0Y2gudXRmOExlbmd0aDEgKz0gZGlmZkJ5dGVMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgyICs9IGRpZmZCeXRlTGVuZ3RoKSA6IGRpZmZUZXh0TGVuZ3RoID49IDIgKiBvcHRpb25zLm1hcmdpbiAmJiBwYXRjaERpZmZMZW5ndGggJiYgKGFkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoVGV4dCwgb3B0aW9ucyksIHBhdGNoZXMucHVzaChwYXRjaCksIHBhdGNoID0gY3JlYXRlUGF0Y2hPYmplY3QoLTEsIC0xKSwgcGF0Y2hEaWZmTGVuZ3RoID0gMCwgcHJlcGF0Y2hUZXh0ID0gcG9zdHBhdGNoVGV4dCwgY2hhckNvdW50MSA9IGNoYXJDb3VudDIsIHV0ZjhDb3VudDEgPSB1dGY4Q291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRpZmYgdHlwZVwiKTtcbiAgICB9XG4gICAgZGlmZlR5cGUgIT09IERJRkZfSU5TRVJUICYmIChjaGFyQ291bnQxICs9IGRpZmZUZXh0TGVuZ3RoLCB1dGY4Q291bnQxICs9IGRpZmZCeXRlTGVuZ3RoKSwgZGlmZlR5cGUgIT09IERJRkZfREVMRVRFICYmIChjaGFyQ291bnQyICs9IGRpZmZUZXh0TGVuZ3RoLCB1dGY4Q291bnQyICs9IGRpZmZCeXRlTGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hEaWZmTGVuZ3RoICYmIChhZGRDb250ZXh0KHBhdGNoLCBwcmVwYXRjaFRleHQsIG9wdGlvbnMpLCBwYXRjaGVzLnB1c2gocGF0Y2gpKSwgcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIGFkZENvbnRleHQocGF0Y2gsIHRleHQsIG9wdHMpIHtcbiAgaWYgKHRleHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgbGV0IHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEpLCBwYWRkaW5nID0gMDtcbiAgZm9yICg7IHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA8IE1BWF9CSVRTIC0gb3B0cy5tYXJnaW4gLSBvcHRzLm1hcmdpbjsgKVxuICAgIHBhZGRpbmcgKz0gb3B0cy5tYXJnaW4sIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIHBhZGRpbmcgKz0gb3B0cy5tYXJnaW47XG4gIGxldCBwcmVmaXhTdGFydCA9IHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmc7XG4gIHByZWZpeFN0YXJ0ID49IDEgJiYgaXNMb3dTdXJyb2dhdGUodGV4dFtwcmVmaXhTdGFydF0pICYmIHByZWZpeFN0YXJ0LS07XG4gIGNvbnN0IHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHByZWZpeFN0YXJ0LCBwYXRjaC5zdGFydDIpO1xuICBwcmVmaXggJiYgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XG4gIGNvbnN0IHByZWZpeExlbmd0aCA9IHByZWZpeC5sZW5ndGgsIHByZWZpeFV0ZjhMZW5ndGggPSBjb3VudFV0ZjhCeXRlcyhwcmVmaXgpO1xuICBsZXQgc3VmZml4RW5kID0gcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmc7XG4gIHN1ZmZpeEVuZCA8IHRleHQubGVuZ3RoICYmIGlzTG93U3Vycm9nYXRlKHRleHRbc3VmZml4RW5kXSkgJiYgc3VmZml4RW5kKys7XG4gIGNvbnN0IHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsIHN1ZmZpeEVuZCk7XG4gIHN1ZmZpeCAmJiBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0VRVUFMLCBzdWZmaXhdKTtcbiAgY29uc3Qgc3VmZml4TGVuZ3RoID0gc3VmZml4Lmxlbmd0aCwgc3VmZml4VXRmOExlbmd0aCA9IGNvdW50VXRmOEJ5dGVzKHN1ZmZpeCk7XG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXhMZW5ndGgsIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXhMZW5ndGgsIHBhdGNoLnV0ZjhTdGFydDEgLT0gcHJlZml4VXRmOExlbmd0aCwgcGF0Y2gudXRmOFN0YXJ0MiAtPSBwcmVmaXhVdGY4TGVuZ3RoLCBwYXRjaC5sZW5ndGgxICs9IHByZWZpeExlbmd0aCArIHN1ZmZpeExlbmd0aCwgcGF0Y2gubGVuZ3RoMiArPSBwcmVmaXhMZW5ndGggKyBzdWZmaXhMZW5ndGgsIHBhdGNoLnV0ZjhMZW5ndGgxICs9IHByZWZpeFV0ZjhMZW5ndGggKyBzdWZmaXhVdGY4TGVuZ3RoLCBwYXRjaC51dGY4TGVuZ3RoMiArPSBwcmVmaXhVdGY4TGVuZ3RoICsgc3VmZml4VXRmOExlbmd0aDtcbn1cbmNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbmZ1bmN0aW9uIHBhcnNlKHRleHRsaW5lKSB7XG4gIGlmICghdGV4dGxpbmUpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBwYXRjaGVzID0gW10sIGxpbmVzID0gdGV4dGxpbmUuc3BsaXQoYFxuYCk7XG4gIGxldCB0ZXh0UG9pbnRlciA9IDA7XG4gIGZvciAoOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbSA9IGxpbmVzW3RleHRQb2ludGVyXS5tYXRjaChwYXRjaEhlYWRlcik7XG4gICAgaWYgKCFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIHN0cmluZzogJHtsaW5lc1t0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaE9iamVjdCh0b0ludChtWzFdKSwgdG9JbnQobVszXSkpO1xuICAgIGZvciAocGF0Y2hlcy5wdXNoKHBhdGNoKSwgbVsyXSA9PT0gXCJcIiA/IChwYXRjaC5zdGFydDEtLSwgcGF0Y2gudXRmOFN0YXJ0MS0tLCBwYXRjaC5sZW5ndGgxID0gMSwgcGF0Y2gudXRmOExlbmd0aDEgPSAxKSA6IG1bMl0gPT09IFwiMFwiID8gKHBhdGNoLmxlbmd0aDEgPSAwLCBwYXRjaC51dGY4TGVuZ3RoMSA9IDApIDogKHBhdGNoLnN0YXJ0MS0tLCBwYXRjaC51dGY4U3RhcnQxLS0sIHBhdGNoLnV0ZjhMZW5ndGgxID0gdG9JbnQobVsyXSksIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC51dGY4TGVuZ3RoMSksIG1bNF0gPT09IFwiXCIgPyAocGF0Y2guc3RhcnQyLS0sIHBhdGNoLnV0ZjhTdGFydDItLSwgcGF0Y2gubGVuZ3RoMiA9IDEsIHBhdGNoLnV0ZjhMZW5ndGgyID0gMSkgOiBtWzRdID09PSBcIjBcIiA/IChwYXRjaC5sZW5ndGgyID0gMCwgcGF0Y2gudXRmOExlbmd0aDIgPSAwKSA6IChwYXRjaC5zdGFydDItLSwgcGF0Y2gudXRmOFN0YXJ0Mi0tLCBwYXRjaC51dGY4TGVuZ3RoMiA9IHRvSW50KG1bNF0pLCBwYXRjaC5sZW5ndGgyID0gcGF0Y2gudXRmOExlbmd0aDIpLCB0ZXh0UG9pbnRlcisrOyB0ZXh0UG9pbnRlciA8IGxpbmVzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBjdXJyZW50TGluZSA9IGxpbmVzW3RleHRQb2ludGVyXSwgc2lnbiA9IGN1cnJlbnRMaW5lLmNoYXJBdCgwKTtcbiAgICAgIGlmIChzaWduID09PSBcIkBcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoc2lnbiA9PT0gXCJcIikge1xuICAgICAgICB0ZXh0UG9pbnRlcisrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBsaW5lO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGluZSA9IGRlY29kZVVSSShjdXJyZW50TGluZS5zbGljZSgxKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgZXNjYXBlIGluIHBhcnNlOiAke2N1cnJlbnRMaW5lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgdXRmOERpZmYgPSBjb3VudFV0ZjhCeXRlcyhsaW5lKSAtIGxpbmUubGVuZ3RoO1xuICAgICAgaWYgKHNpZ24gPT09IFwiLVwiKVxuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKFtESUZGX0RFTEVURSwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZSBpZiAoc2lnbiA9PT0gXCIrXCIpXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfSU5TRVJULCBsaW5lXSksIHBhdGNoLmxlbmd0aDIgLT0gdXRmOERpZmY7XG4gICAgICBlbHNlIGlmIChzaWduID09PSBcIiBcIilcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbGluZV0pLCBwYXRjaC5sZW5ndGgxIC09IHV0ZjhEaWZmLCBwYXRjaC5sZW5ndGgyIC09IHV0ZjhEaWZmO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF0Y2ggbW9kZSBcIiR7c2lnbn1cIiBpbjogJHtsaW5lfWApO1xuICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiB0b0ludChudW0pIHtcbiAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHBhdGNoZXMpIHtcbiAgcmV0dXJuIHBhdGNoZXMubWFwKHN0cmluZ2lmeVBhdGNoKS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5UGF0Y2gocGF0Y2gpIHtcbiAgY29uc3QgeyB1dGY4TGVuZ3RoMSwgdXRmOExlbmd0aDIsIHV0ZjhTdGFydDEsIHV0ZjhTdGFydDIsIGRpZmZzIH0gPSBwYXRjaDtcbiAgbGV0IGNvb3JkczE7XG4gIHV0ZjhMZW5ndGgxID09PSAwID8gY29vcmRzMSA9IGAke3V0ZjhTdGFydDF9LDBgIDogdXRmOExlbmd0aDEgPT09IDEgPyBjb29yZHMxID0gYCR7dXRmOFN0YXJ0MSArIDF9YCA6IGNvb3JkczEgPSBgJHt1dGY4U3RhcnQxICsgMX0sJHt1dGY4TGVuZ3RoMX1gO1xuICBsZXQgY29vcmRzMjtcbiAgdXRmOExlbmd0aDIgPT09IDAgPyBjb29yZHMyID0gYCR7dXRmOFN0YXJ0Mn0sMGAgOiB1dGY4TGVuZ3RoMiA9PT0gMSA/IGNvb3JkczIgPSBgJHt1dGY4U3RhcnQyICsgMX1gIDogY29vcmRzMiA9IGAke3V0ZjhTdGFydDIgKyAxfSwke3V0ZjhMZW5ndGgyfWA7XG4gIGNvbnN0IHRleHQgPSBbYEBAIC0ke2Nvb3JkczF9ICske2Nvb3JkczJ9IEBAXG5gXTtcbiAgbGV0IG9wO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgb3AgPSBcIitcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBvcCA9IFwiLVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgb3AgPSBcIiBcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHBhdGNoIG9wZXJhdGlvbi5cIik7XG4gICAgfVxuICAgIHRleHRbeCArIDFdID0gYCR7b3AgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pfVxuYDtcbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpLnJlcGxhY2UoLyUyMC9nLCBcIiBcIik7XG59XG5leHBvcnQge1xuICBESUZGX0RFTEVURSxcbiAgRElGRl9FUVVBTCxcbiAgRElGRl9JTlNFUlQsXG4gIGFkanVzdEluZGljaWVzVG9VY3MyLFxuICBhcHBseSBhcyBhcHBseVBhdGNoZXMsXG4gIGNsZWFudXBFZmZpY2llbmN5LFxuICBjbGVhbnVwU2VtYW50aWMsXG4gIGRpZmYgYXMgbWFrZURpZmYsXG4gIG1ha2UgYXMgbWFrZVBhdGNoZXMsXG4gIG1hdGNoLFxuICBwYXJzZSBhcyBwYXJzZVBhdGNoLFxuICBzdHJpbmdpZnlQYXRjaCxcbiAgc3RyaW5naWZ5IGFzIHN0cmluZ2lmeVBhdGNoZXMsXG4gIHhJbmRleFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/.pnpm/@sanity+diff-match-patch@3.2.0/node_modules/@sanity/diff-match-patch/dist/index.js\n");

/***/ })

};
;